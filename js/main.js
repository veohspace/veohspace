! function(t) {
    var e = {};

    function n(r) {
        if (e[r]) return e[r].exports;
        var i = e[r] = {
            i: r,
            l: !1,
            exports: {}
        };
        return t[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports
    }
    n.m = t, n.c = e, n.d = function(t, e, r) {
        n.o(t, e) || Object.defineProperty(t, e, {
            enumerable: !0,
            get: r
        })
    }, n.r = function(t) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }, n.t = function(t, e) {
        if (1 & e && (t = n(t)), 8 & e) return t;
        if (4 & e && "object" == typeof t && t && t.__esModule) return t;
        var r = Object.create(null);
        if (n.r(r), Object.defineProperty(r, "default", {
                enumerable: !0,
                value: t
            }), 2 & e && "string" != typeof t)
            for (var i in t) n.d(r, i, function(e) {
                return t[e]
            }.bind(null, i));
        return r
    }, n.n = function(t) {
        var e = t && t.__esModule ? function() {
            return t.default
        } : function() {
            return t
        };
        return n.d(e, "a", e), e
    }, n.o = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }, n.p = "", n(n.s = 140)
}([function(t, e, n) {
    "use strict";

    function r() {}
    n.r(e), n.d(e, "WebGLRenderTargetCube", function() {
        return Ke
    }), n.d(e, "WebGLRenderTarget", function() {
        return qe
    }), n.d(e, "WebGLRenderer", function() {
        return ui
    }), n.d(e, "ShaderLib", function() {
        return sn
    }), n.d(e, "UniformsLib", function() {
        return an
    }), n.d(e, "UniformsUtils", function() {
        return nn
    }), n.d(e, "ShaderChunk", function() {
        return en
    }), n.d(e, "FogExp2", function() {
        return li
    }), n.d(e, "Fog", function() {
        return hi
    }), n.d(e, "Scene", function() {
        return fi
    }), n.d(e, "Sprite", function() {
        return mi
    }), n.d(e, "LOD", function() {
        return gi
    }), n.d(e, "SkinnedMesh", function() {
        return bi
    }), n.d(e, "Skeleton", function() {
        return yi
    }), n.d(e, "Bone", function() {
        return xi
    }), n.d(e, "Mesh", function() {
        return Nn
    }), n.d(e, "LineSegments", function() {
        return Mi
    }), n.d(e, "LineLoop", function() {
        return Si
    }), n.d(e, "Line", function() {
        return _i
    }), n.d(e, "Points", function() {
        return Ti
    }), n.d(e, "Group", function() {
        return ii
    }), n.d(e, "VideoTexture", function() {
        return Pi
    }), n.d(e, "DataTexture", function() {
        return Ze
    }), n.d(e, "DataTexture3D", function() {
        return Vn
    }), n.d(e, "CompressedTexture", function() {
        return Li
    }), n.d(e, "CubeTexture", function() {
        return Hn
    }), n.d(e, "CanvasTexture", function() {
        return Ai
    }), n.d(e, "DepthTexture", function() {
        return zi
    }), n.d(e, "Texture", function() {
        return Ye
    }), n.d(e, "CompressedTextureLoader", function() {
        return sa
    }), n.d(e, "DataTextureLoader", function() {
        return ca
    }), n.d(e, "CubeTextureLoader", function() {
        return la
    }), n.d(e, "TextureLoader", function() {
        return ha
    }), n.d(e, "ObjectLoader", function() {
        return ds
    }), n.d(e, "MaterialLoader", function() {
        return ss
    }), n.d(e, "BufferGeometryLoader", function() {
        return cs
    }), n.d(e, "DefaultLoadingManager", function() {
        return ia
    }), n.d(e, "LoadingManager", function() {
        return ra
    }), n.d(e, "JSONLoader", function() {
        return fs
    }), n.d(e, "ImageLoader", function() {
        return ua
    }), n.d(e, "ImageBitmapLoader", function() {
        return ys
    }), n.d(e, "FontLoader", function() {
        return _s
    }), n.d(e, "FileLoader", function() {
        return aa
    }), n.d(e, "Loader", function() {
        return ls
    }), n.d(e, "LoaderUtils", function() {
        return hs
    }), n.d(e, "Cache", function() {
        return na
    }), n.d(e, "AudioLoader", function() {
        return Ss
    }), n.d(e, "SpotLightShadow", function() {
        return ka
    }), n.d(e, "SpotLight", function() {
        return Ua
    }), n.d(e, "PointLight", function() {
        return Ba
    }), n.d(e, "RectAreaLight", function() {
        return Wa
    }), n.d(e, "HemisphereLight", function() {
        return Fa
    }), n.d(e, "DirectionalLightShadow", function() {
        return Ga
    }), n.d(e, "DirectionalLight", function() {
        return Ha
    }), n.d(e, "AmbientLight", function() {
        return Va
    }), n.d(e, "LightShadow", function() {
        return ja
    }), n.d(e, "Light", function() {
        return Oa
    }), n.d(e, "StereoCamera", function() {
        return Es
    }), n.d(e, "PerspectiveCamera", function() {
        return ai
    }), n.d(e, "OrthographicCamera", function() {
        return Na
    }), n.d(e, "CubeCamera", function() {
        return Ts
    }), n.d(e, "ArrayCamera", function() {
        return si
    }), n.d(e, "Camera", function() {
        return oi
    }), n.d(e, "AudioListener", function() {
        return Ps
    }), n.d(e, "PositionalAudio", function() {
        return As
    }), n.d(e, "AudioContext", function() {
        return Ms
    }), n.d(e, "AudioAnalyser", function() {
        return zs
    }), n.d(e, "Audio", function() {
        return Ls
    }), n.d(e, "VectorKeyframeTrack", function() {
        return is
    }), n.d(e, "StringKeyframeTrack", function() {
        return rs
    }), n.d(e, "QuaternionKeyframeTrack", function() {
        return ns
    }), n.d(e, "NumberKeyframeTrack", function() {
        return ts
    }), n.d(e, "ColorKeyframeTrack", function() {
        return $a
    }), n.d(e, "BooleanKeyframeTrack", function() {
        return Qa
    }), n.d(e, "PropertyMixer", function() {
        return Cs
    }), n.d(e, "PropertyBinding", function() {
        return Os
    }), n.d(e, "KeyframeTrack", function() {
        return Ja
    }), n.d(e, "AnimationUtils", function() {
        return Ya
    }), n.d(e, "AnimationObjectGroup", function() {
        return Fs
    }), n.d(e, "AnimationMixer", function() {
        return ks
    }), n.d(e, "AnimationClip", function() {
        return os
    }), n.d(e, "Uniform", function() {
        return Us
    }), n.d(e, "InstancedBufferGeometry", function() {
        return Bs
    }), n.d(e, "BufferGeometry", function() {
        return zn
    }), n.d(e, "Geometry", function() {
        return mn
    }), n.d(e, "InterleavedBufferAttribute", function() {
        return vi
    }), n.d(e, "InstancedInterleavedBuffer", function() {
        return Ns
    }), n.d(e, "InterleavedBuffer", function() {
        return di
    }), n.d(e, "InstancedBufferAttribute", function() {
        return Gs
    }), n.d(e, "Face3", function() {
        return ln
    }), n.d(e, "Object3D", function() {
        return vn
    }), n.d(e, "Raycaster", function() {
        return Hs
    }), n.d(e, "Layers", function() {
        return fn
    }), n.d(e, "EventDispatcher", function() {
        return r
    }), n.d(e, "Clock", function() {
        return Ys
    }), n.d(e, "QuaternionLinearInterpolant", function() {
        return es
    }), n.d(e, "LinearInterpolant", function() {
        return Ka
    }), n.d(e, "DiscreteInterpolant", function() {
        return Za
    }), n.d(e, "CubicInterpolant", function() {
        return qa
    }), n.d(e, "Interpolant", function() {
        return Xa
    }), n.d(e, "Triangle", function() {
        return Un
    }), n.d(e, "Math", function() {
        return ke
    }), n.d(e, "Spherical", function() {
        return Xs
    }), n.d(e, "Cylindrical", function() {
        return qs
    }), n.d(e, "Plane", function() {
        return $e
    }), n.d(e, "Frustum", function() {
        return tn
    }), n.d(e, "Sphere", function() {
        return Qe
    }), n.d(e, "Ray", function() {
        return kn
    }), n.d(e, "Matrix4", function() {
        return Be
    }), n.d(e, "Matrix3", function() {
        return He
    }), n.d(e, "Box3", function() {
        return Je
    }), n.d(e, "Box2", function() {
        return Ks
    }), n.d(e, "Line3", function() {
        return Zs
    }), n.d(e, "Euler", function() {
        return hn
    }), n.d(e, "Vector4", function() {
        return Xe
    }), n.d(e, "Vector3", function() {
        return Ge
    }), n.d(e, "Vector2", function() {
        return Ue
    }), n.d(e, "Quaternion", function() {
        return Ne
    }), n.d(e, "Color", function() {
        return on
    }), n.d(e, "ImmediateRenderObject", function() {
        return Js
    }), n.d(e, "VertexNormalsHelper", function() {
        return Qs
    }), n.d(e, "SpotLightHelper", function() {
        return $s
    }), n.d(e, "SkeletonHelper", function() {
        return tc
    }), n.d(e, "PointLightHelper", function() {
        return ec
    }), n.d(e, "RectAreaLightHelper", function() {
        return nc
    }), n.d(e, "HemisphereLightHelper", function() {
        return rc
    }), n.d(e, "GridHelper", function() {
        return ic
    }), n.d(e, "PolarGridHelper", function() {
        return oc
    }), n.d(e, "FaceNormalsHelper", function() {
        return ac
    }), n.d(e, "DirectionalLightHelper", function() {
        return sc
    }), n.d(e, "CameraHelper", function() {
        return cc
    }), n.d(e, "BoxHelper", function() {
        return uc
    }), n.d(e, "Box3Helper", function() {
        return lc
    }), n.d(e, "PlaneHelper", function() {
        return hc
    }), n.d(e, "ArrowHelper", function() {
        return fc
    }), n.d(e, "AxesHelper", function() {
        return dc
    }), n.d(e, "Shape", function() {
        return Da
    }), n.d(e, "Path", function() {
        return Ia
    }), n.d(e, "ShapePath", function() {
        return xs
    }), n.d(e, "Font", function() {
        return bs
    }), n.d(e, "CurvePath", function() {
        return Ra
    }), n.d(e, "Curve", function() {
        return fa
    }), n.d(e, "ImageUtils", function() {
        return Ve
    }), n.d(e, "ShapeUtils", function() {
        return xo
    }), n.d(e, "WebGLUtils", function() {
        return ri
    }), n.d(e, "WireframeGeometry", function() {
        return Ci
    }), n.d(e, "ParametricGeometry", function() {
        return Ri
    }), n.d(e, "ParametricBufferGeometry", function() {
        return Ii
    }), n.d(e, "TetrahedronGeometry", function() {
        return Fi
    }), n.d(e, "TetrahedronBufferGeometry", function() {
        return ji
    }), n.d(e, "OctahedronGeometry", function() {
        return ki
    }), n.d(e, "OctahedronBufferGeometry", function() {
        return Ui
    }), n.d(e, "IcosahedronGeometry", function() {
        return Bi
    }), n.d(e, "IcosahedronBufferGeometry", function() {
        return Ni
    }), n.d(e, "DodecahedronGeometry", function() {
        return Gi
    }), n.d(e, "DodecahedronBufferGeometry", function() {
        return Hi
    }), n.d(e, "PolyhedronGeometry", function() {
        return Di
    }), n.d(e, "PolyhedronBufferGeometry", function() {
        return Oi
    }), n.d(e, "TubeGeometry", function() {
        return Vi
    }), n.d(e, "TubeBufferGeometry", function() {
        return Wi
    }), n.d(e, "TorusKnotGeometry", function() {
        return Yi
    }), n.d(e, "TorusKnotBufferGeometry", function() {
        return Xi
    }), n.d(e, "TorusGeometry", function() {
        return qi
    }), n.d(e, "TorusBufferGeometry", function() {
        return Ki
    }), n.d(e, "TextGeometry", function() {
        return To
    }), n.d(e, "TextBufferGeometry", function() {
        return Po
    }), n.d(e, "SphereGeometry", function() {
        return Lo
    }), n.d(e, "SphereBufferGeometry", function() {
        return Ao
    }), n.d(e, "RingGeometry", function() {
        return zo
    }), n.d(e, "RingBufferGeometry", function() {
        return Co
    }), n.d(e, "PlaneGeometry", function() {
        return In
    }), n.d(e, "PlaneBufferGeometry", function() {
        return Dn
    }), n.d(e, "LatheGeometry", function() {
        return Ro
    }), n.d(e, "LatheBufferGeometry", function() {
        return Io
    }), n.d(e, "ShapeGeometry", function() {
        return Do
    }), n.d(e, "ShapeBufferGeometry", function() {
        return Oo
    }), n.d(e, "ExtrudeGeometry", function() {
        return _o
    }), n.d(e, "ExtrudeBufferGeometry", function() {
        return Mo
    }), n.d(e, "EdgesGeometry", function() {
        return jo
    }), n.d(e, "ConeGeometry", function() {
        return Bo
    }), n.d(e, "ConeBufferGeometry", function() {
        return No
    }), n.d(e, "CylinderGeometry", function() {
        return ko
    }), n.d(e, "CylinderBufferGeometry", function() {
        return Uo
    }), n.d(e, "CircleGeometry", function() {
        return Go
    }), n.d(e, "CircleBufferGeometry", function() {
        return Ho
    }), n.d(e, "BoxGeometry", function() {
        return Cn
    }), n.d(e, "BoxBufferGeometry", function() {
        return Rn
    }), n.d(e, "ShadowMaterial", function() {
        return Wo
    }), n.d(e, "SpriteMaterial", function() {
        return pi
    }), n.d(e, "RawShaderMaterial", function() {
        return Yo
    }), n.d(e, "ShaderMaterial", function() {
        return jn
    }), n.d(e, "PointsMaterial", function() {
        return Ei
    }), n.d(e, "MeshPhysicalMaterial", function() {
        return qo
    }), n.d(e, "MeshStandardMaterial", function() {
        return Xo
    }), n.d(e, "MeshPhongMaterial", function() {
        return Ko
    }), n.d(e, "MeshToonMaterial", function() {
        return Zo
    }), n.d(e, "MeshNormalMaterial", function() {
        return Jo
    }), n.d(e, "MeshLambertMaterial", function() {
        return Qo
    }), n.d(e, "MeshDepthMaterial", function() {
        return $r
    }), n.d(e, "MeshDistanceMaterial", function() {
        return ti
    }), n.d(e, "MeshBasicMaterial", function() {
        return Bn
    }), n.d(e, "MeshMatcapMaterial", function() {
        return $o
    }), n.d(e, "LineDashedMaterial", function() {
        return ta
    }), n.d(e, "LineBasicMaterial", function() {
        return wi
    }), n.d(e, "Material", function() {
        return Fn
    }), n.d(e, "Float64BufferAttribute", function() {
        return Tn
    }), n.d(e, "Float32BufferAttribute", function() {
        return En
    }), n.d(e, "Uint32BufferAttribute", function() {
        return Sn
    }), n.d(e, "Int32BufferAttribute", function() {
        return Mn
    }), n.d(e, "Uint16BufferAttribute", function() {
        return _n
    }), n.d(e, "Int16BufferAttribute", function() {
        return wn
    }), n.d(e, "Uint8ClampedBufferAttribute", function() {
        return bn
    }), n.d(e, "Uint8BufferAttribute", function() {
        return xn
    }), n.d(e, "Int8BufferAttribute", function() {
        return yn
    }), n.d(e, "BufferAttribute", function() {
        return gn
    }), n.d(e, "ArcCurve", function() {
        return va
    }), n.d(e, "CatmullRomCurve3", function() {
        return ba
    }), n.d(e, "CubicBezierCurve", function() {
        return Sa
    }), n.d(e, "CubicBezierCurve3", function() {
        return Ea
    }), n.d(e, "EllipseCurve", function() {
        return da
    }), n.d(e, "LineCurve", function() {
        return Ta
    }), n.d(e, "LineCurve3", function() {
        return Pa
    }), n.d(e, "QuadraticBezierCurve", function() {
        return La
    }), n.d(e, "QuadraticBezierCurve3", function() {
        return Aa
    }), n.d(e, "SplineCurve", function() {
        return za
    }), n.d(e, "REVISION", function() {
        return i
    }), n.d(e, "MOUSE", function() {
        return o
    }), n.d(e, "CullFaceNone", function() {
        return a
    }), n.d(e, "CullFaceBack", function() {
        return s
    }), n.d(e, "CullFaceFront", function() {
        return c
    }), n.d(e, "CullFaceFrontBack", function() {
        return u
    }), n.d(e, "FrontFaceDirectionCW", function() {
        return l
    }), n.d(e, "FrontFaceDirectionCCW", function() {
        return h
    }), n.d(e, "BasicShadowMap", function() {
        return f
    }), n.d(e, "PCFShadowMap", function() {
        return d
    }), n.d(e, "PCFSoftShadowMap", function() {
        return v
    }), n.d(e, "FrontSide", function() {
        return p
    }), n.d(e, "BackSide", function() {
        return m
    }), n.d(e, "DoubleSide", function() {
        return g
    }), n.d(e, "FlatShading", function() {
        return y
    }), n.d(e, "SmoothShading", function() {
        return x
    }), n.d(e, "NoColors", function() {
        return b
    }), n.d(e, "FaceColors", function() {
        return w
    }), n.d(e, "VertexColors", function() {
        return _
    }), n.d(e, "NoBlending", function() {
        return M
    }), n.d(e, "NormalBlending", function() {
        return S
    }), n.d(e, "AdditiveBlending", function() {
        return E
    }), n.d(e, "SubtractiveBlending", function() {
        return T
    }), n.d(e, "MultiplyBlending", function() {
        return P
    }), n.d(e, "CustomBlending", function() {
        return L
    }), n.d(e, "AddEquation", function() {
        return A
    }), n.d(e, "SubtractEquation", function() {
        return z
    }), n.d(e, "ReverseSubtractEquation", function() {
        return C
    }), n.d(e, "MinEquation", function() {
        return R
    }), n.d(e, "MaxEquation", function() {
        return I
    }), n.d(e, "ZeroFactor", function() {
        return D
    }), n.d(e, "OneFactor", function() {
        return O
    }), n.d(e, "SrcColorFactor", function() {
        return F
    }), n.d(e, "OneMinusSrcColorFactor", function() {
        return j
    }), n.d(e, "SrcAlphaFactor", function() {
        return k
    }), n.d(e, "OneMinusSrcAlphaFactor", function() {
        return U
    }), n.d(e, "DstAlphaFactor", function() {
        return B
    }), n.d(e, "OneMinusDstAlphaFactor", function() {
        return N
    }), n.d(e, "DstColorFactor", function() {
        return G
    }), n.d(e, "OneMinusDstColorFactor", function() {
        return H
    }), n.d(e, "SrcAlphaSaturateFactor", function() {
        return V
    }), n.d(e, "NeverDepth", function() {
        return W
    }), n.d(e, "AlwaysDepth", function() {
        return Y
    }), n.d(e, "LessDepth", function() {
        return X
    }), n.d(e, "LessEqualDepth", function() {
        return q
    }), n.d(e, "EqualDepth", function() {
        return K
    }), n.d(e, "GreaterEqualDepth", function() {
        return Z
    }), n.d(e, "GreaterDepth", function() {
        return J
    }), n.d(e, "NotEqualDepth", function() {
        return Q
    }), n.d(e, "MultiplyOperation", function() {
        return $
    }), n.d(e, "MixOperation", function() {
        return tt
    }), n.d(e, "AddOperation", function() {
        return et
    }), n.d(e, "NoToneMapping", function() {
        return nt
    }), n.d(e, "LinearToneMapping", function() {
        return rt
    }), n.d(e, "ReinhardToneMapping", function() {
        return it
    }), n.d(e, "Uncharted2ToneMapping", function() {
        return ot
    }), n.d(e, "CineonToneMapping", function() {
        return at
    }), n.d(e, "UVMapping", function() {
        return st
    }), n.d(e, "CubeReflectionMapping", function() {
        return ct
    }), n.d(e, "CubeRefractionMapping", function() {
        return ut
    }), n.d(e, "EquirectangularReflectionMapping", function() {
        return lt
    }), n.d(e, "EquirectangularRefractionMapping", function() {
        return ht
    }), n.d(e, "SphericalReflectionMapping", function() {
        return ft
    }), n.d(e, "CubeUVReflectionMapping", function() {
        return dt
    }), n.d(e, "CubeUVRefractionMapping", function() {
        return vt
    }), n.d(e, "RepeatWrapping", function() {
        return pt
    }), n.d(e, "ClampToEdgeWrapping", function() {
        return mt
    }), n.d(e, "MirroredRepeatWrapping", function() {
        return gt
    }), n.d(e, "NearestFilter", function() {
        return yt
    }), n.d(e, "NearestMipMapNearestFilter", function() {
        return xt
    }), n.d(e, "NearestMipMapLinearFilter", function() {
        return bt
    }), n.d(e, "LinearFilter", function() {
        return wt
    }), n.d(e, "LinearMipMapNearestFilter", function() {
        return _t
    }), n.d(e, "LinearMipMapLinearFilter", function() {
        return Mt
    }), n.d(e, "UnsignedByteType", function() {
        return St
    }), n.d(e, "ByteType", function() {
        return Et
    }), n.d(e, "ShortType", function() {
        return Tt
    }), n.d(e, "UnsignedShortType", function() {
        return Pt
    }), n.d(e, "IntType", function() {
        return Lt
    }), n.d(e, "UnsignedIntType", function() {
        return At
    }), n.d(e, "FloatType", function() {
        return zt
    }), n.d(e, "HalfFloatType", function() {
        return Ct
    }), n.d(e, "UnsignedShort4444Type", function() {
        return Rt
    }), n.d(e, "UnsignedShort5551Type", function() {
        return It
    }), n.d(e, "UnsignedShort565Type", function() {
        return Dt
    }), n.d(e, "UnsignedInt248Type", function() {
        return Ot
    }), n.d(e, "AlphaFormat", function() {
        return Ft
    }), n.d(e, "RGBFormat", function() {
        return jt
    }), n.d(e, "RGBAFormat", function() {
        return kt
    }), n.d(e, "LuminanceFormat", function() {
        return Ut
    }), n.d(e, "LuminanceAlphaFormat", function() {
        return Bt
    }), n.d(e, "RGBEFormat", function() {
        return Nt
    }), n.d(e, "DepthFormat", function() {
        return Gt
    }), n.d(e, "DepthStencilFormat", function() {
        return Ht
    }), n.d(e, "RedFormat", function() {
        return Vt
    }), n.d(e, "RGB_S3TC_DXT1_Format", function() {
        return Wt
    }), n.d(e, "RGBA_S3TC_DXT1_Format", function() {
        return Yt
    }), n.d(e, "RGBA_S3TC_DXT3_Format", function() {
        return Xt
    }), n.d(e, "RGBA_S3TC_DXT5_Format", function() {
        return qt
    }), n.d(e, "RGB_PVRTC_4BPPV1_Format", function() {
        return Kt
    }), n.d(e, "RGB_PVRTC_2BPPV1_Format", function() {
        return Zt
    }), n.d(e, "RGBA_PVRTC_4BPPV1_Format", function() {
        return Jt
    }), n.d(e, "RGBA_PVRTC_2BPPV1_Format", function() {
        return Qt
    }), n.d(e, "RGB_ETC1_Format", function() {
        return $t
    }), n.d(e, "RGBA_ASTC_4x4_Format", function() {
        return te
    }), n.d(e, "RGBA_ASTC_5x4_Format", function() {
        return ee
    }), n.d(e, "RGBA_ASTC_5x5_Format", function() {
        return ne
    }), n.d(e, "RGBA_ASTC_6x5_Format", function() {
        return re
    }), n.d(e, "RGBA_ASTC_6x6_Format", function() {
        return ie
    }), n.d(e, "RGBA_ASTC_8x5_Format", function() {
        return oe
    }), n.d(e, "RGBA_ASTC_8x6_Format", function() {
        return ae
    }), n.d(e, "RGBA_ASTC_8x8_Format", function() {
        return se
    }), n.d(e, "RGBA_ASTC_10x5_Format", function() {
        return ce
    }), n.d(e, "RGBA_ASTC_10x6_Format", function() {
        return ue
    }), n.d(e, "RGBA_ASTC_10x8_Format", function() {
        return le
    }), n.d(e, "RGBA_ASTC_10x10_Format", function() {
        return he
    }), n.d(e, "RGBA_ASTC_12x10_Format", function() {
        return fe
    }), n.d(e, "RGBA_ASTC_12x12_Format", function() {
        return de
    }), n.d(e, "LoopOnce", function() {
        return ve
    }), n.d(e, "LoopRepeat", function() {
        return pe
    }), n.d(e, "LoopPingPong", function() {
        return me
    }), n.d(e, "InterpolateDiscrete", function() {
        return ge
    }), n.d(e, "InterpolateLinear", function() {
        return ye
    }), n.d(e, "InterpolateSmooth", function() {
        return xe
    }), n.d(e, "ZeroCurvatureEnding", function() {
        return be
    }), n.d(e, "ZeroSlopeEnding", function() {
        return we
    }), n.d(e, "WrapAroundEnding", function() {
        return _e
    }), n.d(e, "TrianglesDrawMode", function() {
        return Me
    }), n.d(e, "TriangleStripDrawMode", function() {
        return Se
    }), n.d(e, "TriangleFanDrawMode", function() {
        return Ee
    }), n.d(e, "LinearEncoding", function() {
        return Te
    }), n.d(e, "sRGBEncoding", function() {
        return Pe
    }), n.d(e, "GammaEncoding", function() {
        return Le
    }), n.d(e, "RGBEEncoding", function() {
        return Ae
    }), n.d(e, "LogLuvEncoding", function() {
        return ze
    }), n.d(e, "RGBM7Encoding", function() {
        return Ce
    }), n.d(e, "RGBM16Encoding", function() {
        return Re
    }), n.d(e, "RGBDEncoding", function() {
        return Ie
    }), n.d(e, "BasicDepthPacking", function() {
        return De
    }), n.d(e, "RGBADepthPacking", function() {
        return Oe
    }), n.d(e, "TangentSpaceNormalMap", function() {
        return Fe
    }), n.d(e, "ObjectSpaceNormalMap", function() {
        return je
    }), n.d(e, "CubeGeometry", function() {
        return Cn
    }), n.d(e, "Face4", function() {
        return vc
    }), n.d(e, "LineStrip", function() {
        return pc
    }), n.d(e, "LinePieces", function() {
        return mc
    }), n.d(e, "MeshFaceMaterial", function() {
        return gc
    }), n.d(e, "MultiMaterial", function() {
        return yc
    }), n.d(e, "PointCloud", function() {
        return xc
    }), n.d(e, "Particle", function() {
        return bc
    }), n.d(e, "ParticleSystem", function() {
        return wc
    }), n.d(e, "PointCloudMaterial", function() {
        return _c
    }), n.d(e, "ParticleBasicMaterial", function() {
        return Mc
    }), n.d(e, "ParticleSystemMaterial", function() {
        return Sc
    }), n.d(e, "Vertex", function() {
        return Ec
    }), n.d(e, "DynamicBufferAttribute", function() {
        return Tc
    }), n.d(e, "Int8Attribute", function() {
        return Pc
    }), n.d(e, "Uint8Attribute", function() {
        return Lc
    }), n.d(e, "Uint8ClampedAttribute", function() {
        return Ac
    }), n.d(e, "Int16Attribute", function() {
        return zc
    }), n.d(e, "Uint16Attribute", function() {
        return Cc
    }), n.d(e, "Int32Attribute", function() {
        return Rc
    }), n.d(e, "Uint32Attribute", function() {
        return Ic
    }), n.d(e, "Float32Attribute", function() {
        return Dc
    }), n.d(e, "Float64Attribute", function() {
        return Oc
    }), n.d(e, "ClosedSplineCurve3", function() {
        return Fc
    }), n.d(e, "SplineCurve3", function() {
        return jc
    }), n.d(e, "Spline", function() {
        return kc
    }), n.d(e, "AxisHelper", function() {
        return Uc
    }), n.d(e, "BoundingBoxHelper", function() {
        return Bc
    }), n.d(e, "EdgesHelper", function() {
        return Nc
    }), n.d(e, "WireframeHelper", function() {
        return Gc
    }), n.d(e, "XHRLoader", function() {
        return Hc
    }), n.d(e, "BinaryTextureLoader", function() {
        return Vc
    }), n.d(e, "GeometryUtils", function() {
        return Wc
    }), n.d(e, "Projector", function() {
        return Yc
    }), n.d(e, "CanvasRenderer", function() {
        return Xc
    }), n.d(e, "SceneUtils", function() {
        return qc
    }), n.d(e, "LensFlare", function() {
        return Kc
    }), void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(t) {
        return "number" == typeof t && isFinite(t) && Math.floor(t) === t
    }), void 0 === Math.sign && (Math.sign = function(t) {
        return t < 0 ? -1 : t > 0 ? 1 : +t
    }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }), void 0 === Object.assign && (Object.assign = function(t) {
        if (void 0 === t || null === t) throw new TypeError("Cannot convert undefined or null to object");
        for (var e = Object(t), n = 1; n < arguments.length; n++) {
            var r = arguments[n];
            if (void 0 !== r && null !== r)
                for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i])
        }
        return e
    }), Object.assign(r.prototype, {
        addEventListener: function(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            var n = this._listeners;
            void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
        },
        hasEventListener: function(t, e) {
            if (void 0 === this._listeners) return !1;
            var n = this._listeners;
            return void 0 !== n[t] && -1 !== n[t].indexOf(e)
        },
        removeEventListener: function(t, e) {
            if (void 0 !== this._listeners) {
                var n = this._listeners[t];
                if (void 0 !== n) {
                    var r = n.indexOf(e); - 1 !== r && n.splice(r, 1)
                }
            }
        },
        dispatchEvent: function(t) {
            if (void 0 !== this._listeners) {
                var e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this;
                    for (var n = e.slice(0), r = 0, i = n.length; r < i; r++) n[r].call(this, t)
                }
            }
        }
    });
    var i = "97",
        o = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2
        },
        a = 0,
        s = 1,
        c = 2,
        u = 3,
        l = 0,
        h = 1,
        f = 0,
        d = 1,
        v = 2,
        p = 0,
        m = 1,
        g = 2,
        y = 1,
        x = 2,
        b = 0,
        w = 1,
        _ = 2,
        M = 0,
        S = 1,
        E = 2,
        T = 3,
        P = 4,
        L = 5,
        A = 100,
        z = 101,
        C = 102,
        R = 103,
        I = 104,
        D = 200,
        O = 201,
        F = 202,
        j = 203,
        k = 204,
        U = 205,
        B = 206,
        N = 207,
        G = 208,
        H = 209,
        V = 210,
        W = 0,
        Y = 1,
        X = 2,
        q = 3,
        K = 4,
        Z = 5,
        J = 6,
        Q = 7,
        $ = 0,
        tt = 1,
        et = 2,
        nt = 0,
        rt = 1,
        it = 2,
        ot = 3,
        at = 4,
        st = 300,
        ct = 301,
        ut = 302,
        lt = 303,
        ht = 304,
        ft = 305,
        dt = 306,
        vt = 307,
        pt = 1e3,
        mt = 1001,
        gt = 1002,
        yt = 1003,
        xt = 1004,
        bt = 1005,
        wt = 1006,
        _t = 1007,
        Mt = 1008,
        St = 1009,
        Et = 1010,
        Tt = 1011,
        Pt = 1012,
        Lt = 1013,
        At = 1014,
        zt = 1015,
        Ct = 1016,
        Rt = 1017,
        It = 1018,
        Dt = 1019,
        Ot = 1020,
        Ft = 1021,
        jt = 1022,
        kt = 1023,
        Ut = 1024,
        Bt = 1025,
        Nt = kt,
        Gt = 1026,
        Ht = 1027,
        Vt = 1028,
        Wt = 33776,
        Yt = 33777,
        Xt = 33778,
        qt = 33779,
        Kt = 35840,
        Zt = 35841,
        Jt = 35842,
        Qt = 35843,
        $t = 36196,
        te = 37808,
        ee = 37809,
        ne = 37810,
        re = 37811,
        ie = 37812,
        oe = 37813,
        ae = 37814,
        se = 37815,
        ce = 37816,
        ue = 37817,
        le = 37818,
        he = 37819,
        fe = 37820,
        de = 37821,
        ve = 2200,
        pe = 2201,
        me = 2202,
        ge = 2300,
        ye = 2301,
        xe = 2302,
        be = 2400,
        we = 2401,
        _e = 2402,
        Me = 0,
        Se = 1,
        Ee = 2,
        Te = 3e3,
        Pe = 3001,
        Le = 3007,
        Ae = 3002,
        ze = 3003,
        Ce = 3004,
        Re = 3005,
        Ie = 3006,
        De = 3200,
        Oe = 3201,
        Fe = 0,
        je = 1,
        ke = {
            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,
            generateUUID: function() {
                for (var t = [], e = 0; e < 256; e++) t[e] = (e < 16 ? "0" : "") + e.toString(16);
                return function() {
                    var e = 4294967295 * Math.random() | 0,
                        n = 4294967295 * Math.random() | 0,
                        r = 4294967295 * Math.random() | 0,
                        i = 4294967295 * Math.random() | 0;
                    return (t[255 & e] + t[e >> 8 & 255] + t[e >> 16 & 255] + t[e >> 24 & 255] + "-" + t[255 & n] + t[n >> 8 & 255] + "-" + t[n >> 16 & 15 | 64] + t[n >> 24 & 255] + "-" + t[63 & r | 128] + t[r >> 8 & 255] + "-" + t[r >> 16 & 255] + t[r >> 24 & 255] + t[255 & i] + t[i >> 8 & 255] + t[i >> 16 & 255] + t[i >> 24 & 255]).toUpperCase()
                }
            }(),
            clamp: function(t, e, n) {
                return Math.max(e, Math.min(n, t))
            },
            euclideanModulo: function(t, e) {
                return (t % e + e) % e
            },
            mapLinear: function(t, e, n, r, i) {
                return r + (t - e) * (i - r) / (n - e)
            },
            lerp: function(t, e, n) {
                return (1 - n) * t + n * e
            },
            smoothstep: function(t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
            },
            smootherstep: function(t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
            },
            randInt: function(t, e) {
                return t + Math.floor(Math.random() * (e - t + 1))
            },
            randFloat: function(t, e) {
                return t + Math.random() * (e - t)
            },
            randFloatSpread: function(t) {
                return t * (.5 - Math.random())
            },
            degToRad: function(t) {
                return t * ke.DEG2RAD
            },
            radToDeg: function(t) {
                return t * ke.RAD2DEG
            },
            isPowerOfTwo: function(t) {
                return 0 == (t & t - 1) && 0 !== t
            },
            ceilPowerOfTwo: function(t) {
                return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
            },
            floorPowerOfTwo: function(t) {
                return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
            }
        };

    function Ue(t, e) {
        this.x = t || 0, this.y = e || 0
    }

    function Be() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }

    function Ne(t, e, n, r) {
        this._x = t || 0, this._y = e || 0, this._z = n || 0, this._w = void 0 !== r ? r : 1
    }

    function Ge(t, e, n) {
        this.x = t || 0, this.y = e || 0, this.z = n || 0
    }

    function He() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }
    Object.defineProperties(Ue.prototype, {
        width: {
            get: function() {
                return this.x
            },
            set: function(t) {
                this.x = t
            }
        },
        height: {
            get: function() {
                return this.y
            },
            set: function(t) {
                this.y = t
            }
        }
    }), Object.assign(Ue.prototype, {
        isVector2: !0,
        set: function(t, e) {
            return this.x = t, this.y = e, this
        },
        setScalar: function(t) {
            return this.x = t, this.y = t, this
        },
        setX: function(t) {
            return this.x = t, this
        },
        setY: function(t) {
            return this.y = t, this
        },
        setComponent: function(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y)
        },
        copy: function(t) {
            return this.x = t.x, this.y = t.y, this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
        },
        addScalar: function(t) {
            return this.x += t, this.y += t, this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
        },
        subScalar: function(t) {
            return this.x -= t, this.y -= t, this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this
        },
        multiply: function(t) {
            return this.x *= t.x, this.y *= t.y, this
        },
        multiplyScalar: function(t) {
            return this.x *= t, this.y *= t, this
        },
        divide: function(t) {
            return this.x /= t.x, this.y /= t.y, this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        applyMatrix3: function(t) {
            var e = this.x,
                n = this.y,
                r = t.elements;
            return this.x = r[0] * e + r[3] * n + r[6], this.y = r[1] * e + r[4] * n + r[7], this
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
        },
        clampScalar: function() {
            var t = new Ue,
                e = new Ue;
            return function(n, r) {
                return t.set(n, n), e.set(r, r), this.clamp(t, e)
            }
        }(),
        clampLength: function(t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y
        },
        cross: function(t) {
            return this.x * t.y - this.y * t.x
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        angle: function() {
            var t = Math.atan2(this.y, this.x);
            return t < 0 && (t += 2 * Math.PI), t
        },
        distanceTo: function(t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function(t) {
            var e = this.x - t.x,
                n = this.y - t.y;
            return e * e + n * n
        },
        manhattanDistanceTo: function(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
        },
        lerpVectors: function(t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
        },
        fromBufferAttribute: function(t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
        },
        rotateAround: function(t, e) {
            var n = Math.cos(e),
                r = Math.sin(e),
                i = this.x - t.x,
                o = this.y - t.y;
            return this.x = i * n - o * r + t.x, this.y = i * r + o * n + t.y, this
        }
    }), Object.assign(Be.prototype, {
        isMatrix4: !0,
        set: function(t, e, n, r, i, o, a, s, c, u, l, h, f, d, v, p) {
            var m = this.elements;
            return m[0] = t, m[4] = e, m[8] = n, m[12] = r, m[1] = i, m[5] = o, m[9] = a, m[13] = s, m[2] = c, m[6] = u, m[10] = l, m[14] = h, m[3] = f, m[7] = d, m[11] = v, m[15] = p, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        clone: function() {
            return (new Be).fromArray(this.elements)
        },
        copy: function(t) {
            var e = this.elements,
                n = t.elements;
            return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
        },
        copyPosition: function(t) {
            var e = this.elements,
                n = t.elements;
            return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
        },
        extractBasis: function(t, e, n) {
            return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
        },
        makeBasis: function(t, e, n) {
            return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
        },
        extractRotation: function() {
            var t = new Ge;
            return function(e) {
                var n = this.elements,
                    r = e.elements,
                    i = 1 / t.setFromMatrixColumn(e, 0).length(),
                    o = 1 / t.setFromMatrixColumn(e, 1).length(),
                    a = 1 / t.setFromMatrixColumn(e, 2).length();
                return n[0] = r[0] * i, n[1] = r[1] * i, n[2] = r[2] * i, n[3] = 0, n[4] = r[4] * o, n[5] = r[5] * o, n[6] = r[6] * o, n[7] = 0, n[8] = r[8] * a, n[9] = r[9] * a, n[10] = r[10] * a, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this
            }
        }(),
        makeRotationFromEuler: function(t) {
            t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var e = this.elements,
                n = t.x,
                r = t.y,
                i = t.z,
                o = Math.cos(n),
                a = Math.sin(n),
                s = Math.cos(r),
                c = Math.sin(r),
                u = Math.cos(i),
                l = Math.sin(i);
            if ("XYZ" === t.order) {
                var h = o * u,
                    f = o * l,
                    d = a * u,
                    v = a * l;
                e[0] = s * u, e[4] = -s * l, e[8] = c, e[1] = f + d * c, e[5] = h - v * c, e[9] = -a * s, e[2] = v - h * c, e[6] = d + f * c, e[10] = o * s
            } else if ("YXZ" === t.order) {
                var p = s * u,
                    m = s * l,
                    g = c * u,
                    y = c * l;
                e[0] = p + y * a, e[4] = g * a - m, e[8] = o * c, e[1] = o * l, e[5] = o * u, e[9] = -a, e[2] = m * a - g, e[6] = y + p * a, e[10] = o * s
            } else if ("ZXY" === t.order) {
                p = s * u, m = s * l, g = c * u, y = c * l;
                e[0] = p - y * a, e[4] = -o * l, e[8] = g + m * a, e[1] = m + g * a, e[5] = o * u, e[9] = y - p * a, e[2] = -o * c, e[6] = a, e[10] = o * s
            } else if ("ZYX" === t.order) {
                h = o * u, f = o * l, d = a * u, v = a * l;
                e[0] = s * u, e[4] = d * c - f, e[8] = h * c + v, e[1] = s * l, e[5] = v * c + h, e[9] = f * c - d, e[2] = -c, e[6] = a * s, e[10] = o * s
            } else if ("YZX" === t.order) {
                var x = o * s,
                    b = o * c,
                    w = a * s,
                    _ = a * c;
                e[0] = s * u, e[4] = _ - x * l, e[8] = w * l + b, e[1] = l, e[5] = o * u, e[9] = -a * u, e[2] = -c * u, e[6] = b * l + w, e[10] = x - _ * l
            } else if ("XZY" === t.order) {
                x = o * s, b = o * c, w = a * s, _ = a * c;
                e[0] = s * u, e[4] = -l, e[8] = c * u, e[1] = x * l + _, e[5] = o * u, e[9] = b * l - w, e[2] = w * l - b, e[6] = a * u, e[10] = _ * l + x
            }
            return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
        },
        makeRotationFromQuaternion: function() {
            var t = new Ge(0, 0, 0),
                e = new Ge(1, 1, 1);
            return function(n) {
                return this.compose(t, n, e)
            }
        }(),
        lookAt: function() {
            var t = new Ge,
                e = new Ge,
                n = new Ge;
            return function(r, i, o) {
                var a = this.elements;
                return n.subVectors(r, i), 0 === n.lengthSq() && (n.z = 1), n.normalize(), t.crossVectors(o, n), 0 === t.lengthSq() && (1 === Math.abs(o.z) ? n.x += 1e-4 : n.z += 1e-4, n.normalize(), t.crossVectors(o, n)), t.normalize(), e.crossVectors(n, t), a[0] = t.x, a[4] = e.x, a[8] = n.x, a[1] = t.y, a[5] = e.y, a[9] = n.y, a[2] = t.z, a[6] = e.z, a[10] = n.z, this
            }
        }(),
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
        },
        premultiply: function(t) {
            return this.multiplyMatrices(t, this)
        },
        multiplyMatrices: function(t, e) {
            var n = t.elements,
                r = e.elements,
                i = this.elements,
                o = n[0],
                a = n[4],
                s = n[8],
                c = n[12],
                u = n[1],
                l = n[5],
                h = n[9],
                f = n[13],
                d = n[2],
                v = n[6],
                p = n[10],
                m = n[14],
                g = n[3],
                y = n[7],
                x = n[11],
                b = n[15],
                w = r[0],
                _ = r[4],
                M = r[8],
                S = r[12],
                E = r[1],
                T = r[5],
                P = r[9],
                L = r[13],
                A = r[2],
                z = r[6],
                C = r[10],
                R = r[14],
                I = r[3],
                D = r[7],
                O = r[11],
                F = r[15];
            return i[0] = o * w + a * E + s * A + c * I, i[4] = o * _ + a * T + s * z + c * D, i[8] = o * M + a * P + s * C + c * O, i[12] = o * S + a * L + s * R + c * F, i[1] = u * w + l * E + h * A + f * I, i[5] = u * _ + l * T + h * z + f * D, i[9] = u * M + l * P + h * C + f * O, i[13] = u * S + l * L + h * R + f * F, i[2] = d * w + v * E + p * A + m * I, i[6] = d * _ + v * T + p * z + m * D, i[10] = d * M + v * P + p * C + m * O, i[14] = d * S + v * L + p * R + m * F, i[3] = g * w + y * E + x * A + b * I, i[7] = g * _ + y * T + x * z + b * D, i[11] = g * M + y * P + x * C + b * O, i[15] = g * S + y * L + x * R + b * F, this
        },
        multiplyScalar: function(t) {
            var e = this.elements;
            return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
        },
        applyToBufferAttribute: function() {
            var t = new Ge;
            return function(e) {
                for (var n = 0, r = e.count; n < r; n++) t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.applyMatrix4(this), e.setXYZ(n, t.x, t.y, t.z);
                return e
            }
        }(),
        determinant: function() {
            var t = this.elements,
                e = t[0],
                n = t[4],
                r = t[8],
                i = t[12],
                o = t[1],
                a = t[5],
                s = t[9],
                c = t[13],
                u = t[2],
                l = t[6],
                h = t[10],
                f = t[14];
            return t[3] * (+i * s * l - r * c * l - i * a * h + n * c * h + r * a * f - n * s * f) + t[7] * (+e * s * f - e * c * h + i * o * h - r * o * f + r * c * u - i * s * u) + t[11] * (+e * c * l - e * a * f - i * o * l + n * o * f + i * a * u - n * c * u) + t[15] * (-r * a * u - e * s * l + e * a * h + r * o * l - n * o * h + n * s * u)
        },
        transpose: function() {
            var t, e = this.elements;
            return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
        },
        setPosition: function(t) {
            var e = this.elements;
            return e[12] = t.x, e[13] = t.y, e[14] = t.z, this
        },
        getInverse: function(t, e) {
            var n = this.elements,
                r = t.elements,
                i = r[0],
                o = r[1],
                a = r[2],
                s = r[3],
                c = r[4],
                u = r[5],
                l = r[6],
                h = r[7],
                f = r[8],
                d = r[9],
                v = r[10],
                p = r[11],
                m = r[12],
                g = r[13],
                y = r[14],
                x = r[15],
                b = d * y * h - g * v * h + g * l * p - u * y * p - d * l * x + u * v * x,
                w = m * v * h - f * y * h - m * l * p + c * y * p + f * l * x - c * v * x,
                _ = f * g * h - m * d * h + m * u * p - c * g * p - f * u * x + c * d * x,
                M = m * d * l - f * g * l - m * u * v + c * g * v + f * u * y - c * d * y,
                S = i * b + o * w + a * _ + s * M;
            if (0 === S) {
                var E = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                if (!0 === e) throw new Error(E);
                return console.warn(E), this.identity()
            }
            var T = 1 / S;
            return n[0] = b * T, n[1] = (g * v * s - d * y * s - g * a * p + o * y * p + d * a * x - o * v * x) * T, n[2] = (u * y * s - g * l * s + g * a * h - o * y * h - u * a * x + o * l * x) * T, n[3] = (d * l * s - u * v * s - d * a * h + o * v * h + u * a * p - o * l * p) * T, n[4] = w * T, n[5] = (f * y * s - m * v * s + m * a * p - i * y * p - f * a * x + i * v * x) * T, n[6] = (m * l * s - c * y * s - m * a * h + i * y * h + c * a * x - i * l * x) * T, n[7] = (c * v * s - f * l * s + f * a * h - i * v * h - c * a * p + i * l * p) * T, n[8] = _ * T, n[9] = (m * d * s - f * g * s - m * o * p + i * g * p + f * o * x - i * d * x) * T, n[10] = (c * g * s - m * u * s + m * o * h - i * g * h - c * o * x + i * u * x) * T, n[11] = (f * u * s - c * d * s - f * o * h + i * d * h + c * o * p - i * u * p) * T, n[12] = M * T, n[13] = (f * g * a - m * d * a + m * o * v - i * g * v - f * o * y + i * d * y) * T, n[14] = (m * u * a - c * g * a - m * o * l + i * g * l + c * o * y - i * u * y) * T, n[15] = (c * d * a - f * u * a + f * o * l - i * d * l - c * o * v + i * u * v) * T, this
        },
        scale: function(t) {
            var e = this.elements,
                n = t.x,
                r = t.y,
                i = t.z;
            return e[0] *= n, e[4] *= r, e[8] *= i, e[1] *= n, e[5] *= r, e[9] *= i, e[2] *= n, e[6] *= r, e[10] *= i, e[3] *= n, e[7] *= r, e[11] *= i, this
        },
        getMaxScaleOnAxis: function() {
            var t = this.elements,
                e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, n, r))
        },
        makeTranslation: function(t, e, n) {
            return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
        },
        makeRotationX: function(t) {
            var e = Math.cos(t),
                n = Math.sin(t);
            return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
        },
        makeRotationY: function(t) {
            var e = Math.cos(t),
                n = Math.sin(t);
            return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
        },
        makeRotationZ: function(t) {
            var e = Math.cos(t),
                n = Math.sin(t);
            return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        makeRotationAxis: function(t, e) {
            var n = Math.cos(e),
                r = Math.sin(e),
                i = 1 - n,
                o = t.x,
                a = t.y,
                s = t.z,
                c = i * o,
                u = i * a;
            return this.set(c * o + n, c * a - r * s, c * s + r * a, 0, c * a + r * s, u * a + n, u * s - r * o, 0, c * s - r * a, u * s + r * o, i * s * s + n, 0, 0, 0, 0, 1), this
        },
        makeScale: function(t, e, n) {
            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
        },
        makeShear: function(t, e, n) {
            return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this
        },
        compose: function(t, e, n) {
            var r = this.elements,
                i = e._x,
                o = e._y,
                a = e._z,
                s = e._w,
                c = i + i,
                u = o + o,
                l = a + a,
                h = i * c,
                f = i * u,
                d = i * l,
                v = o * u,
                p = o * l,
                m = a * l,
                g = s * c,
                y = s * u,
                x = s * l,
                b = n.x,
                w = n.y,
                _ = n.z;
            return r[0] = (1 - (v + m)) * b, r[1] = (f + x) * b, r[2] = (d - y) * b, r[3] = 0, r[4] = (f - x) * w, r[5] = (1 - (h + m)) * w, r[6] = (p + g) * w, r[7] = 0, r[8] = (d + y) * _, r[9] = (p - g) * _, r[10] = (1 - (h + v)) * _, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1, this
        },
        decompose: function() {
            var t = new Ge,
                e = new Be;
            return function(n, r, i) {
                var o = this.elements,
                    a = t.set(o[0], o[1], o[2]).length(),
                    s = t.set(o[4], o[5], o[6]).length(),
                    c = t.set(o[8], o[9], o[10]).length();
                this.determinant() < 0 && (a = -a), n.x = o[12], n.y = o[13], n.z = o[14], e.copy(this);
                var u = 1 / a,
                    l = 1 / s,
                    h = 1 / c;
                return e.elements[0] *= u, e.elements[1] *= u, e.elements[2] *= u, e.elements[4] *= l, e.elements[5] *= l, e.elements[6] *= l, e.elements[8] *= h, e.elements[9] *= h, e.elements[10] *= h, r.setFromRotationMatrix(e), i.x = a, i.y = s, i.z = c, this
            }
        }(),
        makePerspective: function(t, e, n, r, i, o) {
            void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var a = this.elements,
                s = 2 * i / (e - t),
                c = 2 * i / (n - r),
                u = (e + t) / (e - t),
                l = (n + r) / (n - r),
                h = -(o + i) / (o - i),
                f = -2 * o * i / (o - i);
            return a[0] = s, a[4] = 0, a[8] = u, a[12] = 0, a[1] = 0, a[5] = c, a[9] = l, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = h, a[14] = f, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
        },
        makeOrthographic: function(t, e, n, r, i, o) {
            var a = this.elements,
                s = 1 / (e - t),
                c = 1 / (n - r),
                u = 1 / (o - i),
                l = (e + t) * s,
                h = (n + r) * c,
                f = (o + i) * u;
            return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -l, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -h, a[2] = 0, a[6] = 0, a[10] = -2 * u, a[14] = -f, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
        },
        equals: function(t) {
            for (var e = this.elements, n = t.elements, r = 0; r < 16; r++)
                if (e[r] !== n[r]) return !1;
            return !0
        },
        fromArray: function(t, e) {
            void 0 === e && (e = 0);
            for (var n = 0; n < 16; n++) this.elements[n] = t[n + e];
            return this
        },
        toArray: function(t, e) {
            void 0 === t && (t = []), void 0 === e && (e = 0);
            var n = this.elements;
            return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
        }
    }), Object.assign(Ne, {
        slerp: function(t, e, n, r) {
            return n.copy(t).slerp(e, r)
        },
        slerpFlat: function(t, e, n, r, i, o, a) {
            var s = n[r + 0],
                c = n[r + 1],
                u = n[r + 2],
                l = n[r + 3],
                h = i[o + 0],
                f = i[o + 1],
                d = i[o + 2],
                v = i[o + 3];
            if (l !== v || s !== h || c !== f || u !== d) {
                var p = 1 - a,
                    m = s * h + c * f + u * d + l * v,
                    g = m >= 0 ? 1 : -1,
                    y = 1 - m * m;
                if (y > Number.EPSILON) {
                    var x = Math.sqrt(y),
                        b = Math.atan2(x, m * g);
                    p = Math.sin(p * b) / x, a = Math.sin(a * b) / x
                }
                var w = a * g;
                if (s = s * p + h * w, c = c * p + f * w, u = u * p + d * w, l = l * p + v * w, p === 1 - a) {
                    var _ = 1 / Math.sqrt(s * s + c * c + u * u + l * l);
                    s *= _, c *= _, u *= _, l *= _
                }
            }
            t[e] = s, t[e + 1] = c, t[e + 2] = u, t[e + 3] = l
        }
    }), Object.defineProperties(Ne.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(t) {
                this._x = t, this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(t) {
                this._y = t, this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(t) {
                this._z = t, this.onChangeCallback()
            }
        },
        w: {
            get: function() {
                return this._w
            },
            set: function(t) {
                this._w = t, this.onChangeCallback()
            }
        }
    }), Object.assign(Ne.prototype, {
        isQuaternion: !0,
        set: function(t, e, n, r) {
            return this._x = t, this._y = e, this._z = n, this._w = r, this.onChangeCallback(), this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._w)
        },
        copy: function(t) {
            return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this
        },
        setFromEuler: function(t, e) {
            if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var n = t._x,
                r = t._y,
                i = t._z,
                o = t.order,
                a = Math.cos,
                s = Math.sin,
                c = a(n / 2),
                u = a(r / 2),
                l = a(i / 2),
                h = s(n / 2),
                f = s(r / 2),
                d = s(i / 2);
            return "XYZ" === o ? (this._x = h * u * l + c * f * d, this._y = c * f * l - h * u * d, this._z = c * u * d + h * f * l, this._w = c * u * l - h * f * d) : "YXZ" === o ? (this._x = h * u * l + c * f * d, this._y = c * f * l - h * u * d, this._z = c * u * d - h * f * l, this._w = c * u * l + h * f * d) : "ZXY" === o ? (this._x = h * u * l - c * f * d, this._y = c * f * l + h * u * d, this._z = c * u * d + h * f * l, this._w = c * u * l - h * f * d) : "ZYX" === o ? (this._x = h * u * l - c * f * d, this._y = c * f * l + h * u * d, this._z = c * u * d - h * f * l, this._w = c * u * l + h * f * d) : "YZX" === o ? (this._x = h * u * l + c * f * d, this._y = c * f * l + h * u * d, this._z = c * u * d - h * f * l, this._w = c * u * l - h * f * d) : "XZY" === o && (this._x = h * u * l - c * f * d, this._y = c * f * l - h * u * d, this._z = c * u * d + h * f * l, this._w = c * u * l + h * f * d), !1 !== e && this.onChangeCallback(), this
        },
        setFromAxisAngle: function(t, e) {
            var n = e / 2,
                r = Math.sin(n);
            return this._x = t.x * r, this._y = t.y * r, this._z = t.z * r, this._w = Math.cos(n), this.onChangeCallback(), this
        },
        setFromRotationMatrix: function(t) {
            var e, n = t.elements,
                r = n[0],
                i = n[4],
                o = n[8],
                a = n[1],
                s = n[5],
                c = n[9],
                u = n[2],
                l = n[6],
                h = n[10],
                f = r + s + h;
            return f > 0 ? (e = .5 / Math.sqrt(f + 1), this._w = .25 / e, this._x = (l - c) * e, this._y = (o - u) * e, this._z = (a - i) * e) : r > s && r > h ? (e = 2 * Math.sqrt(1 + r - s - h), this._w = (l - c) / e, this._x = .25 * e, this._y = (i + a) / e, this._z = (o + u) / e) : s > h ? (e = 2 * Math.sqrt(1 + s - r - h), this._w = (o - u) / e, this._x = (i + a) / e, this._y = .25 * e, this._z = (c + l) / e) : (e = 2 * Math.sqrt(1 + h - r - s), this._w = (a - i) / e, this._x = (o + u) / e, this._y = (c + l) / e, this._z = .25 * e), this.onChangeCallback(), this
        },
        setFromUnitVectors: function() {
            var t, e = new Ge;
            return function(n, r) {
                return void 0 === e && (e = new Ge), (t = n.dot(r) + 1) < 1e-6 ? (t = 0, Math.abs(n.x) > Math.abs(n.z) ? e.set(-n.y, n.x, 0) : e.set(0, -n.z, n.y)) : e.crossVectors(n, r), this._x = e.x, this._y = e.y, this._z = e.z, this._w = t, this.normalize()
            }
        }(),
        angleTo: function(t) {
            return 2 * Math.acos(Math.abs(ke.clamp(this.dot(t), -1, 1)))
        },
        rotateTowards: function(t, e) {
            var n = this.angleTo(t);
            if (0 === n) return this;
            var r = Math.min(1, e / n);
            return this.slerp(t, r), this
        },
        inverse: function() {
            return this.conjugate()
        },
        conjugate: function() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
        },
        dot: function(t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var t = this.length();
            return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this.onChangeCallback(), this
        },
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
        },
        premultiply: function(t) {
            return this.multiplyQuaternions(t, this)
        },
        multiplyQuaternions: function(t, e) {
            var n = t._x,
                r = t._y,
                i = t._z,
                o = t._w,
                a = e._x,
                s = e._y,
                c = e._z,
                u = e._w;
            return this._x = n * u + o * a + r * c - i * s, this._y = r * u + o * s + i * a - n * c, this._z = i * u + o * c + n * s - r * a, this._w = o * u - n * a - r * s - i * c, this.onChangeCallback(), this
        },
        slerp: function(t, e) {
            if (0 === e) return this;
            if (1 === e) return this.copy(t);
            var n = this._x,
                r = this._y,
                i = this._z,
                o = this._w,
                a = o * t._w + n * t._x + r * t._y + i * t._z;
            if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = o, this._x = n, this._y = r, this._z = i, this;
            var s = 1 - a * a;
            if (s <= Number.EPSILON) {
                var c = 1 - e;
                return this._w = c * o + e * this._w, this._x = c * n + e * this._x, this._y = c * r + e * this._y, this._z = c * i + e * this._z, this.normalize()
            }
            var u = Math.sqrt(s),
                l = Math.atan2(u, a),
                h = Math.sin((1 - e) * l) / u,
                f = Math.sin(e * l) / u;
            return this._w = o * h + this._w * f, this._x = n * h + this._x * f, this._y = r * h + this._y * f, this._z = i * h + this._z * f, this.onChangeCallback(), this
        },
        equals: function(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
        },
        onChange: function(t) {
            return this.onChangeCallback = t, this
        },
        onChangeCallback: function() {}
    }), Object.assign(Ge.prototype, {
        isVector3: !0,
        set: function(t, e, n) {
            return this.x = t, this.y = e, this.z = n, this
        },
        setScalar: function(t) {
            return this.x = t, this.y = t, this.z = t, this
        },
        setX: function(t) {
            return this.x = t, this
        },
        setY: function(t) {
            return this.y = t, this
        },
        setZ: function(t) {
            return this.z = t, this
        },
        setComponent: function(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z)
        },
        copy: function(t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
        },
        addScalar: function(t) {
            return this.x += t, this.y += t, this.z += t, this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
        },
        subScalar: function(t) {
            return this.x -= t, this.y -= t, this.z -= t, this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
        },
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
        },
        multiplyScalar: function(t) {
            return this.x *= t, this.y *= t, this.z *= t, this
        },
        multiplyVectors: function(t, e) {
            return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
        },
        applyEuler: function() {
            var t = new Ne;
            return function(e) {
                return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(t.setFromEuler(e))
            }
        }(),
        applyAxisAngle: function() {
            var t = new Ne;
            return function(e, n) {
                return this.applyQuaternion(t.setFromAxisAngle(e, n))
            }
        }(),
        applyMatrix3: function(t) {
            var e = this.x,
                n = this.y,
                r = this.z,
                i = t.elements;
            return this.x = i[0] * e + i[3] * n + i[6] * r, this.y = i[1] * e + i[4] * n + i[7] * r, this.z = i[2] * e + i[5] * n + i[8] * r, this
        },
        applyMatrix4: function(t) {
            var e = this.x,
                n = this.y,
                r = this.z,
                i = t.elements,
                o = 1 / (i[3] * e + i[7] * n + i[11] * r + i[15]);
            return this.x = (i[0] * e + i[4] * n + i[8] * r + i[12]) * o, this.y = (i[1] * e + i[5] * n + i[9] * r + i[13]) * o, this.z = (i[2] * e + i[6] * n + i[10] * r + i[14]) * o, this
        },
        applyQuaternion: function(t) {
            var e = this.x,
                n = this.y,
                r = this.z,
                i = t.x,
                o = t.y,
                a = t.z,
                s = t.w,
                c = s * e + o * r - a * n,
                u = s * n + a * e - i * r,
                l = s * r + i * n - o * e,
                h = -i * e - o * n - a * r;
            return this.x = c * s + h * -i + u * -a - l * -o, this.y = u * s + h * -o + l * -i - c * -a, this.z = l * s + h * -a + c * -o - u * -i, this
        },
        project: function(t) {
            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
        },
        unproject: function() {
            var t = new Be;
            return function(e) {
                return this.applyMatrix4(t.getInverse(e.projectionMatrix)).applyMatrix4(e.matrixWorld)
            }
        }(),
        transformDirection: function(t) {
            var e = this.x,
                n = this.y,
                r = this.z,
                i = t.elements;
            return this.x = i[0] * e + i[4] * n + i[8] * r, this.y = i[1] * e + i[5] * n + i[9] * r, this.z = i[2] * e + i[6] * n + i[10] * r, this.normalize()
        },
        divide: function(t) {
            return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
        },
        clampScalar: function() {
            var t = new Ge,
                e = new Ge;
            return function(n, r) {
                return t.set(n, n, n), e.set(r, r, r), this.clamp(t, e)
            }
        }(),
        clampLength: function(t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
        },
        lerpVectors: function(t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t)
        },
        cross: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
        },
        crossVectors: function(t, e) {
            var n = t.x,
                r = t.y,
                i = t.z,
                o = e.x,
                a = e.y,
                s = e.z;
            return this.x = r * s - i * a, this.y = i * o - n * s, this.z = n * a - r * o, this
        },
        projectOnVector: function(t) {
            var e = t.dot(this) / t.lengthSq();
            return this.copy(t).multiplyScalar(e)
        },
        projectOnPlane: function() {
            var t = new Ge;
            return function(e) {
                return t.copy(this).projectOnVector(e), this.sub(t)
            }
        }(),
        reflect: function() {
            var t = new Ge;
            return function(e) {
                return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
            }
        }(),
        angleTo: function(t) {
            var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
            return Math.acos(ke.clamp(e, -1, 1))
        },
        distanceTo: function(t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function(t) {
            var e = this.x - t.x,
                n = this.y - t.y,
                r = this.z - t.z;
            return e * e + n * n + r * r
        },
        manhattanDistanceTo: function(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
        },
        setFromSpherical: function(t) {
            return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
        },
        setFromSphericalCoords: function(t, e, n) {
            var r = Math.sin(e) * t;
            return this.x = r * Math.sin(n), this.y = Math.cos(e) * t, this.z = r * Math.cos(n), this
        },
        setFromCylindrical: function(t) {
            return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
        },
        setFromCylindricalCoords: function(t, e, n) {
            return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
        },
        setFromMatrixPosition: function(t) {
            var e = t.elements;
            return this.x = e[12], this.y = e[13], this.z = e[14], this
        },
        setFromMatrixScale: function(t) {
            var e = this.setFromMatrixColumn(t, 0).length(),
                n = this.setFromMatrixColumn(t, 1).length(),
                r = this.setFromMatrixColumn(t, 2).length();
            return this.x = e, this.y = n, this.z = r, this
        },
        setFromMatrixColumn: function(t, e) {
            return this.fromArray(t.elements, 4 * e)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
        },
        fromBufferAttribute: function(t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
        }
    }), Object.assign(He.prototype, {
        isMatrix3: !0,
        set: function(t, e, n, r, i, o, a, s, c) {
            var u = this.elements;
            return u[0] = t, u[1] = r, u[2] = a, u[3] = e, u[4] = i, u[5] = s, u[6] = n, u[7] = o, u[8] = c, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        },
        clone: function() {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function(t) {
            var e = this.elements,
                n = t.elements;
            return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
        },
        setFromMatrix4: function(t) {
            var e = t.elements;
            return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
        },
        applyToBufferAttribute: function() {
            var t = new Ge;
            return function(e) {
                for (var n = 0, r = e.count; n < r; n++) t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.applyMatrix3(this), e.setXYZ(n, t.x, t.y, t.z);
                return e
            }
        }(),
        multiply: function(t) {
            return this.multiplyMatrices(this, t)
        },
        premultiply: function(t) {
            return this.multiplyMatrices(t, this)
        },
        multiplyMatrices: function(t, e) {
            var n = t.elements,
                r = e.elements,
                i = this.elements,
                o = n[0],
                a = n[3],
                s = n[6],
                c = n[1],
                u = n[4],
                l = n[7],
                h = n[2],
                f = n[5],
                d = n[8],
                v = r[0],
                p = r[3],
                m = r[6],
                g = r[1],
                y = r[4],
                x = r[7],
                b = r[2],
                w = r[5],
                _ = r[8];
            return i[0] = o * v + a * g + s * b, i[3] = o * p + a * y + s * w, i[6] = o * m + a * x + s * _, i[1] = c * v + u * g + l * b, i[4] = c * p + u * y + l * w, i[7] = c * m + u * x + l * _, i[2] = h * v + f * g + d * b, i[5] = h * p + f * y + d * w, i[8] = h * m + f * x + d * _, this
        },
        multiplyScalar: function(t) {
            var e = this.elements;
            return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
        },
        determinant: function() {
            var t = this.elements,
                e = t[0],
                n = t[1],
                r = t[2],
                i = t[3],
                o = t[4],
                a = t[5],
                s = t[6],
                c = t[7],
                u = t[8];
            return e * o * u - e * a * c - n * i * u + n * a * s + r * i * c - r * o * s
        },
        getInverse: function(t, e) {
            t && t.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            var n = t.elements,
                r = this.elements,
                i = n[0],
                o = n[1],
                a = n[2],
                s = n[3],
                c = n[4],
                u = n[5],
                l = n[6],
                h = n[7],
                f = n[8],
                d = f * c - u * h,
                v = u * l - f * s,
                p = h * s - c * l,
                m = i * d + o * v + a * p;
            if (0 === m) {
                var g = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                if (!0 === e) throw new Error(g);
                return console.warn(g), this.identity()
            }
            var y = 1 / m;
            return r[0] = d * y, r[1] = (a * h - f * o) * y, r[2] = (u * o - a * c) * y, r[3] = v * y, r[4] = (f * i - a * l) * y, r[5] = (a * s - u * i) * y, r[6] = p * y, r[7] = (o * l - h * i) * y, r[8] = (c * i - o * s) * y, this
        },
        transpose: function() {
            var t, e = this.elements;
            return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
        },
        getNormalMatrix: function(t) {
            return this.setFromMatrix4(t).getInverse(this).transpose()
        },
        transposeIntoArray: function(t) {
            var e = this.elements;
            return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
        },
        setUvTransform: function(t, e, n, r, i, o, a) {
            var s = Math.cos(i),
                c = Math.sin(i);
            this.set(n * s, n * c, -n * (s * o + c * a) + o + t, -r * c, r * s, -r * (-c * o + s * a) + a + e, 0, 0, 1)
        },
        scale: function(t, e) {
            var n = this.elements;
            return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
        },
        rotate: function(t) {
            var e = Math.cos(t),
                n = Math.sin(t),
                r = this.elements,
                i = r[0],
                o = r[3],
                a = r[6],
                s = r[1],
                c = r[4],
                u = r[7];
            return r[0] = e * i + n * s, r[3] = e * o + n * c, r[6] = e * a + n * u, r[1] = -n * i + e * s, r[4] = -n * o + e * c, r[7] = -n * a + e * u, this
        },
        translate: function(t, e) {
            var n = this.elements;
            return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
        },
        equals: function(t) {
            for (var e = this.elements, n = t.elements, r = 0; r < 9; r++)
                if (e[r] !== n[r]) return !1;
            return !0
        },
        fromArray: function(t, e) {
            void 0 === e && (e = 0);
            for (var n = 0; n < 9; n++) this.elements[n] = t[n + e];
            return this
        },
        toArray: function(t, e) {
            void 0 === t && (t = []), void 0 === e && (e = 0);
            var n = this.elements;
            return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
        }
    });
    var Ve = {
            getDataURL: function(t) {
                var e;
                if (t instanceof HTMLCanvasElement) e = t;
                else {
                    (e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")).width = t.width, e.height = t.height;
                    var n = e.getContext("2d");
                    t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height)
                }
                return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
            }
        },
        We = 0;

    function Ye(t, e, n, r, i, o, a, s, c, u) {
        Object.defineProperty(this, "id", {
            value: We++
        }), this.uuid = ke.generateUUID(), this.name = "", this.image = void 0 !== t ? t : Ye.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : Ye.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : mt, this.wrapT = void 0 !== r ? r : mt, this.magFilter = void 0 !== i ? i : wt, this.minFilter = void 0 !== o ? o : Mt, this.anisotropy = void 0 !== c ? c : 1, this.format = void 0 !== a ? a : kt, this.type = void 0 !== s ? s : St, this.offset = new Ue(0, 0), this.repeat = new Ue(1, 1), this.center = new Ue(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new He, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== u ? u : Te, this.version = 0, this.onUpdate = null
    }

    function Xe(t, e, n, r) {
        this.x = t || 0, this.y = e || 0, this.z = n || 0, this.w = void 0 !== r ? r : 1
    }

    function qe(t, e, n) {
        this.width = t, this.height = e, this.scissor = new Xe(0, 0, t, e), this.scissorTest = !1, this.viewport = new Xe(0, 0, t, e), void 0 === (n = n || {}).minFilter && (n.minFilter = wt), this.texture = new Ye(void 0, void 0, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.generateMipmaps = void 0 === n.generateMipmaps || n.generateMipmaps, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
    }

    function Ke(t, e, n) {
        qe.call(this, t, e, n), this.activeCubeFace = 0, this.activeMipMapLevel = 0
    }

    function Ze(t, e, n, r, i, o, a, s, c, u, l, h) {
        Ye.call(this, null, o, a, s, c, u, r, i, l, h), this.image = {
            data: t,
            width: e,
            height: n
        }, this.magFilter = void 0 !== c ? c : yt, this.minFilter = void 0 !== u ? u : yt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }

    function Je(t, e) {
        this.min = void 0 !== t ? t : new Ge(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Ge(-1 / 0, -1 / 0, -1 / 0)
    }

    function Qe(t, e) {
        this.center = void 0 !== t ? t : new Ge, this.radius = void 0 !== e ? e : 0
    }

    function $e(t, e) {
        this.normal = void 0 !== t ? t : new Ge(1, 0, 0), this.constant = void 0 !== e ? e : 0
    }

    function tn(t, e, n, r, i, o) {
        this.planes = [void 0 !== t ? t : new $e, void 0 !== e ? e : new $e, void 0 !== n ? n : new $e, void 0 !== r ? r : new $e, void 0 !== i ? i : new $e, void 0 !== o ? o : new $e]
    }
    Ye.DEFAULT_IMAGE = void 0, Ye.DEFAULT_MAPPING = st, Ye.prototype = Object.assign(Object.create(r.prototype), {
        constructor: Ye,
        isTexture: !0,
        updateMatrix: function() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
        },
        toJSON: function(t) {
            var e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
            var n = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY
            };
            if (void 0 !== this.image) {
                var r = this.image;
                if (void 0 === r.uuid && (r.uuid = ke.generateUUID()), !e && void 0 === t.images[r.uuid]) {
                    var i;
                    if (Array.isArray(r)) {
                        i = [];
                        for (var o = 0, a = r.length; o < a; o++) i.push(Ve.getDataURL(r[o]))
                    } else i = Ve.getDataURL(r);
                    t.images[r.uuid] = {
                        uuid: r.uuid,
                        url: i
                    }
                }
                n.image = r.uuid
            }
            return e || (t.textures[this.uuid] = n), n
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(t) {
            if (this.mapping !== st) return t;
            if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                case pt:
                    t.x = t.x - Math.floor(t.x);
                    break;
                case mt:
                    t.x = t.x < 0 ? 0 : 1;
                    break;
                case gt:
                    1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
            }
            if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                case pt:
                    t.y = t.y - Math.floor(t.y);
                    break;
                case mt:
                    t.y = t.y < 0 ? 0 : 1;
                    break;
                case gt:
                    1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
            }
            return this.flipY && (t.y = 1 - t.y), t
        }
    }), Object.defineProperty(Ye.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }), Object.assign(Xe.prototype, {
        isVector4: !0,
        set: function(t, e, n, r) {
            return this.x = t, this.y = e, this.z = n, this.w = r, this
        },
        setScalar: function(t) {
            return this.x = t, this.y = t, this.z = t, this.w = t, this
        },
        setX: function(t) {
            return this.x = t, this
        },
        setY: function(t) {
            return this.y = t, this
        },
        setZ: function(t) {
            return this.z = t, this
        },
        setW: function(t) {
            return this.w = t, this
        },
        setComponent: function(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                case 3:
                    this.w = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z, this.w)
        },
        copy: function(t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
        },
        addScalar: function(t) {
            return this.x += t, this.y += t, this.z += t, this.w += t, this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
        },
        subScalar: function(t) {
            return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
        },
        multiplyScalar: function(t) {
            return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
        },
        applyMatrix4: function(t) {
            var e = this.x,
                n = this.y,
                r = this.z,
                i = this.w,
                o = t.elements;
            return this.x = o[0] * e + o[4] * n + o[8] * r + o[12] * i, this.y = o[1] * e + o[5] * n + o[9] * r + o[13] * i, this.z = o[2] * e + o[6] * n + o[10] * r + o[14] * i, this.w = o[3] * e + o[7] * n + o[11] * r + o[15] * i, this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        setAxisAngleFromQuaternion: function(t) {
            this.w = 2 * Math.acos(t.w);
            var e = Math.sqrt(1 - t.w * t.w);
            return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
        },
        setAxisAngleFromRotationMatrix: function(t) {
            var e, n, r, i, o = t.elements,
                a = o[0],
                s = o[4],
                c = o[8],
                u = o[1],
                l = o[5],
                h = o[9],
                f = o[2],
                d = o[6],
                v = o[10];
            if (Math.abs(s - u) < .01 && Math.abs(c - f) < .01 && Math.abs(h - d) < .01) {
                if (Math.abs(s + u) < .1 && Math.abs(c + f) < .1 && Math.abs(h + d) < .1 && Math.abs(a + l + v - 3) < .1) return this.set(1, 0, 0, 0), this;
                e = Math.PI;
                var p = (a + 1) / 2,
                    m = (l + 1) / 2,
                    g = (v + 1) / 2,
                    y = (s + u) / 4,
                    x = (c + f) / 4,
                    b = (h + d) / 4;
                return p > m && p > g ? p < .01 ? (n = 0, r = .707106781, i = .707106781) : (r = y / (n = Math.sqrt(p)), i = x / n) : m > g ? m < .01 ? (n = .707106781, r = 0, i = .707106781) : (n = y / (r = Math.sqrt(m)), i = b / r) : g < .01 ? (n = .707106781, r = .707106781, i = 0) : (n = x / (i = Math.sqrt(g)), r = b / i), this.set(n, r, i, e), this
            }
            var w = Math.sqrt((d - h) * (d - h) + (c - f) * (c - f) + (u - s) * (u - s));
            return Math.abs(w) < .001 && (w = 1), this.x = (d - h) / w, this.y = (c - f) / w, this.z = (u - s) / w, this.w = Math.acos((a + l + v - 1) / 2), this
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
        },
        clampScalar: function() {
            var t, e;
            return function(n, r) {
                return void 0 === t && (t = new Xe, e = new Xe), t.set(n, n, n, n), e.set(r, r, r, r), this.clamp(t, e)
            }
        }(),
        clampLength: function(t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
        },
        lerpVectors: function(t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
        },
        fromBufferAttribute: function(t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
        }
    }), qe.prototype = Object.assign(Object.create(r.prototype), {
        constructor: qe,
        isWebGLRenderTarget: !0,
        setSize: function(t, e) {
            this.width === t && this.height === e || (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Ke.prototype = Object.create(qe.prototype), Ke.prototype.constructor = Ke, Ke.prototype.isWebGLRenderTargetCube = !0, Ze.prototype = Object.create(Ye.prototype), Ze.prototype.constructor = Ze, Ze.prototype.isDataTexture = !0, Object.assign(Je.prototype, {
        isBox3: !0,
        set: function(t, e) {
            return this.min.copy(t), this.max.copy(e), this
        },
        setFromArray: function(t) {
            for (var e = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = t.length; s < c; s += 3) {
                var u = t[s],
                    l = t[s + 1],
                    h = t[s + 2];
                u < e && (e = u), l < n && (n = l), h < r && (r = h), u > i && (i = u), l > o && (o = l), h > a && (a = h)
            }
            return this.min.set(e, n, r), this.max.set(i, o, a), this
        },
        setFromBufferAttribute: function(t) {
            for (var e = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = t.count; s < c; s++) {
                var u = t.getX(s),
                    l = t.getY(s),
                    h = t.getZ(s);
                u < e && (e = u), l < n && (n = l), h < r && (r = h), u > i && (i = u), l > o && (o = l), h > a && (a = h)
            }
            return this.min.set(e, n, r), this.max.set(i, o, a), this
        },
        setFromPoints: function(t) {
            this.makeEmpty();
            for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
            return this
        },
        setFromCenterAndSize: function() {
            var t = new Ge;
            return function(e, n) {
                var r = t.copy(n).multiplyScalar(.5);
                return this.min.copy(e).sub(r), this.max.copy(e).add(r), this
            }
        }(),
        setFromObject: function(t) {
            return this.makeEmpty(), this.expandByObject(t)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function(t) {
            return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new Ge), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(t) {
            return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new Ge), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
        },
        expandByPoint: function(t) {
            return this.min.min(t), this.max.max(t), this
        },
        expandByVector: function(t) {
            return this.min.sub(t), this.max.add(t), this
        },
        expandByScalar: function(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this
        },
        expandByObject: function() {
            var t, e, n, r = new Ge;

            function i(i) {
                var o = i.geometry;
                if (void 0 !== o)
                    if (o.isGeometry) {
                        var a = o.vertices;
                        for (e = 0, n = a.length; e < n; e++) r.copy(a[e]), r.applyMatrix4(i.matrixWorld), t.expandByPoint(r)
                    } else if (o.isBufferGeometry) {
                    var s = o.attributes.position;
                    if (void 0 !== s)
                        for (e = 0, n = s.count; e < n; e++) r.fromBufferAttribute(s, e).applyMatrix4(i.matrixWorld), t.expandByPoint(r)
                }
            }
            return function(e) {
                return t = this, e.updateMatrixWorld(!0), e.traverse(i), this
            }
        }(),
        containsPoint: function(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
        },
        containsBox: function(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
        },
        getParameter: function(t, e) {
            return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new Ge), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
        },
        intersectsSphere: function() {
            var t = new Ge;
            return function(e) {
                return this.clampPoint(e.center, t), t.distanceToSquared(e.center) <= e.radius * e.radius
            }
        }(),
        intersectsPlane: function(t) {
            var e, n;
            return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
        },
        intersectsTriangle: function() {
            var t = new Ge,
                e = new Ge,
                n = new Ge,
                r = new Ge,
                i = new Ge,
                o = new Ge,
                a = new Ge,
                s = new Ge,
                c = new Ge,
                u = new Ge;

            function l(r) {
                var i, o;
                for (i = 0, o = r.length - 3; i <= o; i += 3) {
                    a.fromArray(r, i);
                    var s = c.x * Math.abs(a.x) + c.y * Math.abs(a.y) + c.z * Math.abs(a.z),
                        u = t.dot(a),
                        l = e.dot(a),
                        h = n.dot(a);
                    if (Math.max(-Math.max(u, l, h), Math.min(u, l, h)) > s) return !1
                }
                return !0
            }
            return function(a) {
                if (this.isEmpty()) return !1;
                this.getCenter(s), c.subVectors(this.max, s), t.subVectors(a.a, s), e.subVectors(a.b, s), n.subVectors(a.c, s), r.subVectors(e, t), i.subVectors(n, e), o.subVectors(t, n);
                var h = [0, -r.z, r.y, 0, -i.z, i.y, 0, -o.z, o.y, r.z, 0, -r.x, i.z, 0, -i.x, o.z, 0, -o.x, -r.y, r.x, 0, -i.y, i.x, 0, -o.y, o.x, 0];
                return !!l(h) && (!!l(h = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (u.crossVectors(r, i), l(h = [u.x, u.y, u.z])))
            }
        }(),
        clampPoint: function(t, e) {
            return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new Ge), e.copy(t).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var t = new Ge;
            return function(e) {
                return t.copy(e).clamp(this.min, this.max).sub(e).length()
            }
        }(),
        getBoundingSphere: function() {
            var t = new Ge;
            return function(e) {
                return void 0 === e && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"), e = new Qe), this.getCenter(e.center), e.radius = .5 * this.getSize(t).length(), e
            }
        }(),
        intersect: function(t) {
            return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
        },
        union: function(t) {
            return this.min.min(t.min), this.max.max(t.max), this
        },
        applyMatrix4: function() {
            var t = [new Ge, new Ge, new Ge, new Ge, new Ge, new Ge, new Ge, new Ge];
            return function(e) {
                return this.isEmpty() ? this : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(t), this)
            }
        }(),
        translate: function(t) {
            return this.min.add(t), this.max.add(t), this
        },
        equals: function(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    }), Object.assign(Qe.prototype, {
        set: function(t, e) {
            return this.center.copy(t), this.radius = e, this
        },
        setFromPoints: function() {
            var t = new Je;
            return function(e, n) {
                var r = this.center;
                void 0 !== n ? r.copy(n) : t.setFromPoints(e).getCenter(r);
                for (var i = 0, o = 0, a = e.length; o < a; o++) i = Math.max(i, r.distanceToSquared(e[o]));
                return this.radius = Math.sqrt(i), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.center.copy(t.center), this.radius = t.radius, this
        },
        empty: function() {
            return this.radius <= 0
        },
        containsPoint: function(t) {
            return t.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(t) {
            return t.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(t) {
            var e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e
        },
        intersectsBox: function(t) {
            return t.intersectsSphere(this)
        },
        intersectsPlane: function(t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius
        },
        clampPoint: function(t, e) {
            var n = this.center.distanceToSquared(t);
            return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new Ge), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
        },
        getBoundingBox: function(t) {
            return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new Je), t.set(this.center, this.center), t.expandByScalar(this.radius), t
        },
        applyMatrix4: function(t) {
            return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
        },
        translate: function(t) {
            return this.center.add(t), this
        },
        equals: function(t) {
            return t.center.equals(this.center) && t.radius === this.radius
        }
    }), Object.assign($e.prototype, {
        set: function(t, e) {
            return this.normal.copy(t), this.constant = e, this
        },
        setComponents: function(t, e, n, r) {
            return this.normal.set(t, e, n), this.constant = r, this
        },
        setFromNormalAndCoplanarPoint: function(t, e) {
            return this.normal.copy(t), this.constant = -e.dot(this.normal), this
        },
        setFromCoplanarPoints: function() {
            var t = new Ge,
                e = new Ge;
            return function(n, r, i) {
                var o = t.subVectors(i, r).cross(e.subVectors(n, r)).normalize();
                return this.setFromNormalAndCoplanarPoint(o, n), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.normal.copy(t.normal), this.constant = t.constant, this
        },
        normalize: function() {
            var t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t), this.constant *= t, this
        },
        negate: function() {
            return this.constant *= -1, this.normal.negate(), this
        },
        distanceToPoint: function(t) {
            return this.normal.dot(t) + this.constant
        },
        distanceToSphere: function(t) {
            return this.distanceToPoint(t.center) - t.radius
        },
        projectPoint: function(t, e) {
            return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new Ge), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
        },
        intersectLine: function() {
            var t = new Ge;
            return function(e, n) {
                void 0 === n && (console.warn("THREE.Plane: .intersectLine() target is now required"), n = new Ge);
                var r = e.delta(t),
                    i = this.normal.dot(r);
                if (0 === i) return 0 === this.distanceToPoint(e.start) ? n.copy(e.start) : void 0;
                var o = -(e.start.dot(this.normal) + this.constant) / i;
                return o < 0 || o > 1 ? void 0 : n.copy(r).multiplyScalar(o).add(e.start)
            }
        }(),
        intersectsLine: function(t) {
            var e = this.distanceToPoint(t.start),
                n = this.distanceToPoint(t.end);
            return e < 0 && n > 0 || n < 0 && e > 0
        },
        intersectsBox: function(t) {
            return t.intersectsPlane(this)
        },
        intersectsSphere: function(t) {
            return t.intersectsPlane(this)
        },
        coplanarPoint: function(t) {
            return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new Ge), t.copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function() {
            var t = new Ge,
                e = new He;
            return function(n, r) {
                var i = r || e.getNormalMatrix(n),
                    o = this.coplanarPoint(t).applyMatrix4(n),
                    a = this.normal.applyMatrix3(i).normalize();
                return this.constant = -o.dot(a), this
            }
        }(),
        translate: function(t) {
            return this.constant -= t.dot(this.normal), this
        },
        equals: function(t) {
            return t.normal.equals(this.normal) && t.constant === this.constant
        }
    }), Object.assign(tn.prototype, {
        set: function(t, e, n, r, i, o) {
            var a = this.planes;
            return a[0].copy(t), a[1].copy(e), a[2].copy(n), a[3].copy(r), a[4].copy(i), a[5].copy(o), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            for (var e = this.planes, n = 0; n < 6; n++) e[n].copy(t.planes[n]);
            return this
        },
        setFromMatrix: function(t) {
            var e = this.planes,
                n = t.elements,
                r = n[0],
                i = n[1],
                o = n[2],
                a = n[3],
                s = n[4],
                c = n[5],
                u = n[6],
                l = n[7],
                h = n[8],
                f = n[9],
                d = n[10],
                v = n[11],
                p = n[12],
                m = n[13],
                g = n[14],
                y = n[15];
            return e[0].setComponents(a - r, l - s, v - h, y - p).normalize(), e[1].setComponents(a + r, l + s, v + h, y + p).normalize(), e[2].setComponents(a + i, l + c, v + f, y + m).normalize(), e[3].setComponents(a - i, l - c, v - f, y - m).normalize(), e[4].setComponents(a - o, l - u, v - d, y - g).normalize(), e[5].setComponents(a + o, l + u, v + d, y + g).normalize(), this
        },
        intersectsObject: function() {
            var t = new Qe;
            return function(e) {
                var n = e.geometry;
                return null === n.boundingSphere && n.computeBoundingSphere(), t.copy(n.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
            }
        }(),
        intersectsSprite: function() {
            var t = new Qe;
            return function(e) {
                return t.center.set(0, 0, 0), t.radius = .7071067811865476, t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
            }
        }(),
        intersectsSphere: function(t) {
            for (var e = this.planes, n = t.center, r = -t.radius, i = 0; i < 6; i++) {
                if (e[i].distanceToPoint(n) < r) return !1
            }
            return !0
        },
        intersectsBox: function() {
            var t = new Ge;
            return function(e) {
                for (var n = this.planes, r = 0; r < 6; r++) {
                    var i = n[r];
                    if (t.x = i.normal.x > 0 ? e.max.x : e.min.x, t.y = i.normal.y > 0 ? e.max.y : e.min.y, t.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(t) < 0) return !1
                }
                return !0
            }
        }(),
        containsPoint: function(t) {
            for (var e = this.planes, n = 0; n < 6; n++)
                if (e[n].distanceToPoint(t) < 0) return !1;
            return !0
        }
    });
    var en = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
            alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "\nvec3 transformed = vec3( position );\n",
            beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
            bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif\n",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
            color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
            color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
            common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
            defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
            encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
            encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}\n",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
            envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
            envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
            fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif\n",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif\n",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
            gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
            lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
            lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif\n",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
            map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
            map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
            map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
            normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n",
            normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif\n",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
            project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
            dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
            dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
            shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
            shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
            tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
            uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
            uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
            uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
            uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
            background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n}\n",
            background_vert: "varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4( position, 1.0 );\n\tgl_Position.z = 1.0;\n}\n",
            cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
            cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
            depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
            equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
            meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\tvec4 matcapColor = texture2D( matcap, uv );\n\tmatcapColor = matcapTexelToLinear( matcapColor );\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}\n",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
            meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
            normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}\n",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",
            shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n"
        },
        nn = {
            merge: function(t) {
                for (var e = {}, n = 0; n < t.length; n++) {
                    var r = this.clone(t[n]);
                    for (var i in r) e[i] = r[i]
                }
                return e
            },
            clone: function(t) {
                var e = {};
                for (var n in t)
                    for (var r in e[n] = {}, t[n]) {
                        var i = t[n][r];
                        i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture) ? e[n][r] = i.clone() : Array.isArray(i) ? e[n][r] = i.slice() : e[n][r] = i
                    }
                return e
            }
        },
        rn = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        };

    function on(t, e, n) {
        return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
    }
    Object.assign(on.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(t) {
            return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
        },
        setScalar: function(t) {
            return this.r = t, this.g = t, this.b = t, this
        },
        setHex: function(t) {
            return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
        },
        setRGB: function(t, e, n) {
            return this.r = t, this.g = e, this.b = n, this
        },
        setHSL: function() {
            function t(t, e, n) {
                return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
            }
            return function(e, n, r) {
                if (e = ke.euclideanModulo(e, 1), n = ke.clamp(n, 0, 1), r = ke.clamp(r, 0, 1), 0 === n) this.r = this.g = this.b = r;
                else {
                    var i = r <= .5 ? r * (1 + n) : r + n - r * n,
                        o = 2 * r - i;
                    this.r = t(o, i, e + 1 / 3), this.g = t(o, i, e), this.b = t(o, i, e - 1 / 3)
                }
                return this
            }
        }(),
        setStyle: function(t) {
            function e(e) {
                void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
            }
            var n;
            if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                var r, i = n[1],
                    o = n[2];
                switch (i) {
                    case "rgb":
                    case "rgba":
                        if (r = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(r[1], 10)) / 255, this.g = Math.min(255, parseInt(r[2], 10)) / 255, this.b = Math.min(255, parseInt(r[3], 10)) / 255, e(r[5]), this;
                        if (r = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(r[1], 10)) / 100, this.g = Math.min(100, parseInt(r[2], 10)) / 100, this.b = Math.min(100, parseInt(r[3], 10)) / 100, e(r[5]), this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (r = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
                            var a = parseFloat(r[1]) / 360,
                                s = parseInt(r[2], 10) / 100,
                                c = parseInt(r[3], 10) / 100;
                            return e(r[5]), this.setHSL(a, s, c)
                        }
                }
            } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                var u, l = (u = n[1]).length;
                if (3 === l) return this.r = parseInt(u.charAt(0) + u.charAt(0), 16) / 255, this.g = parseInt(u.charAt(1) + u.charAt(1), 16) / 255, this.b = parseInt(u.charAt(2) + u.charAt(2), 16) / 255, this;
                if (6 === l) return this.r = parseInt(u.charAt(0) + u.charAt(1), 16) / 255, this.g = parseInt(u.charAt(2) + u.charAt(3), 16) / 255, this.b = parseInt(u.charAt(4) + u.charAt(5), 16) / 255, this
            }
            t && t.length > 0 && (void 0 !== (u = rn[t]) ? this.setHex(u) : console.warn("THREE.Color: Unknown color " + t));
            return this
        },
        clone: function() {
            return new this.constructor(this.r, this.g, this.b)
        },
        copy: function(t) {
            return this.r = t.r, this.g = t.g, this.b = t.b, this
        },
        copyGammaToLinear: function(t, e) {
            return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
        },
        copyLinearToGamma: function(t, e) {
            void 0 === e && (e = 2);
            var n = e > 0 ? 1 / e : 1;
            return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this
        },
        convertGammaToLinear: function(t) {
            return this.copyGammaToLinear(this, t), this
        },
        convertLinearToGamma: function(t) {
            return this.copyLinearToGamma(this, t), this
        },
        copySRGBToLinear: function() {
            function t(t) {
                return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
            }
            return function(e) {
                return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this
            }
        }(),
        copyLinearToSRGB: function() {
            function t(t) {
                return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
            }
            return function(e) {
                return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this
            }
        }(),
        convertSRGBToLinear: function() {
            return this.copySRGBToLinear(this), this
        },
        convertLinearToSRGB: function() {
            return this.copyLinearToSRGB(this), this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(t) {
            void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {
                h: 0,
                s: 0,
                l: 0
            });
            var e, n, r = this.r,
                i = this.g,
                o = this.b,
                a = Math.max(r, i, o),
                s = Math.min(r, i, o),
                c = (s + a) / 2;
            if (s === a) e = 0, n = 0;
            else {
                var u = a - s;
                switch (n = c <= .5 ? u / (a + s) : u / (2 - a - s), a) {
                    case r:
                        e = (i - o) / u + (i < o ? 6 : 0);
                        break;
                    case i:
                        e = (o - r) / u + 2;
                        break;
                    case o:
                        e = (r - i) / u + 4
                }
                e /= 6
            }
            return t.h = e, t.s = n, t.l = c, t
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function() {
            var t = {};
            return function(e, n, r) {
                return this.getHSL(t), t.h += e, t.s += n, t.l += r, this.setHSL(t.h, t.s, t.l), this
            }
        }(),
        add: function(t) {
            return this.r += t.r, this.g += t.g, this.b += t.b, this
        },
        addColors: function(t, e) {
            return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
        },
        addScalar: function(t) {
            return this.r += t, this.g += t, this.b += t, this
        },
        sub: function(t) {
            return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
        },
        multiply: function(t) {
            return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
        },
        multiplyScalar: function(t) {
            return this.r *= t, this.g *= t, this.b *= t, this
        },
        lerp: function(t, e) {
            return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
        },
        lerpHSL: function() {
            var t = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                e = {
                    h: 0,
                    s: 0,
                    l: 0
                };
            return function(n, r) {
                this.getHSL(t), n.getHSL(e);
                var i = ke.lerp(t.h, e.h, r),
                    o = ke.lerp(t.s, e.s, r),
                    a = ke.lerp(t.l, e.l, r);
                return this.setHSL(i, o, a), this
            }
        }(),
        equals: function(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
        },
        toJSON: function() {
            return this.getHex()
        }
    });
    var an = {
            common: {
                diffuse: {
                    value: new on(15658734)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new He
                },
                alphaMap: {
                    value: null
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                refractionRatio: {
                    value: .98
                },
                maxMipLevel: {
                    value: 0
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalScale: {
                    value: new Ue(1, 1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new on(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotShadowMap: {
                    value: []
                },
                spotShadowMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                }
            },
            points: {
                diffuse: {
                    value: new on(15658734)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new He
                }
            },
            sprite: {
                diffuse: {
                    value: new on(15658734)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new Ue(.5, .5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new He
                }
            }
        },
        sn = {
            basic: {
                uniforms: nn.merge([an.common, an.specularmap, an.envmap, an.aomap, an.lightmap, an.fog]),
                vertexShader: en.meshbasic_vert,
                fragmentShader: en.meshbasic_frag
            },
            lambert: {
                uniforms: nn.merge([an.common, an.specularmap, an.envmap, an.aomap, an.lightmap, an.emissivemap, an.fog, an.lights, {
                    emissive: {
                        value: new on(0)
                    }
                }]),
                vertexShader: en.meshlambert_vert,
                fragmentShader: en.meshlambert_frag
            },
            phong: {
                uniforms: nn.merge([an.common, an.specularmap, an.envmap, an.aomap, an.lightmap, an.emissivemap, an.bumpmap, an.normalmap, an.displacementmap, an.gradientmap, an.fog, an.lights, {
                    emissive: {
                        value: new on(0)
                    },
                    specular: {
                        value: new on(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: en.meshphong_vert,
                fragmentShader: en.meshphong_frag
            },
            standard: {
                uniforms: nn.merge([an.common, an.envmap, an.aomap, an.lightmap, an.emissivemap, an.bumpmap, an.normalmap, an.displacementmap, an.roughnessmap, an.metalnessmap, an.fog, an.lights, {
                    emissive: {
                        value: new on(0)
                    },
                    roughness: {
                        value: .5
                    },
                    metalness: {
                        value: .5
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: en.meshphysical_vert,
                fragmentShader: en.meshphysical_frag
            },
            matcap: {
                uniforms: nn.merge([an.common, an.bumpmap, an.normalmap, an.displacementmap, an.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: en.meshmatcap_vert,
                fragmentShader: en.meshmatcap_frag
            },
            points: {
                uniforms: nn.merge([an.points, an.fog]),
                vertexShader: en.points_vert,
                fragmentShader: en.points_frag
            },
            dashed: {
                uniforms: nn.merge([an.common, an.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: en.linedashed_vert,
                fragmentShader: en.linedashed_frag
            },
            depth: {
                uniforms: nn.merge([an.common, an.displacementmap]),
                vertexShader: en.depth_vert,
                fragmentShader: en.depth_frag
            },
            normal: {
                uniforms: nn.merge([an.common, an.bumpmap, an.normalmap, an.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: en.normal_vert,
                fragmentShader: en.normal_frag
            },
            sprite: {
                uniforms: nn.merge([an.sprite, an.fog]),
                vertexShader: en.sprite_vert,
                fragmentShader: en.sprite_frag
            },
            background: {
                uniforms: {
                    t2D: {
                        value: null
                    }
                },
                vertexShader: en.background_vert,
                fragmentShader: en.background_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: en.cube_vert,
                fragmentShader: en.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: en.equirect_vert,
                fragmentShader: en.equirect_frag
            },
            distanceRGBA: {
                uniforms: nn.merge([an.common, an.displacementmap, {
                    referencePosition: {
                        value: new Ge
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: en.distanceRGBA_vert,
                fragmentShader: en.distanceRGBA_frag
            },
            shadow: {
                uniforms: nn.merge([an.lights, an.fog, {
                    color: {
                        value: new on(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: en.shadow_vert,
                fragmentShader: en.shadow_frag
            }
        };

    function cn() {
        var t = null,
            e = !1,
            n = null;

        function r(i, o) {
            !1 !== e && (n(i, o), t.requestAnimationFrame(r))
        }
        return {
            start: function() {
                !0 !== e && null !== n && (t.requestAnimationFrame(r), e = !0)
            },
            stop: function() {
                e = !1
            },
            setAnimationLoop: function(t) {
                n = t
            },
            setContext: function(e) {
                t = e
            }
        }
    }

    function un(t) {
        var e = new WeakMap;
        return {
            get: function(t) {
                return t.isInterleavedBufferAttribute && (t = t.data), e.get(t)
            },
            remove: function(n) {
                n.isInterleavedBufferAttribute && (n = n.data);
                var r = e.get(n);
                r && (t.deleteBuffer(r.buffer), e.delete(n))
            },
            update: function(n, r) {
                n.isInterleavedBufferAttribute && (n = n.data);
                var i = e.get(n);
                void 0 === i ? e.set(n, function(e, n) {
                    var r = e.array,
                        i = e.dynamic ? t.DYNAMIC_DRAW : t.STATIC_DRAW,
                        o = t.createBuffer();
                    t.bindBuffer(n, o), t.bufferData(n, r, i), e.onUploadCallback();
                    var a = t.FLOAT;
                    return r instanceof Float32Array ? a = t.FLOAT : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? a = t.UNSIGNED_SHORT : r instanceof Int16Array ? a = t.SHORT : r instanceof Uint32Array ? a = t.UNSIGNED_INT : r instanceof Int32Array ? a = t.INT : r instanceof Int8Array ? a = t.BYTE : r instanceof Uint8Array && (a = t.UNSIGNED_BYTE), {
                        buffer: o,
                        type: a,
                        bytesPerElement: r.BYTES_PER_ELEMENT,
                        version: e.version
                    }
                }(n, r)) : i.version < n.version && (function(e, n, r) {
                    var i = n.array,
                        o = n.updateRange;
                    t.bindBuffer(r, e), !1 === n.dynamic ? t.bufferData(r, i, t.STATIC_DRAW) : -1 === o.count ? t.bufferSubData(r, 0, i) : 0 === o.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(r, o.offset * i.BYTES_PER_ELEMENT, i.subarray(o.offset, o.offset + o.count)), o.count = -1)
                }(i.buffer, n, r), i.version = n.version)
            }
        }
    }

    function ln(t, e, n, r, i, o) {
        this.a = t, this.b = e, this.c = n, this.normal = r && r.isVector3 ? r : new Ge, this.vertexNormals = Array.isArray(r) ? r : [], this.color = i && i.isColor ? i : new on, this.vertexColors = Array.isArray(i) ? i : [], this.materialIndex = void 0 !== o ? o : 0
    }

    function hn(t, e, n, r) {
        this._x = t || 0, this._y = e || 0, this._z = n || 0, this._order = r || hn.DefaultOrder
    }

    function fn() {
        this.mask = 1
    }
    sn.physical = {
        uniforms: nn.merge([sn.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        }]),
        vertexShader: en.meshphysical_vert,
        fragmentShader: en.meshphysical_frag
    }, Object.assign(ln.prototype, {
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
            for (var e = 0, n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
            for (e = 0, n = t.vertexColors.length; e < n; e++) this.vertexColors[e] = t.vertexColors[e].clone();
            return this
        }
    }), hn.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], hn.DefaultOrder = "XYZ", Object.defineProperties(hn.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(t) {
                this._x = t, this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(t) {
                this._y = t, this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(t) {
                this._z = t, this.onChangeCallback()
            }
        },
        order: {
            get: function() {
                return this._order
            },
            set: function(t) {
                this._order = t, this.onChangeCallback()
            }
        }
    }), Object.assign(hn.prototype, {
        isEuler: !0,
        set: function(t, e, n, r) {
            return this._x = t, this._y = e, this._z = n, this._order = r || this._order, this.onChangeCallback(), this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._order)
        },
        copy: function(t) {
            return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this
        },
        setFromRotationMatrix: function(t, e, n) {
            var r = ke.clamp,
                i = t.elements,
                o = i[0],
                a = i[4],
                s = i[8],
                c = i[1],
                u = i[5],
                l = i[9],
                h = i[2],
                f = i[6],
                d = i[10];
            return "XYZ" === (e = e || this._order) ? (this._y = Math.asin(r(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-l, d), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(f, u), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-r(l, -1, 1)), Math.abs(l) < .99999 ? (this._y = Math.atan2(s, d), this._z = Math.atan2(c, u)) : (this._y = Math.atan2(-h, o), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(r(f, -1, 1)), Math.abs(f) < .99999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-a, u)) : (this._y = 0, this._z = Math.atan2(c, o))) : "ZYX" === e ? (this._y = Math.asin(-r(h, -1, 1)), Math.abs(h) < .99999 ? (this._x = Math.atan2(f, d), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-a, u))) : "YZX" === e ? (this._z = Math.asin(r(c, -1, 1)), Math.abs(c) < .99999 ? (this._x = Math.atan2(-l, u), this._y = Math.atan2(-h, o)) : (this._x = 0, this._y = Math.atan2(s, d))) : "XZY" === e ? (this._z = Math.asin(-r(a, -1, 1)), Math.abs(a) < .99999 ? (this._x = Math.atan2(f, u), this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-l, d), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, !1 !== n && this.onChangeCallback(), this
        },
        setFromQuaternion: function() {
            var t = new Be;
            return function(e, n, r) {
                return t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, n, r)
            }
        }(),
        setFromVector3: function(t, e) {
            return this.set(t.x, t.y, t.z, e || this._order)
        },
        reorder: function() {
            var t = new Ne;
            return function(e) {
                return t.setFromEuler(this), this.setFromQuaternion(t, e)
            }
        }(),
        equals: function(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
        },
        fromArray: function(t) {
            return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
        },
        toVector3: function(t) {
            return t ? t.set(this._x, this._y, this._z) : new Ge(this._x, this._y, this._z)
        },
        onChange: function(t) {
            return this.onChangeCallback = t, this
        },
        onChangeCallback: function() {}
    }), Object.assign(fn.prototype, {
        set: function(t) {
            this.mask = 1 << t | 0
        },
        enable: function(t) {
            this.mask |= 1 << t | 0
        },
        toggle: function(t) {
            this.mask ^= 1 << t | 0
        },
        disable: function(t) {
            this.mask &= ~(1 << t | 0)
        },
        test: function(t) {
            return 0 != (this.mask & t.mask)
        }
    });
    var dn = 0;

    function vn() {
        Object.defineProperty(this, "id", {
            value: dn++
        }), this.uuid = ke.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = vn.DefaultUp.clone();
        var t = new Ge,
            e = new hn,
            n = new Ne,
            r = new Ge(1, 1, 1);
        e.onChange(function() {
            n.setFromEuler(e, !1)
        }), n.onChange(function() {
            e.setFromQuaternion(n, void 0, !1)
        }), Object.defineProperties(this, {
            position: {
                enumerable: !0,
                value: t
            },
            rotation: {
                enumerable: !0,
                value: e
            },
            quaternion: {
                enumerable: !0,
                value: n
            },
            scale: {
                enumerable: !0,
                value: r
            },
            modelViewMatrix: {
                value: new Be
            },
            normalMatrix: {
                value: new He
            }
        }), this.matrix = new Be, this.matrixWorld = new Be, this.matrixAutoUpdate = vn.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new fn, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
    }
    vn.DefaultUp = new Ge(0, 1, 0), vn.DefaultMatrixAutoUpdate = !0, vn.prototype = Object.assign(Object.create(r.prototype), {
        constructor: vn,
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix: function(t) {
            this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function(t) {
            return this.quaternion.premultiply(t), this
        },
        setRotationFromAxisAngle: function(t, e) {
            this.quaternion.setFromAxisAngle(t, e)
        },
        setRotationFromEuler: function(t) {
            this.quaternion.setFromEuler(t, !0)
        },
        setRotationFromMatrix: function(t) {
            this.quaternion.setFromRotationMatrix(t)
        },
        setRotationFromQuaternion: function(t) {
            this.quaternion.copy(t)
        },
        rotateOnAxis: function() {
            var t = new Ne;
            return function(e, n) {
                return t.setFromAxisAngle(e, n), this.quaternion.multiply(t), this
            }
        }(),
        rotateOnWorldAxis: function() {
            var t = new Ne;
            return function(e, n) {
                return t.setFromAxisAngle(e, n), this.quaternion.premultiply(t), this
            }
        }(),
        rotateX: function() {
            var t = new Ge(1, 0, 0);
            return function(e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        rotateY: function() {
            var t = new Ge(0, 1, 0);
            return function(e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        rotateZ: function() {
            var t = new Ge(0, 0, 1);
            return function(e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        translateOnAxis: function() {
            var t = new Ge;
            return function(e, n) {
                return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(n)), this
            }
        }(),
        translateX: function() {
            var t = new Ge(1, 0, 0);
            return function(e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        translateY: function() {
            var t = new Ge(0, 1, 0);
            return function(e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        translateZ: function() {
            var t = new Ge(0, 0, 1);
            return function(e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        localToWorld: function(t) {
            return t.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function() {
            var t = new Be;
            return function(e) {
                return e.applyMatrix4(t.getInverse(this.matrixWorld))
            }
        }(),
        lookAt: function() {
            var t = new Ne,
                e = new Be,
                n = new Ge,
                r = new Ge;
            return function(i, o, a) {
                i.isVector3 ? n.copy(i) : n.set(i, o, a);
                var s = this.parent;
                this.updateWorldMatrix(!0, !1), r.setFromMatrixPosition(this.matrixWorld), this.isCamera ? e.lookAt(r, n, this.up) : e.lookAt(n, r, this.up), this.quaternion.setFromRotationMatrix(e), s && (e.extractRotation(s.matrixWorld), t.setFromRotationMatrix(e), this.quaternion.premultiply(t.inverse()))
            }
        }(),
        add: function(t) {
            if (arguments.length > 1) {
                for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                return this
            }
            return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({
                type: "added"
            }), this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
        },
        remove: function(t) {
            if (arguments.length > 1) {
                for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                return this
            }
            var n = this.children.indexOf(t);
            return -1 !== n && (t.parent = null, t.dispatchEvent({
                type: "removed"
            }), this.children.splice(n, 1)), this
        },
        getObjectById: function(t) {
            return this.getObjectByProperty("id", t)
        },
        getObjectByName: function(t) {
            return this.getObjectByProperty("name", t)
        },
        getObjectByProperty: function(t, e) {
            if (this[t] === e) return this;
            for (var n = 0, r = this.children.length; n < r; n++) {
                var i = this.children[n].getObjectByProperty(t, e);
                if (void 0 !== i) return i
            }
        },
        getWorldPosition: function(t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new Ge), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function() {
            var t = new Ge,
                e = new Ge;
            return function(n) {
                return void 0 === n && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), n = new Ne), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, n, e), n
            }
        }(),
        getWorldScale: function() {
            var t = new Ge,
                e = new Ne;
            return function(n) {
                return void 0 === n && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), n = new Ge), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, n), n
            }
        }(),
        getWorldDirection: function(t) {
            void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new Ge), this.updateMatrixWorld(!0);
            var e = this.matrixWorld.elements;
            return t.set(e[8], e[9], e[10]).normalize()
        },
        raycast: function() {},
        traverse: function(t) {
            t(this);
            for (var e = this.children, n = 0, r = e.length; n < r; n++) e[n].traverse(t)
        },
        traverseVisible: function(t) {
            if (!1 !== this.visible) {
                t(this);
                for (var e = this.children, n = 0, r = e.length; n < r; n++) e[n].traverseVisible(t)
            }
        },
        traverseAncestors: function(t) {
            var e = this.parent;
            null !== e && (t(e), e.traverseAncestors(t))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(t) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
            for (var e = this.children, n = 0, r = e.length; n < r; n++) e[n].updateMatrixWorld(t)
        },
        updateWorldMatrix: function(t, e) {
            var n = this.parent;
            if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e)
                for (var r = this.children, i = 0, o = r.length; i < o; i++) r[i].updateWorldMatrix(!1, !0)
        },
        toJSON: function(t) {
            var e = void 0 === t || "string" == typeof t,
                n = {};
            e && (t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            }, n.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var r = {};

            function i(e, n) {
                return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
            }
            if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isMesh || this.isLine || this.isPoints) {
                r.geometry = i(t.geometries, this.geometry);
                var o = this.geometry.parameters;
                if (void 0 !== o && void 0 !== o.shapes) {
                    var a = o.shapes;
                    if (Array.isArray(a))
                        for (var s = 0, c = a.length; s < c; s++) {
                            var u = a[s];
                            i(t.shapes, u)
                        } else i(t.shapes, a)
                }
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    var l = [];
                    for (s = 0, c = this.material.length; s < c; s++) l.push(i(t.materials, this.material[s]));
                    r.material = l
                } else r.material = i(t.materials, this.material);
            if (this.children.length > 0) {
                r.children = [];
                for (s = 0; s < this.children.length; s++) r.children.push(this.children[s].toJSON(t).object)
            }
            if (e) {
                var h = p(t.geometries),
                    f = p(t.materials),
                    d = p(t.textures),
                    v = p(t.images);
                a = p(t.shapes);
                h.length > 0 && (n.geometries = h), f.length > 0 && (n.materials = f), d.length > 0 && (n.textures = d), v.length > 0 && (n.images = v), a.length > 0 && (n.shapes = a)
            }
            return n.object = r, n;

            function p(t) {
                var e = [];
                for (var n in t) {
                    var r = t[n];
                    delete r.metadata, e.push(r)
                }
                return e
            }
        },
        clone: function(t) {
            return (new this.constructor).copy(this, t)
        },
        copy: function(t, e) {
            if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                for (var n = 0; n < t.children.length; n++) {
                    var r = t.children[n];
                    this.add(r.clone())
                }
            return this
        }
    });
    var pn = 0;

    function mn() {
        Object.defineProperty(this, "id", {
            value: pn += 2
        }), this.uuid = ke.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
            []
        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
    }

    function gn(t, e, n) {
        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }

    function yn(t, e, n) {
        gn.call(this, new Int8Array(t), e, n)
    }

    function xn(t, e, n) {
        gn.call(this, new Uint8Array(t), e, n)
    }

    function bn(t, e, n) {
        gn.call(this, new Uint8ClampedArray(t), e, n)
    }

    function wn(t, e, n) {
        gn.call(this, new Int16Array(t), e, n)
    }

    function _n(t, e, n) {
        gn.call(this, new Uint16Array(t), e, n)
    }

    function Mn(t, e, n) {
        gn.call(this, new Int32Array(t), e, n)
    }

    function Sn(t, e, n) {
        gn.call(this, new Uint32Array(t), e, n)
    }

    function En(t, e, n) {
        gn.call(this, new Float32Array(t), e, n)
    }

    function Tn(t, e, n) {
        gn.call(this, new Float64Array(t), e, n)
    }

    function Pn() {
        this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
    }

    function Ln(t) {
        if (0 === t.length) return -1 / 0;
        for (var e = t[0], n = 1, r = t.length; n < r; ++n) t[n] > e && (e = t[n]);
        return e
    }
    mn.prototype = Object.assign(Object.create(r.prototype), {
        constructor: mn,
        isGeometry: !0,
        applyMatrix: function(t) {
            for (var e = (new He).getNormalMatrix(t), n = 0, r = this.vertices.length; n < r; n++) {
                this.vertices[n].applyMatrix4(t)
            }
            for (n = 0, r = this.faces.length; n < r; n++) {
                var i = this.faces[n];
                i.normal.applyMatrix3(e).normalize();
                for (var o = 0, a = i.vertexNormals.length; o < a; o++) i.vertexNormals[o].applyMatrix3(e).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
        },
        rotateX: function() {
            var t = new Be;
            return function(e) {
                return t.makeRotationX(e), this.applyMatrix(t), this
            }
        }(),
        rotateY: function() {
            var t = new Be;
            return function(e) {
                return t.makeRotationY(e), this.applyMatrix(t), this
            }
        }(),
        rotateZ: function() {
            var t = new Be;
            return function(e) {
                return t.makeRotationZ(e), this.applyMatrix(t), this
            }
        }(),
        translate: function() {
            var t = new Be;
            return function(e, n, r) {
                return t.makeTranslation(e, n, r), this.applyMatrix(t), this
            }
        }(),
        scale: function() {
            var t = new Be;
            return function(e, n, r) {
                return t.makeScale(e, n, r), this.applyMatrix(t), this
            }
        }(),
        lookAt: function() {
            var t = new vn;
            return function(e) {
                t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
            }
        }(),
        fromBufferGeometry: function(t) {
            var e = this,
                n = null !== t.index ? t.index.array : void 0,
                r = t.attributes,
                i = r.position.array,
                o = void 0 !== r.normal ? r.normal.array : void 0,
                a = void 0 !== r.color ? r.color.array : void 0,
                s = void 0 !== r.uv ? r.uv.array : void 0,
                c = void 0 !== r.uv2 ? r.uv2.array : void 0;
            void 0 !== c && (this.faceVertexUvs[1] = []);
            for (var u = [], l = [], h = [], f = 0, d = 0; f < i.length; f += 3, d += 2) e.vertices.push(new Ge(i[f], i[f + 1], i[f + 2])), void 0 !== o && u.push(new Ge(o[f], o[f + 1], o[f + 2])), void 0 !== a && e.colors.push(new on(a[f], a[f + 1], a[f + 2])), void 0 !== s && l.push(new Ue(s[d], s[d + 1])), void 0 !== c && h.push(new Ue(c[d], c[d + 1]));

            function v(t, n, r, i) {
                var f = new ln(t, n, r, void 0 !== o ? [u[t].clone(), u[n].clone(), u[r].clone()] : [], void 0 !== a ? [e.colors[t].clone(), e.colors[n].clone(), e.colors[r].clone()] : [], i);
                e.faces.push(f), void 0 !== s && e.faceVertexUvs[0].push([l[t].clone(), l[n].clone(), l[r].clone()]), void 0 !== c && e.faceVertexUvs[1].push([h[t].clone(), h[n].clone(), h[r].clone()])
            }
            var p = t.groups;
            if (p.length > 0)
                for (f = 0; f < p.length; f++)
                    for (var m = p[f], g = m.start, y = (d = g, g + m.count); d < y; d += 3) void 0 !== n ? v(n[d], n[d + 1], n[d + 2], m.materialIndex) : v(d, d + 1, d + 2, m.materialIndex);
            else if (void 0 !== n)
                for (f = 0; f < n.length; f += 3) v(n[f], n[f + 1], n[f + 2]);
            else
                for (f = 0; f < i.length / 3; f += 3) v(f, f + 1, f + 2);
            return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
        },
        center: function() {
            var t = new Ge;
            return function() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this
            }
        }(),
        normalize: function() {
            this.computeBoundingSphere();
            var t = this.boundingSphere.center,
                e = this.boundingSphere.radius,
                n = 0 === e ? 1 : 1 / e,
                r = new Be;
            return r.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix(r), this
        },
        computeFaceNormals: function() {
            for (var t = new Ge, e = new Ge, n = 0, r = this.faces.length; n < r; n++) {
                var i = this.faces[n],
                    o = this.vertices[i.a],
                    a = this.vertices[i.b],
                    s = this.vertices[i.c];
                t.subVectors(s, a), e.subVectors(o, a), t.cross(e), t.normalize(), i.normal.copy(t)
            }
        },
        computeVertexNormals: function(t) {
            var e, n, r, i, o, a;
            for (void 0 === t && (t = !0), a = new Array(this.vertices.length), e = 0, n = this.vertices.length; e < n; e++) a[e] = new Ge;
            if (t) {
                var s, c, u, l = new Ge,
                    h = new Ge;
                for (r = 0, i = this.faces.length; r < i; r++) o = this.faces[r], s = this.vertices[o.a], c = this.vertices[o.b], u = this.vertices[o.c], l.subVectors(u, c), h.subVectors(s, c), l.cross(h), a[o.a].add(l), a[o.b].add(l), a[o.c].add(l)
            } else
                for (this.computeFaceNormals(), r = 0, i = this.faces.length; r < i; r++) a[(o = this.faces[r]).a].add(o.normal), a[o.b].add(o.normal), a[o.c].add(o.normal);
            for (e = 0, n = this.vertices.length; e < n; e++) a[e].normalize();
            for (r = 0, i = this.faces.length; r < i; r++) {
                var f = (o = this.faces[r]).vertexNormals;
                3 === f.length ? (f[0].copy(a[o.a]), f[1].copy(a[o.b]), f[2].copy(a[o.c])) : (f[0] = a[o.a].clone(), f[1] = a[o.b].clone(), f[2] = a[o.c].clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function() {
            var t, e, n;
            for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
                var r = (n = this.faces[t]).vertexNormals;
                3 === r.length ? (r[0].copy(n.normal), r[1].copy(n.normal), r[2].copy(n.normal)) : (r[0] = n.normal.clone(), r[1] = n.normal.clone(), r[2] = n.normal.clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            var t, e, n, r, i;
            for (n = 0, r = this.faces.length; n < r; n++)
                for ((i = this.faces[n]).__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(), i.__originalVertexNormals || (i.__originalVertexNormals = []), t = 0, e = i.vertexNormals.length; t < e; t++) i.__originalVertexNormals[t] ? i.__originalVertexNormals[t].copy(i.vertexNormals[t]) : i.__originalVertexNormals[t] = i.vertexNormals[t].clone();
            var o = new mn;
            for (o.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
                if (!this.morphNormals[t]) {
                    this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [];
                    var a = this.morphNormals[t].faceNormals,
                        s = this.morphNormals[t].vertexNormals;
                    for (n = 0, r = this.faces.length; n < r; n++) c = new Ge, u = {
                        a: new Ge,
                        b: new Ge,
                        c: new Ge
                    }, a.push(c), s.push(u)
                }
                var c, u, l = this.morphNormals[t];
                for (o.vertices = this.morphTargets[t].vertices, o.computeFaceNormals(), o.computeVertexNormals(), n = 0, r = this.faces.length; n < r; n++) i = this.faces[n], c = l.faceNormals[n], u = l.vertexNormals[n], c.copy(i.normal), u.a.copy(i.vertexNormals[0]), u.b.copy(i.vertexNormals[1]), u.c.copy(i.vertexNormals[2])
            }
            for (n = 0, r = this.faces.length; n < r; n++)(i = this.faces[n]).normal = i.__originalFaceNormal, i.vertexNormals = i.__originalVertexNormals
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new Je), this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new Qe), this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(t, e, n) {
            if (t && t.isGeometry) {
                var r, i = this.vertices.length,
                    o = this.vertices,
                    a = t.vertices,
                    s = this.faces,
                    c = t.faces,
                    u = this.faceVertexUvs[0],
                    l = t.faceVertexUvs[0],
                    h = this.colors,
                    f = t.colors;
                void 0 === n && (n = 0), void 0 !== e && (r = (new He).getNormalMatrix(e));
                for (var d = 0, v = a.length; d < v; d++) {
                    var p = a[d].clone();
                    void 0 !== e && p.applyMatrix4(e), o.push(p)
                }
                for (d = 0, v = f.length; d < v; d++) h.push(f[d].clone());
                for (d = 0, v = c.length; d < v; d++) {
                    var m, g, y, x = c[d],
                        b = x.vertexNormals,
                        w = x.vertexColors;
                    (m = new ln(x.a + i, x.b + i, x.c + i)).normal.copy(x.normal), void 0 !== r && m.normal.applyMatrix3(r).normalize();
                    for (var _ = 0, M = b.length; _ < M; _++) g = b[_].clone(), void 0 !== r && g.applyMatrix3(r).normalize(), m.vertexNormals.push(g);
                    m.color.copy(x.color);
                    for (_ = 0, M = w.length; _ < M; _++) y = w[_], m.vertexColors.push(y.clone());
                    m.materialIndex = x.materialIndex + n, s.push(m)
                }
                for (d = 0, v = l.length; d < v; d++) {
                    var S = l[d],
                        E = [];
                    if (void 0 !== S) {
                        for (_ = 0, M = S.length; _ < M; _++) E.push(S[_].clone());
                        u.push(E)
                    }
                }
            } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t)
        },
        mergeMesh: function(t) {
            t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
        },
        mergeVertices: function() {
            var t, e, n, r, i, o, a, s, c = {},
                u = [],
                l = [],
                h = Math.pow(10, 4);
            for (n = 0, r = this.vertices.length; n < r; n++) t = this.vertices[n], void 0 === c[e = Math.round(t.x * h) + "_" + Math.round(t.y * h) + "_" + Math.round(t.z * h)] ? (c[e] = n, u.push(this.vertices[n]), l[n] = u.length - 1) : l[n] = l[c[e]];
            var f = [];
            for (n = 0, r = this.faces.length; n < r; n++) {
                (i = this.faces[n]).a = l[i.a], i.b = l[i.b], i.c = l[i.c], o = [i.a, i.b, i.c];
                for (var d = 0; d < 3; d++)
                    if (o[d] === o[(d + 1) % 3]) {
                        f.push(n);
                        break
                    }
            }
            for (n = f.length - 1; n >= 0; n--) {
                var v = f[n];
                for (this.faces.splice(v, 1), a = 0, s = this.faceVertexUvs.length; a < s; a++) this.faceVertexUvs[a].splice(v, 1)
            }
            var p = this.vertices.length - u.length;
            return this.vertices = u, p
        },
        setFromPoints: function(t) {
            this.vertices = [];
            for (var e = 0, n = t.length; e < n; e++) {
                var r = t[e];
                this.vertices.push(new Ge(r.x, r.y, r.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function() {
            for (var t = this.faces, e = t.length, n = 0; n < e; n++) t[n]._id = n;
            t.sort(function(t, e) {
                return t.materialIndex - e.materialIndex
            });
            var r, i, o = this.faceVertexUvs[0],
                a = this.faceVertexUvs[1];
            o && o.length === e && (r = []), a && a.length === e && (i = []);
            for (n = 0; n < e; n++) {
                var s = t[n]._id;
                r && r.push(o[s]), i && i.push(a[s])
            }
            r && (this.faceVertexUvs[0] = r), i && (this.faceVertexUvs[1] = i)
        },
        toJSON: function() {
            var t = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                var e = this.parameters;
                for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
                return t
            }
            for (var r = [], i = 0; i < this.vertices.length; i++) {
                var o = this.vertices[i];
                r.push(o.x, o.y, o.z)
            }
            var a = [],
                s = [],
                c = {},
                u = [],
                l = {},
                h = [],
                f = {};
            for (i = 0; i < this.faces.length; i++) {
                var d = this.faces[i],
                    v = void 0 !== this.faceVertexUvs[0][i],
                    p = d.normal.length() > 0,
                    m = d.vertexNormals.length > 0,
                    g = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b,
                    y = d.vertexColors.length > 0,
                    x = 0;
                if (x = M(x = M(x = M(x = M(x = M(x = M(x = M(x = M(x, 0, 0), 1, !0), 2, !1), 3, v), 4, p), 5, m), 6, g), 7, y), a.push(x), a.push(d.a, d.b, d.c), a.push(d.materialIndex), v) {
                    var b = this.faceVertexUvs[0][i];
                    a.push(T(b[0]), T(b[1]), T(b[2]))
                }
                if (p && a.push(S(d.normal)), m) {
                    var w = d.vertexNormals;
                    a.push(S(w[0]), S(w[1]), S(w[2]))
                }
                if (g && a.push(E(d.color)), y) {
                    var _ = d.vertexColors;
                    a.push(E(_[0]), E(_[1]), E(_[2]))
                }
            }

            function M(t, e, n) {
                return n ? t | 1 << e : t & ~(1 << e)
            }

            function S(t) {
                var e = t.x.toString() + t.y.toString() + t.z.toString();
                return void 0 !== c[e] ? c[e] : (c[e] = s.length / 3, s.push(t.x, t.y, t.z), c[e])
            }

            function E(t) {
                var e = t.r.toString() + t.g.toString() + t.b.toString();
                return void 0 !== l[e] ? l[e] : (l[e] = u.length, u.push(t.getHex()), l[e])
            }

            function T(t) {
                var e = t.x.toString() + t.y.toString();
                return void 0 !== f[e] ? f[e] : (f[e] = h.length / 2, h.push(t.x, t.y), f[e])
            }
            return t.data = {}, t.data.vertices = r, t.data.normals = s, u.length > 0 && (t.data.colors = u), h.length > 0 && (t.data.uvs = [h]), t.data.faces = a, t
        },
        clone: function() {
            return (new mn).copy(this)
        },
        copy: function(t) {
            var e, n, r, i, o, a;
            this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
            var s = t.vertices;
            for (e = 0, n = s.length; e < n; e++) this.vertices.push(s[e].clone());
            var c = t.colors;
            for (e = 0, n = c.length; e < n; e++) this.colors.push(c[e].clone());
            var u = t.faces;
            for (e = 0, n = u.length; e < n; e++) this.faces.push(u[e].clone());
            for (e = 0, n = t.faceVertexUvs.length; e < n; e++) {
                var l = t.faceVertexUvs[e];
                for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), r = 0, i = l.length; r < i; r++) {
                    var h = l[r],
                        f = [];
                    for (o = 0, a = h.length; o < a; o++) {
                        var d = h[o];
                        f.push(d.clone())
                    }
                    this.faceVertexUvs[e].push(f)
                }
            }
            var v = t.morphTargets;
            for (e = 0, n = v.length; e < n; e++) {
                var p = {};
                if (p.name = v[e].name, void 0 !== v[e].vertices)
                    for (p.vertices = [], r = 0, i = v[e].vertices.length; r < i; r++) p.vertices.push(v[e].vertices[r].clone());
                if (void 0 !== v[e].normals)
                    for (p.normals = [], r = 0, i = v[e].normals.length; r < i; r++) p.normals.push(v[e].normals[r].clone());
                this.morphTargets.push(p)
            }
            var m = t.morphNormals;
            for (e = 0, n = m.length; e < n; e++) {
                var g = {};
                if (void 0 !== m[e].vertexNormals)
                    for (g.vertexNormals = [], r = 0, i = m[e].vertexNormals.length; r < i; r++) {
                        var y = m[e].vertexNormals[r],
                            x = {};
                        x.a = y.a.clone(), x.b = y.b.clone(), x.c = y.c.clone(), g.vertexNormals.push(x)
                    }
                if (void 0 !== m[e].faceNormals)
                    for (g.faceNormals = [], r = 0, i = m[e].faceNormals.length; r < i; r++) g.faceNormals.push(m[e].faceNormals[r].clone());
                this.morphNormals.push(g)
            }
            var b = t.skinWeights;
            for (e = 0, n = b.length; e < n; e++) this.skinWeights.push(b[e].clone());
            var w = t.skinIndices;
            for (e = 0, n = w.length; e < n; e++) this.skinIndices.push(w[e].clone());
            var _ = t.lineDistances;
            for (e = 0, n = _.length; e < n; e++) this.lineDistances.push(_[e]);
            var M = t.boundingBox;
            null !== M && (this.boundingBox = M.clone());
            var S = t.boundingSphere;
            return null !== S && (this.boundingSphere = S.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Object.defineProperty(gn.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }), Object.assign(gn.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function() {},
        setArray: function(t) {
            if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t, this
        },
        setDynamic: function(t) {
            return this.dynamic = t, this
        },
        copy: function(t) {
            return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this
        },
        copyAt: function(t, e, n) {
            t *= this.itemSize, n *= e.itemSize;
            for (var r = 0, i = this.itemSize; r < i; r++) this.array[t + r] = e.array[n + r];
            return this
        },
        copyArray: function(t) {
            return this.array.set(t), this
        },
        copyColorsArray: function(t) {
            for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
                var o = t[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), o = new on), e[n++] = o.r, e[n++] = o.g, e[n++] = o.b
            }
            return this
        },
        copyVector2sArray: function(t) {
            for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
                var o = t[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), o = new Ue), e[n++] = o.x, e[n++] = o.y
            }
            return this
        },
        copyVector3sArray: function(t) {
            for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
                var o = t[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), o = new Ge), e[n++] = o.x, e[n++] = o.y, e[n++] = o.z
            }
            return this
        },
        copyVector4sArray: function(t) {
            for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
                var o = t[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), o = new Xe), e[n++] = o.x, e[n++] = o.y, e[n++] = o.z, e[n++] = o.w
            }
            return this
        },
        set: function(t, e) {
            return void 0 === e && (e = 0), this.array.set(t, e), this
        },
        getX: function(t) {
            return this.array[t * this.itemSize]
        },
        setX: function(t, e) {
            return this.array[t * this.itemSize] = e, this
        },
        getY: function(t) {
            return this.array[t * this.itemSize + 1]
        },
        setY: function(t, e) {
            return this.array[t * this.itemSize + 1] = e, this
        },
        getZ: function(t) {
            return this.array[t * this.itemSize + 2]
        },
        setZ: function(t, e) {
            return this.array[t * this.itemSize + 2] = e, this
        },
        getW: function(t) {
            return this.array[t * this.itemSize + 3]
        },
        setW: function(t, e) {
            return this.array[t * this.itemSize + 3] = e, this
        },
        setXY: function(t, e, n) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
        },
        setXYZ: function(t, e, n, r) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this
        },
        setXYZW: function(t, e, n, r, i) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this.array[t + 3] = i, this
        },
        onUpload: function(t) {
            return this.onUploadCallback = t, this
        },
        clone: function() {
            return new this.constructor(this.array, this.itemSize).copy(this)
        }
    }), yn.prototype = Object.create(gn.prototype), yn.prototype.constructor = yn, xn.prototype = Object.create(gn.prototype), xn.prototype.constructor = xn, bn.prototype = Object.create(gn.prototype), bn.prototype.constructor = bn, wn.prototype = Object.create(gn.prototype), wn.prototype.constructor = wn, _n.prototype = Object.create(gn.prototype), _n.prototype.constructor = _n, Mn.prototype = Object.create(gn.prototype), Mn.prototype.constructor = Mn, Sn.prototype = Object.create(gn.prototype), Sn.prototype.constructor = Sn, En.prototype = Object.create(gn.prototype), En.prototype.constructor = En, Tn.prototype = Object.create(gn.prototype), Tn.prototype.constructor = Tn, Object.assign(Pn.prototype, {
        computeGroups: function(t) {
            for (var e, n = [], r = void 0, i = t.faces, o = 0; o < i.length; o++) {
                var a = i[o];
                a.materialIndex !== r && (r = a.materialIndex, void 0 !== e && (e.count = 3 * o - e.start, n.push(e)), e = {
                    start: 3 * o,
                    materialIndex: r
                })
            }
            void 0 !== e && (e.count = 3 * o - e.start, n.push(e)), this.groups = n
        },
        fromGeometry: function(t) {
            var e, n = t.faces,
                r = t.vertices,
                i = t.faceVertexUvs,
                o = i[0] && i[0].length > 0,
                a = i[1] && i[1].length > 0,
                s = t.morphTargets,
                c = s.length;
            if (c > 0) {
                e = [];
                for (var u = 0; u < c; u++) e[u] = {
                    name: s[u].name,
                    data: []
                };
                this.morphTargets.position = e
            }
            var l, h = t.morphNormals,
                f = h.length;
            if (f > 0) {
                l = [];
                for (u = 0; u < f; u++) l[u] = {
                    name: h[u].name,
                    data: []
                };
                this.morphTargets.normal = l
            }
            var d = t.skinIndices,
                v = t.skinWeights,
                p = d.length === r.length,
                m = v.length === r.length;
            r.length > 0 && 0 === n.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
            for (u = 0; u < n.length; u++) {
                var g = n[u];
                this.vertices.push(r[g.a], r[g.b], r[g.c]);
                var y = g.vertexNormals;
                if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
                else {
                    var x = g.normal;
                    this.normals.push(x, x, x)
                }
                var b, w = g.vertexColors;
                if (3 === w.length) this.colors.push(w[0], w[1], w[2]);
                else {
                    var _ = g.color;
                    this.colors.push(_, _, _)
                }
                if (!0 === o) void 0 !== (b = i[0][u]) ? this.uvs.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", u), this.uvs.push(new Ue, new Ue, new Ue));
                if (!0 === a) void 0 !== (b = i[1][u]) ? this.uvs2.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", u), this.uvs2.push(new Ue, new Ue, new Ue));
                for (var M = 0; M < c; M++) {
                    var S = s[M].vertices;
                    e[M].data.push(S[g.a], S[g.b], S[g.c])
                }
                for (M = 0; M < f; M++) {
                    var E = h[M].vertexNormals[u];
                    l[M].data.push(E.a, E.b, E.c)
                }
                p && this.skinIndices.push(d[g.a], d[g.b], d[g.c]), m && this.skinWeights.push(v[g.a], v[g.b], v[g.c])
            }
            return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
        }
    });
    var An = 1;

    function zn() {
        Object.defineProperty(this, "id", {
            value: An += 2
        }), this.uuid = ke.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {}
    }

    function Cn(t, e, n, r, i, o) {
        mn.call(this), this.type = "BoxGeometry", this.parameters = {
            width: t,
            height: e,
            depth: n,
            widthSegments: r,
            heightSegments: i,
            depthSegments: o
        }, this.fromBufferGeometry(new Rn(t, e, n, r, i, o)), this.mergeVertices()
    }

    function Rn(t, e, n, r, i, o) {
        zn.call(this), this.type = "BoxBufferGeometry", this.parameters = {
            width: t,
            height: e,
            depth: n,
            widthSegments: r,
            heightSegments: i,
            depthSegments: o
        };
        var a = this;
        t = t || 1, e = e || 1, n = n || 1, r = Math.floor(r) || 1, i = Math.floor(i) || 1;
        var s = [],
            c = [],
            u = [],
            l = [],
            h = 0,
            f = 0;

        function d(t, e, n, r, i, o, d, v, p, m, g) {
            var y, x, b = o / p,
                w = d / m,
                _ = o / 2,
                M = d / 2,
                S = v / 2,
                E = p + 1,
                T = m + 1,
                P = 0,
                L = 0,
                A = new Ge;
            for (x = 0; x < T; x++) {
                var z = x * w - M;
                for (y = 0; y < E; y++) {
                    var C = y * b - _;
                    A[t] = C * r, A[e] = z * i, A[n] = S, c.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = v > 0 ? 1 : -1, u.push(A.x, A.y, A.z), l.push(y / p), l.push(1 - x / m), P += 1
                }
            }
            for (x = 0; x < m; x++)
                for (y = 0; y < p; y++) {
                    var R = h + y + E * x,
                        I = h + y + E * (x + 1),
                        D = h + (y + 1) + E * (x + 1),
                        O = h + (y + 1) + E * x;
                    s.push(R, I, O), s.push(I, D, O), L += 6
                }
            a.addGroup(f, L, g), f += L, h += P
        }
        d("z", "y", "x", -1, -1, n, e, t, o = Math.floor(o) || 1, i, 0), d("z", "y", "x", 1, -1, n, e, -t, o, i, 1), d("x", "z", "y", 1, 1, t, n, e, r, o, 2), d("x", "z", "y", 1, -1, t, n, -e, r, o, 3), d("x", "y", "z", 1, -1, t, e, n, r, i, 4), d("x", "y", "z", -1, -1, t, e, -n, r, i, 5), this.setIndex(s), this.addAttribute("position", new En(c, 3)), this.addAttribute("normal", new En(u, 3)), this.addAttribute("uv", new En(l, 2))
    }

    function In(t, e, n, r) {
        mn.call(this), this.type = "PlaneGeometry", this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: r
        }, this.fromBufferGeometry(new Dn(t, e, n, r)), this.mergeVertices()
    }

    function Dn(t, e, n, r) {
        zn.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: r
        };
        var i, o, a = (t = t || 1) / 2,
            s = (e = e || 1) / 2,
            c = Math.floor(n) || 1,
            u = Math.floor(r) || 1,
            l = c + 1,
            h = u + 1,
            f = t / c,
            d = e / u,
            v = [],
            p = [],
            m = [],
            g = [];
        for (o = 0; o < h; o++) {
            var y = o * d - s;
            for (i = 0; i < l; i++) {
                var x = i * f - a;
                p.push(x, -y, 0), m.push(0, 0, 1), g.push(i / c), g.push(1 - o / u)
            }
        }
        for (o = 0; o < u; o++)
            for (i = 0; i < c; i++) {
                var b = i + l * o,
                    w = i + l * (o + 1),
                    _ = i + 1 + l * (o + 1),
                    M = i + 1 + l * o;
                v.push(b, w, M), v.push(w, _, M)
            }
        this.setIndex(v), this.addAttribute("position", new En(p, 3)), this.addAttribute("normal", new En(m, 3)), this.addAttribute("uv", new En(g, 2))
    }
    zn.prototype = Object.assign(Object.create(r.prototype), {
        constructor: zn,
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index
        },
        setIndex: function(t) {
            Array.isArray(t) ? this.index = new(Ln(t) > 65535 ? Sn : _n)(t, 1) : this.index = t
        },
        addAttribute: function(t, e) {
            return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : (this.attributes[t] = e, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(t, new gn(arguments[1], arguments[2])))
        },
        getAttribute: function(t) {
            return this.attributes[t]
        },
        removeAttribute: function(t) {
            return delete this.attributes[t], this
        },
        addGroup: function(t, e, n) {
            this.groups.push({
                start: t,
                count: e,
                materialIndex: void 0 !== n ? n : 0
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(t, e) {
            this.drawRange.start = t, this.drawRange.count = e
        },
        applyMatrix: function(t) {
            var e = this.attributes.position;
            void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0);
            var n = this.attributes.normal;
            void 0 !== n && ((new He).getNormalMatrix(t).applyToBufferAttribute(n), n.needsUpdate = !0);
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
        },
        rotateX: function() {
            var t = new Be;
            return function(e) {
                return t.makeRotationX(e), this.applyMatrix(t), this
            }
        }(),
        rotateY: function() {
            var t = new Be;
            return function(e) {
                return t.makeRotationY(e), this.applyMatrix(t), this
            }
        }(),
        rotateZ: function() {
            var t = new Be;
            return function(e) {
                return t.makeRotationZ(e), this.applyMatrix(t), this
            }
        }(),
        translate: function() {
            var t = new Be;
            return function(e, n, r) {
                return t.makeTranslation(e, n, r), this.applyMatrix(t), this
            }
        }(),
        scale: function() {
            var t = new Be;
            return function(e, n, r) {
                return t.makeScale(e, n, r), this.applyMatrix(t), this
            }
        }(),
        lookAt: function() {
            var t = new vn;
            return function(e) {
                t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
            }
        }(),
        center: function() {
            var t = new Ge;
            return function() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this
            }
        }(),
        setFromObject: function(t) {
            var e = t.geometry;
            if (t.isPoints || t.isLine) {
                var n = new En(3 * e.vertices.length, 3),
                    r = new En(3 * e.colors.length, 3);
                if (this.addAttribute("position", n.copyVector3sArray(e.vertices)), this.addAttribute("color", r.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
                    var i = new En(e.lineDistances.length, 1);
                    this.addAttribute("lineDistance", i.copyArray(e.lineDistances))
                }
                null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
            } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
            return this
        },
        setFromPoints: function(t) {
            for (var e = [], n = 0, r = t.length; n < r; n++) {
                var i = t[n];
                e.push(i.x, i.y, i.z || 0)
            }
            return this.addAttribute("position", new En(e, 3)), this
        },
        updateFromObject: function(t) {
            var e, n = t.geometry;
            if (t.isMesh) {
                var r = n.__directGeometry;
                if (!0 === n.elementsNeedUpdate && (r = void 0, n.elementsNeedUpdate = !1), void 0 === r) return this.fromGeometry(n);
                r.verticesNeedUpdate = n.verticesNeedUpdate, r.normalsNeedUpdate = n.normalsNeedUpdate, r.colorsNeedUpdate = n.colorsNeedUpdate, r.uvsNeedUpdate = n.uvsNeedUpdate, r.groupsNeedUpdate = n.groupsNeedUpdate, n.verticesNeedUpdate = !1, n.normalsNeedUpdate = !1, n.colorsNeedUpdate = !1, n.uvsNeedUpdate = !1, n.groupsNeedUpdate = !1, n = r
            }
            return !0 === n.verticesNeedUpdate && (void 0 !== (e = this.attributes.position) && (e.copyVector3sArray(n.vertices), e.needsUpdate = !0), n.verticesNeedUpdate = !1), !0 === n.normalsNeedUpdate && (void 0 !== (e = this.attributes.normal) && (e.copyVector3sArray(n.normals), e.needsUpdate = !0), n.normalsNeedUpdate = !1), !0 === n.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e.copyColorsArray(n.colors), e.needsUpdate = !0), n.colorsNeedUpdate = !1), n.uvsNeedUpdate && (void 0 !== (e = this.attributes.uv) && (e.copyVector2sArray(n.uvs), e.needsUpdate = !0), n.uvsNeedUpdate = !1), n.lineDistancesNeedUpdate && (void 0 !== (e = this.attributes.lineDistance) && (e.copyArray(n.lineDistances), e.needsUpdate = !0), n.lineDistancesNeedUpdate = !1), n.groupsNeedUpdate && (n.computeGroups(t.geometry), this.groups = n.groups, n.groupsNeedUpdate = !1), this
        },
        fromGeometry: function(t) {
            return t.__directGeometry = (new Pn).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
        },
        fromDirectGeometry: function(t) {
            var e = new Float32Array(3 * t.vertices.length);
            if (this.addAttribute("position", new gn(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                var n = new Float32Array(3 * t.normals.length);
                this.addAttribute("normal", new gn(n, 3).copyVector3sArray(t.normals))
            }
            if (t.colors.length > 0) {
                var r = new Float32Array(3 * t.colors.length);
                this.addAttribute("color", new gn(r, 3).copyColorsArray(t.colors))
            }
            if (t.uvs.length > 0) {
                var i = new Float32Array(2 * t.uvs.length);
                this.addAttribute("uv", new gn(i, 2).copyVector2sArray(t.uvs))
            }
            if (t.uvs2.length > 0) {
                var o = new Float32Array(2 * t.uvs2.length);
                this.addAttribute("uv2", new gn(o, 2).copyVector2sArray(t.uvs2))
            }
            for (var a in this.groups = t.groups, t.morphTargets) {
                for (var s = [], c = t.morphTargets[a], u = 0, l = c.length; u < l; u++) {
                    var h = c[u],
                        f = new En(3 * h.data.length, 3);
                    f.name = h.name, s.push(f.copyVector3sArray(h.data))
                }
                this.morphAttributes[a] = s
            }
            if (t.skinIndices.length > 0) {
                var d = new En(4 * t.skinIndices.length, 4);
                this.addAttribute("skinIndex", d.copyVector4sArray(t.skinIndices))
            }
            if (t.skinWeights.length > 0) {
                var v = new En(4 * t.skinWeights.length, 4);
                this.addAttribute("skinWeight", v.copyVector4sArray(t.skinWeights))
            }
            return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new Je);
            var t = this.attributes.position;
            void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        },
        computeBoundingSphere: function() {
            var t = new Je,
                e = new Ge;
            return function() {
                null === this.boundingSphere && (this.boundingSphere = new Qe);
                var n = this.attributes.position;
                if (n) {
                    var r = this.boundingSphere.center;
                    t.setFromBufferAttribute(n), t.getCenter(r);
                    for (var i = 0, o = 0, a = n.count; o < a; o++) e.x = n.getX(o), e.y = n.getY(o), e.z = n.getZ(o), i = Math.max(i, r.distanceToSquared(e));
                    this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
        }(),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var t = this.index,
                e = this.attributes;
            if (e.position) {
                var n = e.position.array;
                if (void 0 === e.normal) this.addAttribute("normal", new gn(new Float32Array(n.length), 3));
                else
                    for (var r = e.normal.array, i = 0, o = r.length; i < o; i++) r[i] = 0;
                var a, s, c, u = e.normal.array,
                    l = new Ge,
                    h = new Ge,
                    f = new Ge,
                    d = new Ge,
                    v = new Ge;
                if (t) {
                    var p = t.array;
                    for (i = 0, o = t.count; i < o; i += 3) a = 3 * p[i + 0], s = 3 * p[i + 1], c = 3 * p[i + 2], l.fromArray(n, a), h.fromArray(n, s), f.fromArray(n, c), d.subVectors(f, h), v.subVectors(l, h), d.cross(v), u[a] += d.x, u[a + 1] += d.y, u[a + 2] += d.z, u[s] += d.x, u[s + 1] += d.y, u[s + 2] += d.z, u[c] += d.x, u[c + 1] += d.y, u[c + 2] += d.z
                } else
                    for (i = 0, o = n.length; i < o; i += 9) l.fromArray(n, i), h.fromArray(n, i + 3), f.fromArray(n, i + 6), d.subVectors(f, h), v.subVectors(l, h), d.cross(v), u[i] = d.x, u[i + 1] = d.y, u[i + 2] = d.z, u[i + 3] = d.x, u[i + 4] = d.y, u[i + 5] = d.z, u[i + 6] = d.x, u[i + 7] = d.y, u[i + 8] = d.z;
                this.normalizeNormals(), e.normal.needsUpdate = !0
            }
        },
        merge: function(t, e) {
            if (t && t.isBufferGeometry) {
                void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var n = this.attributes;
                for (var r in n)
                    if (void 0 !== t.attributes[r])
                        for (var i = n[r].array, o = t.attributes[r], a = o.array, s = 0, c = o.itemSize * e; s < a.length; s++, c++) i[c] = a[s];
                return this
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
        },
        normalizeNormals: function() {
            var t = new Ge;
            return function() {
                for (var e = this.attributes.normal, n = 0, r = e.count; n < r; n++) t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.normalize(), e.setXYZ(n, t.x, t.y, t.z)
            }
        }(),
        toNonIndexed: function() {
            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
            var t = new zn,
                e = this.index.array,
                n = this.attributes;
            for (var r in n) {
                for (var i = n[r], o = i.array, a = i.itemSize, s = new o.constructor(e.length * a), c = 0, u = 0, l = 0, h = e.length; l < h; l++) {
                    c = e[l] * a;
                    for (var f = 0; f < a; f++) s[u++] = o[c++]
                }
                t.addAttribute(r, new gn(s, a))
            }
            var d = this.groups;
            for (l = 0, h = d.length; l < h; l++) {
                var v = d[l];
                t.addGroup(v.start, v.count, v.materialIndex)
            }
            return t
        },
        toJSON: function() {
            var t = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                var e = this.parameters;
                for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
                return t
            }
            t.data = {
                attributes: {}
            };
            var r = this.index;
            if (null !== r) {
                var i = Array.prototype.slice.call(r.array);
                t.data.index = {
                    type: r.array.constructor.name,
                    array: i
                }
            }
            var o = this.attributes;
            for (var n in o) {
                var a = o[n];
                i = Array.prototype.slice.call(a.array);
                t.data.attributes[n] = {
                    itemSize: a.itemSize,
                    type: a.array.constructor.name,
                    array: i,
                    normalized: a.normalized
                }
            }
            var s = this.groups;
            s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
            var c = this.boundingSphere;
            return null !== c && (t.data.boundingSphere = {
                center: c.center.toArray(),
                radius: c.radius
            }), t
        },
        clone: function() {
            return (new zn).copy(this)
        },
        copy: function(t) {
            var e, n, r;
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
            var i = t.index;
            null !== i && this.setIndex(i.clone());
            var o = t.attributes;
            for (e in o) {
                var a = o[e];
                this.addAttribute(e, a.clone())
            }
            var s = t.morphAttributes;
            for (e in s) {
                var c = [],
                    u = s[e];
                for (n = 0, r = u.length; n < r; n++) c.push(u[n].clone());
                this.morphAttributes[e] = c
            }
            var l = t.groups;
            for (n = 0, r = l.length; n < r; n++) {
                var h = l[n];
                this.addGroup(h.start, h.count, h.materialIndex)
            }
            var f = t.boundingBox;
            null !== f && (this.boundingBox = f.clone());
            var d = t.boundingSphere;
            return null !== d && (this.boundingSphere = d.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Cn.prototype = Object.create(mn.prototype), Cn.prototype.constructor = Cn, Rn.prototype = Object.create(zn.prototype), Rn.prototype.constructor = Rn, In.prototype = Object.create(mn.prototype), In.prototype.constructor = In, Dn.prototype = Object.create(zn.prototype), Dn.prototype.constructor = Dn;
    var On = 0;

    function Fn() {
        Object.defineProperty(this, "id", {
            value: On++
        }), this.uuid = ke.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = S, this.side = p, this.flatShading = !1, this.vertexColors = b, this.opacity = 1, this.transparent = !1, this.blendSrc = k, this.blendDst = U, this.blendEquation = A, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = q, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.visible = !0, this.userData = {}, this.needsUpdate = !0
    }

    function jn(t) {
        Fn.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
    }

    function kn(t, e) {
        this.origin = void 0 !== t ? t : new Ge, this.direction = void 0 !== e ? e : new Ge
    }

    function Un(t, e, n) {
        this.a = void 0 !== t ? t : new Ge, this.b = void 0 !== e ? e : new Ge, this.c = void 0 !== n ? n : new Ge
    }

    function Bn(t) {
        Fn.call(this), this.type = "MeshBasicMaterial", this.color = new on(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = $, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(t)
    }

    function Nn(t, e) {
        vn.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new zn, this.material = void 0 !== e ? e : new Bn({
            color: 16777215 * Math.random()
        }), this.drawMode = Me, this.updateMorphTargets()
    }

    function Gn(t, e) {
        return Math.abs(e[1]) - Math.abs(t[1])
    }

    function Hn(t, e, n, r, i, o, a, s, c, u) {
        t = void 0 !== t ? t : [], e = void 0 !== e ? e : ct, Ye.call(this, t, e, n, r, i, o, a, s, c, u), this.flipY = !1
    }

    function Vn(t, e, n, r) {
        Ye.call(this, null), this.image = {
            data: t,
            width: e,
            height: n,
            depth: r
        }, this.magFilter = yt, this.minFilter = yt, this.generateMipmaps = !1, this.flipY = !1
    }
    Fn.prototype = Object.assign(Object.create(r.prototype), {
        constructor: Fn,
        isMaterial: !0,
        onBeforeCompile: function() {},
        setValues: function(t) {
            if (void 0 !== t)
                for (var e in t) {
                    var n = t[e];
                    if (void 0 !== n)
                        if ("shading" !== e) {
                            var r = this[e];
                            void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[e] = "overdraw" === e ? Number(n) : n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                        } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n === y;
                    else console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                }
        },
        toJSON: function(t) {
            var e = void 0 === t || "string" == typeof t;
            e && (t = {
                textures: {},
                images: {}
            });
            var n = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };

            function r(t) {
                var e = [];
                for (var n in t) {
                    var r = t[n];
                    delete r.metadata, e.push(r)
                }
                return e
            }
            if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== S && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== p && (n.side = this.side), this.vertexColors !== b && (n.vertexColors = this.vertexColors), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                var i = r(t.textures),
                    o = r(t.images);
                i.length > 0 && (n.textures = i), o.length > 0 && (n.images = o)
            }
            return n
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.overdraw = t.overdraw, this.visible = t.visible, this.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
            var e = t.clippingPlanes,
                n = null;
            if (null !== e) {
                var r = e.length;
                n = new Array(r);
                for (var i = 0; i !== r; ++i) n[i] = e[i].clone()
            }
            return this.clippingPlanes = n, this.shadowSide = t.shadowSide, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), jn.prototype = Object.create(Fn.prototype), jn.prototype.constructor = jn, jn.prototype.isShaderMaterial = !0, jn.prototype.copy = function(t) {
        return Fn.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = nn.clone(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this
    }, jn.prototype.toJSON = function(t) {
        var e = Fn.prototype.toJSON.call(this, t);
        for (var n in e.uniforms = {}, this.uniforms) {
            var r = this.uniforms[n].value;
            r.isTexture ? e.uniforms[n] = {
                type: "t",
                value: r.toJSON(t).uuid
            } : r.isColor ? e.uniforms[n] = {
                type: "c",
                value: r.getHex()
            } : r.isVector2 ? e.uniforms[n] = {
                type: "v2",
                value: r.toArray()
            } : r.isVector3 ? e.uniforms[n] = {
                type: "v3",
                value: r.toArray()
            } : r.isVector4 ? e.uniforms[n] = {
                type: "v4",
                value: r.toArray()
            } : r.isMatrix4 ? e.uniforms[n] = {
                type: "m4",
                value: r.toArray()
            } : e.uniforms[n] = {
                value: r
            }
        }
        return Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e
    }, Object.assign(kn.prototype, {
        set: function(t, e) {
            return this.origin.copy(t), this.direction.copy(e), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.origin.copy(t.origin), this.direction.copy(t.direction), this
        },
        at: function(t, e) {
            return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new Ge), e.copy(this.direction).multiplyScalar(t).add(this.origin)
        },
        lookAt: function(t) {
            return this.direction.copy(t).sub(this.origin).normalize(), this
        },
        recast: function() {
            var t = new Ge;
            return function(e) {
                return this.origin.copy(this.at(e, t)), this
            }
        }(),
        closestPointToPoint: function(t, e) {
            void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new Ge), e.subVectors(t, this.origin);
            var n = e.dot(this.direction);
            return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
        },
        distanceToPoint: function(t) {
            return Math.sqrt(this.distanceSqToPoint(t))
        },
        distanceSqToPoint: function() {
            var t = new Ge;
            return function(e) {
                var n = t.subVectors(e, this.origin).dot(this.direction);
                return n < 0 ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(n).add(this.origin), t.distanceToSquared(e))
            }
        }(),
        distanceSqToSegment: function() {
            var t = new Ge,
                e = new Ge,
                n = new Ge;
            return function(r, i, o, a) {
                t.copy(r).add(i).multiplyScalar(.5), e.copy(i).sub(r).normalize(), n.copy(this.origin).sub(t);
                var s, c, u, l, h = .5 * r.distanceTo(i),
                    f = -this.direction.dot(e),
                    d = n.dot(this.direction),
                    v = -n.dot(e),
                    p = n.lengthSq(),
                    m = Math.abs(1 - f * f);
                if (m > 0)
                    if (c = f * d - v, l = h * m, (s = f * v - d) >= 0)
                        if (c >= -l)
                            if (c <= l) {
                                var g = 1 / m;
                                u = (s *= g) * (s + f * (c *= g) + 2 * d) + c * (f * s + c + 2 * v) + p
                            } else c = h, u = -(s = Math.max(0, -(f * c + d))) * s + c * (c + 2 * v) + p;
                else c = -h, u = -(s = Math.max(0, -(f * c + d))) * s + c * (c + 2 * v) + p;
                else c <= -l ? u = -(s = Math.max(0, -(-f * h + d))) * s + (c = s > 0 ? -h : Math.min(Math.max(-h, -v), h)) * (c + 2 * v) + p : c <= l ? (s = 0, u = (c = Math.min(Math.max(-h, -v), h)) * (c + 2 * v) + p) : u = -(s = Math.max(0, -(f * h + d))) * s + (c = s > 0 ? h : Math.min(Math.max(-h, -v), h)) * (c + 2 * v) + p;
                else c = f > 0 ? -h : h, u = -(s = Math.max(0, -(f * c + d))) * s + c * (c + 2 * v) + p;
                return o && o.copy(this.direction).multiplyScalar(s).add(this.origin), a && a.copy(e).multiplyScalar(c).add(t), u
            }
        }(),
        intersectSphere: function() {
            var t = new Ge;
            return function(e, n) {
                t.subVectors(e.center, this.origin);
                var r = t.dot(this.direction),
                    i = t.dot(t) - r * r,
                    o = e.radius * e.radius;
                if (i > o) return null;
                var a = Math.sqrt(o - i),
                    s = r - a,
                    c = r + a;
                return s < 0 && c < 0 ? null : s < 0 ? this.at(c, n) : this.at(s, n)
            }
        }(),
        intersectsSphere: function(t) {
            return this.distanceSqToPoint(t.center) <= t.radius * t.radius
        },
        distanceToPlane: function(t) {
            var e = t.normal.dot(this.direction);
            if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
            var n = -(this.origin.dot(t.normal) + t.constant) / e;
            return n >= 0 ? n : null
        },
        intersectPlane: function(t, e) {
            var n = this.distanceToPlane(t);
            return null === n ? null : this.at(n, e)
        },
        intersectsPlane: function(t) {
            var e = t.distanceToPoint(this.origin);
            return 0 === e || t.normal.dot(this.direction) * e < 0
        },
        intersectBox: function(t, e) {
            var n, r, i, o, a, s, c = 1 / this.direction.x,
                u = 1 / this.direction.y,
                l = 1 / this.direction.z,
                h = this.origin;
            return c >= 0 ? (n = (t.min.x - h.x) * c, r = (t.max.x - h.x) * c) : (n = (t.max.x - h.x) * c, r = (t.min.x - h.x) * c), u >= 0 ? (i = (t.min.y - h.y) * u, o = (t.max.y - h.y) * u) : (i = (t.max.y - h.y) * u, o = (t.min.y - h.y) * u), n > o || i > r ? null : ((i > n || n != n) && (n = i), (o < r || r != r) && (r = o), l >= 0 ? (a = (t.min.z - h.z) * l, s = (t.max.z - h.z) * l) : (a = (t.max.z - h.z) * l, s = (t.min.z - h.z) * l), n > s || a > r ? null : ((a > n || n != n) && (n = a), (s < r || r != r) && (r = s), r < 0 ? null : this.at(n >= 0 ? n : r, e)))
        },
        intersectsBox: function() {
            var t = new Ge;
            return function(e) {
                return null !== this.intersectBox(e, t)
            }
        }(),
        intersectTriangle: function() {
            var t = new Ge,
                e = new Ge,
                n = new Ge,
                r = new Ge;
            return function(i, o, a, s, c) {
                e.subVectors(o, i), n.subVectors(a, i), r.crossVectors(e, n);
                var u, l = this.direction.dot(r);
                if (l > 0) {
                    if (s) return null;
                    u = 1
                } else {
                    if (!(l < 0)) return null;
                    u = -1, l = -l
                }
                t.subVectors(this.origin, i);
                var h = u * this.direction.dot(n.crossVectors(t, n));
                if (h < 0) return null;
                var f = u * this.direction.dot(e.cross(t));
                if (f < 0) return null;
                if (h + f > l) return null;
                var d = -u * t.dot(r);
                return d < 0 ? null : this.at(d / l, c)
            }
        }(),
        applyMatrix4: function(t) {
            return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
        },
        equals: function(t) {
            return t.origin.equals(this.origin) && t.direction.equals(this.direction)
        }
    }), Object.assign(Un, {
        getNormal: function() {
            var t = new Ge;
            return function(e, n, r, i) {
                void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"), i = new Ge), i.subVectors(r, n), t.subVectors(e, n), i.cross(t);
                var o = i.lengthSq();
                return o > 0 ? i.multiplyScalar(1 / Math.sqrt(o)) : i.set(0, 0, 0)
            }
        }(),
        getBarycoord: function() {
            var t = new Ge,
                e = new Ge,
                n = new Ge;
            return function(r, i, o, a, s) {
                t.subVectors(a, i), e.subVectors(o, i), n.subVectors(r, i);
                var c = t.dot(t),
                    u = t.dot(e),
                    l = t.dot(n),
                    h = e.dot(e),
                    f = e.dot(n),
                    d = c * h - u * u;
                if (void 0 === s && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), s = new Ge), 0 === d) return s.set(-2, -1, -1);
                var v = 1 / d,
                    p = (h * l - u * f) * v,
                    m = (c * f - u * l) * v;
                return s.set(1 - p - m, m, p)
            }
        }(),
        containsPoint: function() {
            var t = new Ge;
            return function(e, n, r, i) {
                return Un.getBarycoord(e, n, r, i, t), t.x >= 0 && t.y >= 0 && t.x + t.y <= 1
            }
        }(),
        getUV: function() {
            var t = new Ge;
            return function(e, n, r, i, o, a, s, c) {
                return this.getBarycoord(e, n, r, i, t), c.set(0, 0), c.addScaledVector(o, t.x), c.addScaledVector(a, t.y), c.addScaledVector(s, t.z), c
            }
        }()
    }), Object.assign(Un.prototype, {
        set: function(t, e, n) {
            return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
        },
        setFromPointsAndIndices: function(t, e, n, r) {
            return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
        },
        getArea: function() {
            var t = new Ge,
                e = new Ge;
            return function() {
                return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), .5 * t.cross(e).length()
            }
        }(),
        getMidpoint: function(t) {
            return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new Ge), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        getNormal: function(t) {
            return Un.getNormal(this.a, this.b, this.c, t)
        },
        getPlane: function(t) {
            return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new Ge), t.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        getBarycoord: function(t, e) {
            return Un.getBarycoord(t, this.a, this.b, this.c, e)
        },
        containsPoint: function(t) {
            return Un.containsPoint(t, this.a, this.b, this.c)
        },
        getUV: function(t, e, n, r, i) {
            return Un.getUV(t, this.a, this.b, this.c, e, n, r, i)
        },
        intersectsBox: function(t) {
            return t.intersectsTriangle(this)
        },
        closestPointToPoint: function() {
            var t = new Ge,
                e = new Ge,
                n = new Ge,
                r = new Ge,
                i = new Ge,
                o = new Ge;
            return function(a, s) {
                void 0 === s && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), s = new Ge);
                var c, u, l = this.a,
                    h = this.b,
                    f = this.c;
                t.subVectors(h, l), e.subVectors(f, l), r.subVectors(a, l);
                var d = t.dot(r),
                    v = e.dot(r);
                if (d <= 0 && v <= 0) return s.copy(l);
                i.subVectors(a, h);
                var p = t.dot(i),
                    m = e.dot(i);
                if (p >= 0 && m <= p) return s.copy(h);
                var g = d * m - p * v;
                if (g <= 0 && d >= 0 && p <= 0) return c = d / (d - p), s.copy(l).addScaledVector(t, c);
                o.subVectors(a, f);
                var y = t.dot(o),
                    x = e.dot(o);
                if (x >= 0 && y <= x) return s.copy(f);
                var b = y * v - d * x;
                if (b <= 0 && v >= 0 && x <= 0) return u = v / (v - x), s.copy(l).addScaledVector(e, u);
                var w = p * x - y * m;
                if (w <= 0 && m - p >= 0 && y - x >= 0) return n.subVectors(f, h), u = (m - p) / (m - p + (y - x)), s.copy(h).addScaledVector(n, u);
                var _ = 1 / (w + b + g);
                return c = b * _, u = g * _, s.copy(l).addScaledVector(t, c).addScaledVector(e, u)
            }
        }(),
        equals: function(t) {
            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
        }
    }), Bn.prototype = Object.create(Fn.prototype), Bn.prototype.constructor = Bn, Bn.prototype.isMeshBasicMaterial = !0, Bn.prototype.copy = function(t) {
        return Fn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
    }, Nn.prototype = Object.assign(Object.create(vn.prototype), {
        constructor: Nn,
        isMesh: !0,
        setDrawMode: function(t) {
            this.drawMode = t
        },
        copy: function(t) {
            return vn.prototype.copy.call(this, t), this.drawMode = t.drawMode, void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this
        },
        updateMorphTargets: function() {
            var t, e, n, r = this.geometry;
            if (r.isBufferGeometry) {
                var i = r.morphAttributes,
                    o = Object.keys(i);
                if (o.length > 0) {
                    var a = i[o[0]];
                    if (void 0 !== a)
                        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = a.length; t < e; t++) n = a[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                }
            } else {
                var s = r.morphTargets;
                if (void 0 !== s && s.length > 0)
                    for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = s.length; t < e; t++) n = s[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
            }
        },
        raycast: function() {
            var t = new Be,
                e = new kn,
                n = new Qe,
                r = new Ge,
                i = new Ge,
                o = new Ge,
                a = new Ge,
                s = new Ge,
                c = new Ge,
                u = new Ue,
                l = new Ue,
                h = new Ue,
                f = new Ge,
                d = new Ge;

            function v(t, e, n, r, i, o, a, s) {
                if (null === (e.side === m ? r.intersectTriangle(a, o, i, !0, s) : r.intersectTriangle(i, o, a, e.side !== g, s))) return null;
                d.copy(s), d.applyMatrix4(t.matrixWorld);
                var c = n.ray.origin.distanceTo(d);
                return c < n.near || c > n.far ? null : {
                    distance: c,
                    point: d.clone(),
                    object: t
                }
            }

            function p(t, e, n, a, s, c, d, p, m) {
                r.fromBufferAttribute(s, d), i.fromBufferAttribute(s, p), o.fromBufferAttribute(s, m);
                var g = v(t, e, n, a, r, i, o, f);
                if (g) {
                    c && (u.fromBufferAttribute(c, d), l.fromBufferAttribute(c, p), h.fromBufferAttribute(c, m), g.uv = Un.getUV(f, r, i, o, u, l, h, new Ue));
                    var y = new ln(d, p, m);
                    Un.getNormal(r, i, o, y.normal), g.face = y
                }
                return g
            }
            return function(d, m) {
                var g, y = this.geometry,
                    x = this.material,
                    b = this.matrixWorld;
                if (void 0 !== x && (null === y.boundingSphere && y.computeBoundingSphere(), n.copy(y.boundingSphere), n.applyMatrix4(b), !1 !== d.ray.intersectsSphere(n) && (t.getInverse(b), e.copy(d.ray).applyMatrix4(t), null === y.boundingBox || !1 !== e.intersectsBox(y.boundingBox))))
                    if (y.isBufferGeometry) {
                        var w, _, M, S, E, T, P, L, A, z = y.index,
                            C = y.attributes.position,
                            R = y.attributes.uv,
                            I = y.groups,
                            D = y.drawRange;
                        if (null !== z)
                            if (Array.isArray(x))
                                for (S = 0, T = I.length; S < T; S++)
                                    for (A = x[(L = I[S]).materialIndex], E = Math.max(L.start, D.start), P = Math.min(L.start + L.count, D.start + D.count); E < P; E += 3) w = z.getX(E), _ = z.getX(E + 1), M = z.getX(E + 2), (g = p(this, A, d, e, C, R, w, _, M)) && (g.faceIndex = Math.floor(E / 3), m.push(g));
                            else
                                for (S = Math.max(0, D.start), T = Math.min(z.count, D.start + D.count); S < T; S += 3) w = z.getX(S), _ = z.getX(S + 1), M = z.getX(S + 2), (g = p(this, x, d, e, C, R, w, _, M)) && (g.faceIndex = Math.floor(S / 3), m.push(g));
                        else if (void 0 !== C)
                            if (Array.isArray(x))
                                for (S = 0, T = I.length; S < T; S++)
                                    for (A = x[(L = I[S]).materialIndex], E = Math.max(L.start, D.start), P = Math.min(L.start + L.count, D.start + D.count); E < P; E += 3)(g = p(this, A, d, e, C, R, w = E, _ = E + 1, M = E + 2)) && (g.faceIndex = Math.floor(E / 3), m.push(g));
                            else
                                for (S = Math.max(0, D.start), T = Math.min(C.count, D.start + D.count); S < T; S += 3)(g = p(this, x, d, e, C, R, w = S, _ = S + 1, M = S + 2)) && (g.faceIndex = Math.floor(S / 3), m.push(g))
                    } else if (y.isGeometry) {
                    var O, F, j, k, U = Array.isArray(x),
                        B = y.vertices,
                        N = y.faces,
                        G = y.faceVertexUvs[0];
                    G.length > 0 && (k = G);
                    for (var H = 0, V = N.length; H < V; H++) {
                        var W = N[H],
                            Y = U ? x[W.materialIndex] : x;
                        if (void 0 !== Y) {
                            if (O = B[W.a], F = B[W.b], j = B[W.c], !0 === Y.morphTargets) {
                                var X = y.morphTargets,
                                    q = this.morphTargetInfluences;
                                r.set(0, 0, 0), i.set(0, 0, 0), o.set(0, 0, 0);
                                for (var K = 0, Z = X.length; K < Z; K++) {
                                    var J = q[K];
                                    if (0 !== J) {
                                        var Q = X[K].vertices;
                                        r.addScaledVector(a.subVectors(Q[W.a], O), J), i.addScaledVector(s.subVectors(Q[W.b], F), J), o.addScaledVector(c.subVectors(Q[W.c], j), J)
                                    }
                                }
                                r.add(O), i.add(F), o.add(j), O = r, F = i, j = o
                            }
                            if (g = v(this, Y, d, e, O, F, j, f)) {
                                if (k && k[H]) {
                                    var $ = k[H];
                                    u.copy($[0]), l.copy($[1]), h.copy($[2]), g.uv = Un.getUV(f, O, F, j, u, l, h, new Ue)
                                }
                                g.face = W, g.faceIndex = H, m.push(g)
                            }
                        }
                    }
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), Hn.prototype = Object.create(Ye.prototype), Hn.prototype.constructor = Hn, Hn.prototype.isCubeTexture = !0, Object.defineProperty(Hn.prototype, "images", {
        get: function() {
            return this.image
        },
        set: function(t) {
            this.image = t
        }
    }), Vn.prototype = Object.create(Ye.prototype), Vn.prototype.constructor = Vn, Vn.prototype.isDataTexture3D = !0;
    var Wn = new Ye,
        Yn = new Vn,
        Xn = new Hn;

    function qn() {
        this.seq = [], this.map = {}
    }
    var Kn = [],
        Zn = [],
        Jn = new Float32Array(16),
        Qn = new Float32Array(9),
        $n = new Float32Array(4);

    function tr(t, e, n) {
        var r = t[0];
        if (r <= 0 || r > 0) return t;
        var i = e * n,
            o = Kn[i];
        if (void 0 === o && (o = new Float32Array(i), Kn[i] = o), 0 !== e) {
            r.toArray(o, 0);
            for (var a = 1, s = 0; a !== e; ++a) s += n, t[a].toArray(o, s)
        }
        return o
    }

    function er(t, e) {
        if (t.length !== e.length) return !1;
        for (var n = 0, r = t.length; n < r; n++)
            if (t[n] !== e[n]) return !1;
        return !0
    }

    function nr(t, e) {
        for (var n = 0, r = e.length; n < r; n++) t[n] = e[n]
    }

    function rr(t, e) {
        var n = Zn[e];
        void 0 === n && (n = new Int32Array(e), Zn[e] = n);
        for (var r = 0; r !== e; ++r) n[r] = t.allocTextureUnit();
        return n
    }

    function ir(t, e) {
        var n = this.cache;
        n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
    }

    function or(t, e) {
        var n = this.cache;
        n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
    }

    function ar(t, e) {
        var n = this.cache;
        if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
        else {
            if (er(n, e)) return;
            t.uniform2fv(this.addr, e), nr(n, e)
        }
    }

    function sr(t, e) {
        var n = this.cache;
        if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
        else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
        else {
            if (er(n, e)) return;
            t.uniform3fv(this.addr, e), nr(n, e)
        }
    }

    function cr(t, e) {
        var n = this.cache;
        if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
        else {
            if (er(n, e)) return;
            t.uniform4fv(this.addr, e), nr(n, e)
        }
    }

    function ur(t, e) {
        var n = this.cache,
            r = e.elements;
        if (void 0 === r) {
            if (er(n, e)) return;
            t.uniformMatrix2fv(this.addr, !1, e), nr(n, e)
        } else {
            if (er(n, r)) return;
            $n.set(r), t.uniformMatrix2fv(this.addr, !1, $n), nr(n, r)
        }
    }

    function lr(t, e) {
        var n = this.cache,
            r = e.elements;
        if (void 0 === r) {
            if (er(n, e)) return;
            t.uniformMatrix3fv(this.addr, !1, e), nr(n, e)
        } else {
            if (er(n, r)) return;
            Qn.set(r), t.uniformMatrix3fv(this.addr, !1, Qn), nr(n, r)
        }
    }

    function hr(t, e) {
        var n = this.cache,
            r = e.elements;
        if (void 0 === r) {
            if (er(n, e)) return;
            t.uniformMatrix4fv(this.addr, !1, e), nr(n, e)
        } else {
            if (er(n, r)) return;
            Jn.set(r), t.uniformMatrix4fv(this.addr, !1, Jn), nr(n, r)
        }
    }

    function fr(t, e, n) {
        var r = this.cache,
            i = n.allocTextureUnit();
        r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture2D(e || Wn, i)
    }

    function dr(t, e, n) {
        var r = this.cache,
            i = n.allocTextureUnit();
        r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(e || Yn, i)
    }

    function vr(t, e, n) {
        var r = this.cache,
            i = n.allocTextureUnit();
        r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTextureCube(e || Xn, i)
    }

    function pr(t, e) {
        var n = this.cache;
        er(n, e) || (t.uniform2iv(this.addr, e), nr(n, e))
    }

    function mr(t, e) {
        var n = this.cache;
        er(n, e) || (t.uniform3iv(this.addr, e), nr(n, e))
    }

    function gr(t, e) {
        var n = this.cache;
        er(n, e) || (t.uniform4iv(this.addr, e), nr(n, e))
    }

    function yr(t, e) {
        var n = this.cache;
        er(n, e) || (t.uniform1fv(this.addr, e), nr(n, e))
    }

    function xr(t, e) {
        var n = this.cache;
        er(n, e) || (t.uniform1iv(this.addr, e), nr(n, e))
    }

    function br(t, e) {
        var n = this.cache,
            r = tr(e, this.size, 2);
        er(n, r) || (t.uniform2fv(this.addr, r), this.updateCache(r))
    }

    function wr(t, e) {
        var n = this.cache,
            r = tr(e, this.size, 3);
        er(n, r) || (t.uniform3fv(this.addr, r), this.updateCache(r))
    }

    function _r(t, e) {
        var n = this.cache,
            r = tr(e, this.size, 4);
        er(n, r) || (t.uniform4fv(this.addr, r), this.updateCache(r))
    }

    function Mr(t, e) {
        var n = this.cache,
            r = tr(e, this.size, 4);
        er(n, r) || (t.uniformMatrix2fv(this.addr, !1, r), this.updateCache(r))
    }

    function Sr(t, e) {
        var n = this.cache,
            r = tr(e, this.size, 9);
        er(n, r) || (t.uniformMatrix3fv(this.addr, !1, r), this.updateCache(r))
    }

    function Er(t, e) {
        var n = this.cache,
            r = tr(e, this.size, 16);
        er(n, r) || (t.uniformMatrix4fv(this.addr, !1, r), this.updateCache(r))
    }

    function Tr(t, e, n) {
        var r = this.cache,
            i = e.length,
            o = rr(n, i);
        !1 === er(r, o) && (t.uniform1iv(this.addr, o), nr(r, o));
        for (var a = 0; a !== i; ++a) n.setTexture2D(e[a] || Wn, o[a])
    }

    function Pr(t, e, n) {
        var r = this.cache,
            i = e.length,
            o = rr(n, i);
        !1 === er(r, o) && (t.uniform1iv(this.addr, o), nr(r, o));
        for (var a = 0; a !== i; ++a) n.setTextureCube(e[a] || Xn, o[a])
    }

    function Lr(t, e, n) {
        this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
            switch (t) {
                case 5126:
                    return ir;
                case 35664:
                    return ar;
                case 35665:
                    return sr;
                case 35666:
                    return cr;
                case 35674:
                    return ur;
                case 35675:
                    return lr;
                case 35676:
                    return hr;
                case 35678:
                case 36198:
                    return fr;
                case 35679:
                    return dr;
                case 35680:
                    return vr;
                case 5124:
                case 35670:
                    return or;
                case 35667:
                case 35671:
                    return pr;
                case 35668:
                case 35672:
                    return mr;
                case 35669:
                case 35673:
                    return gr
            }
        }(e.type)
    }

    function Ar(t, e, n) {
        this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
            switch (t) {
                case 5126:
                    return yr;
                case 35664:
                    return br;
                case 35665:
                    return wr;
                case 35666:
                    return _r;
                case 35674:
                    return Mr;
                case 35675:
                    return Sr;
                case 35676:
                    return Er;
                case 35678:
                    return Tr;
                case 35680:
                    return Pr;
                case 5124:
                case 35670:
                    return xr;
                case 35667:
                case 35671:
                    return pr;
                case 35668:
                case 35672:
                    return mr;
                case 35669:
                case 35673:
                    return gr
            }
        }(e.type)
    }

    function zr(t) {
        this.id = t, qn.call(this)
    }
    Ar.prototype.updateCache = function(t) {
        var e = this.cache;
        t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), nr(e, t)
    }, zr.prototype.setValue = function(t, e, n) {
        for (var r = this.seq, i = 0, o = r.length; i !== o; ++i) {
            var a = r[i];
            a.setValue(t, e[a.id], n)
        }
    };
    var Cr = /([\w\d_]+)(\])?(\[|\.)?/g;

    function Rr(t, e) {
        t.seq.push(e), t.map[e.id] = e
    }

    function Ir(t, e, n) {
        var r = t.name,
            i = r.length;
        for (Cr.lastIndex = 0;;) {
            var o = Cr.exec(r),
                a = Cr.lastIndex,
                s = o[1],
                c = "]" === o[2],
                u = o[3];
            if (c && (s |= 0), void 0 === u || "[" === u && a + 2 === i) {
                Rr(n, void 0 === u ? new Lr(s, t, e) : new Ar(s, t, e));
                break
            }
            var l = n.map[s];
            void 0 === l && Rr(n, l = new zr(s)), n = l
        }
    }

    function Dr(t, e, n) {
        qn.call(this), this.renderer = n;
        for (var r = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), i = 0; i < r; ++i) {
            var o = t.getActiveUniform(e, i);
            Ir(o, t.getUniformLocation(e, o.name), this)
        }
    }

    function Or(t, e, n) {
        var r = t.createShader(e);
        return t.shaderSource(r, n), t.compileShader(r), !1 === t.getShaderParameter(r, t.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(r) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", e === t.VERTEX_SHADER ? "vertex" : "fragment", t.getShaderInfoLog(r), function(t) {
            for (var e = t.split("\n"), n = 0; n < e.length; n++) e[n] = n + 1 + ": " + e[n];
            return e.join("\n")
        }(n)), r
    }
    Dr.prototype.setValue = function(t, e, n) {
        var r = this.map[e];
        void 0 !== r && r.setValue(t, n, this.renderer)
    }, Dr.prototype.setOptional = function(t, e, n) {
        var r = e[n];
        void 0 !== r && this.setValue(t, n, r)
    }, Dr.upload = function(t, e, n, r) {
        for (var i = 0, o = e.length; i !== o; ++i) {
            var a = e[i],
                s = n[a.id];
            !1 !== s.needsUpdate && a.setValue(t, s.value, r)
        }
    }, Dr.seqWithValue = function(t, e) {
        for (var n = [], r = 0, i = t.length; r !== i; ++r) {
            var o = t[r];
            o.id in e && n.push(o)
        }
        return n
    };
    var Fr = 0;

    function jr(t) {
        switch (t) {
            case Te:
                return ["Linear", "( value )"];
            case Pe:
                return ["sRGB", "( value )"];
            case Ae:
                return ["RGBE", "( value )"];
            case Ce:
                return ["RGBM", "( value, 7.0 )"];
            case Re:
                return ["RGBM", "( value, 16.0 )"];
            case Ie:
                return ["RGBD", "( value, 256.0 )"];
            case Le:
                return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            default:
                throw new Error("unsupported encoding: " + t)
        }
    }

    function kr(t, e) {
        var n = jr(e);
        return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
    }

    function Ur(t) {
        return "" !== t
    }

    function Br(t, e) {
        return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    }

    function Nr(t, e) {
        return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
    }

    function Gr(t) {
        return t.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function(t, e) {
            var n = en[e];
            if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
            return Gr(n)
        })
    }

    function Hr(t) {
        return t.replace(/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(t, e, n, r) {
            for (var i = "", o = parseInt(e); o < parseInt(n); o++) i += r.replace(/\[ i \]/g, "[ " + o + " ]");
            return i
        })
    }

    function Vr(t, e, n, r, i, o, a) {
        var s = t.context,
            c = r.defines,
            u = i.vertexShader,
            l = i.fragmentShader,
            h = "SHADOWMAP_TYPE_BASIC";
        o.shadowMapType === d ? h = "SHADOWMAP_TYPE_PCF" : o.shadowMapType === v && (h = "SHADOWMAP_TYPE_PCF_SOFT");
        var f = "ENVMAP_TYPE_CUBE",
            p = "ENVMAP_MODE_REFLECTION",
            m = "ENVMAP_BLENDING_MULTIPLY";
        if (o.envMap) {
            switch (r.envMap.mapping) {
                case ct:
                case ut:
                    f = "ENVMAP_TYPE_CUBE";
                    break;
                case dt:
                case vt:
                    f = "ENVMAP_TYPE_CUBE_UV";
                    break;
                case lt:
                case ht:
                    f = "ENVMAP_TYPE_EQUIREC";
                    break;
                case ft:
                    f = "ENVMAP_TYPE_SPHERE"
            }
            switch (r.envMap.mapping) {
                case ut:
                case ht:
                    p = "ENVMAP_MODE_REFRACTION"
            }
            switch (r.combine) {
                case $:
                    m = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case tt:
                    m = "ENVMAP_BLENDING_MIX";
                    break;
                case et:
                    m = "ENVMAP_BLENDING_ADD"
            }
        }
        var g, y, x = t.gammaFactor > 0 ? t.gammaFactor : 1,
            b = a.isWebGL2 ? "" : function(t, e, n) {
                return [(t = t || {}).derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap && !e.objectSpaceNormalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && n.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && n.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && n.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Ur).join("\n")
            }(r.extensions, o, e),
            w = function(t) {
                var e = [];
                for (var n in t) {
                    var r = t[n];
                    !1 !== r && e.push("#define " + n + " " + r)
                }
                return e.join("\n")
            }(c),
            _ = s.createProgram();
        if (r.isRawShaderMaterial ? ((g = [w].filter(Ur).join("\n")).length > 0 && (g += "\n"), (y = [b, w].filter(Ur).join("\n")).length > 0 && (y += "\n")) : (g = ["precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + i.name, w, o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + x, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + p : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + h : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (a.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Ur).join("\n"), y = [b, "precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + i.name, w, o.alphaTest ? "#define ALPHATEST " + o.alphaTest + (o.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + x, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + f : "", o.envMap ? "#define " + p : "", o.envMap ? "#define " + m : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + h : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (a.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", o.envMap && (a.isWebGL2 || e.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", o.toneMapping !== nt ? "#define TONE_MAPPING" : "", o.toneMapping !== nt ? en.tonemapping_pars_fragment : "", o.toneMapping !== nt ? function(t, e) {
                var n;
                switch (e) {
                    case rt:
                        n = "Linear";
                        break;
                    case it:
                        n = "Reinhard";
                        break;
                    case ot:
                        n = "Uncharted2";
                        break;
                    case at:
                        n = "OptimizedCineon";
                        break;
                    default:
                        throw new Error("unsupported toneMapping: " + e)
                }
                return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
            }("toneMapping", o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.matcapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? en.encodings_pars_fragment : "", o.mapEncoding ? kr("mapTexelToLinear", o.mapEncoding) : "", o.matcapEncoding ? kr("matcapTexelToLinear", o.matcapEncoding) : "", o.envMapEncoding ? kr("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? kr("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? function(t, e) {
                var n = jr(e);
                return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
            }("linearToOutputTexel", o.outputEncoding) : "", o.depthPacking ? "#define DEPTH_PACKING " + r.depthPacking : "", "\n"].filter(Ur).join("\n")), u = Nr(u = Br(u = Gr(u), o), o), l = Nr(l = Br(l = Gr(l), o), o), u = Hr(u), l = Hr(l), a.isWebGL2 && !r.isRawShaderMaterial) {
            var M = !1,
                S = /^\s*#version\s+300\s+es\s*\n/;
            r.isShaderMaterial && null !== u.match(S) && null !== l.match(S) && (M = !0, u = u.replace(S, ""), l = l.replace(S, "")), g = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, y = ["#version 300 es\n", "#define varying in", M ? "" : "out highp vec4 pc_fragColor;", M ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y
        }
        var E = g + u,
            T = y + l,
            P = Or(s, s.VERTEX_SHADER, E),
            L = Or(s, s.FRAGMENT_SHADER, T);
        s.attachShader(_, P), s.attachShader(_, L), void 0 !== r.index0AttributeName ? s.bindAttribLocation(_, 0, r.index0AttributeName) : !0 === o.morphTargets && s.bindAttribLocation(_, 0, "position"), s.linkProgram(_);
        var A, z, C = s.getProgramInfoLog(_).trim(),
            R = s.getShaderInfoLog(P).trim(),
            I = s.getShaderInfoLog(L).trim(),
            D = !0,
            O = !0;
        return !1 === s.getProgramParameter(_, s.LINK_STATUS) ? (D = !1, console.error("THREE.WebGLProgram: shader error: ", s.getError(), "gl.VALIDATE_STATUS", s.getProgramParameter(_, s.VALIDATE_STATUS), "gl.getProgramInfoLog", C, R, I)) : "" !== C ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", C) : "" !== R && "" !== I || (O = !1), O && (this.diagnostics = {
            runnable: D,
            material: r,
            programLog: C,
            vertexShader: {
                log: R,
                prefix: g
            },
            fragmentShader: {
                log: I,
                prefix: y
            }
        }), s.deleteShader(P), s.deleteShader(L), this.getUniforms = function() {
            return void 0 === A && (A = new Dr(s, _, t)), A
        }, this.getAttributes = function() {
            return void 0 === z && (z = function(t, e) {
                for (var n = {}, r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), i = 0; i < r; i++) {
                    var o = t.getActiveAttrib(e, i).name;
                    n[o] = t.getAttribLocation(e, o)
                }
                return n
            }(s, _)), z
        }, this.destroy = function() {
            s.deleteProgram(_), this.program = void 0
        }, Object.defineProperties(this, {
            uniforms: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                }
            },
            attributes: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                }
            }
        }), this.name = i.name, this.id = Fr++, this.code = n, this.usedTimes = 1, this.program = _, this.vertexShader = P, this.fragmentShader = L, this
    }

    function Wr(t, e, n) {
        var r = [],
            i = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "phong",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            },
            o = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];

        function a(t, e) {
            var n;
            return t ? t.isTexture ? n = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), n = t.texture.encoding) : n = Te, n === Te && e && (n = Le), n
        }
        this.getParameters = function(e, r, o, s, c, u, l) {
            var h = i[e.type],
                f = l.isSkinnedMesh ? function(t) {
                    var e = t.skeleton.bones;
                    if (n.floatVertexTextures) return 1024;
                    var r = n.maxVertexUniforms,
                        i = Math.floor((r - 20) / 4),
                        o = Math.min(i, e.length);
                    return o < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + o + "."), 0) : o
                }(l) : 0,
                d = n.precision;
            null !== e.precision && (d = n.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", d, "instead.");
            var v = t.getRenderTarget();
            return {
                shaderID: h,
                precision: d,
                supportsVertexTextures: n.vertexTextures,
                outputEncoding: a(v ? v.texture : null, t.gammaOutput),
                map: !!e.map,
                mapEncoding: a(e.map, t.gammaInput),
                matcap: !!e.matcap,
                matcapEncoding: a(e.matcap, t.gammaInput),
                envMap: !!e.envMap,
                envMapMode: e.envMap && e.envMap.mapping,
                envMapEncoding: a(e.envMap, t.gammaInput),
                envMapCubeUV: !!e.envMap && (e.envMap.mapping === dt || e.envMap.mapping === vt),
                lightMap: !!e.lightMap,
                aoMap: !!e.aoMap,
                emissiveMap: !!e.emissiveMap,
                emissiveMapEncoding: a(e.emissiveMap, t.gammaInput),
                bumpMap: !!e.bumpMap,
                normalMap: !!e.normalMap,
                objectSpaceNormalMap: e.normalMapType === je,
                displacementMap: !!e.displacementMap,
                roughnessMap: !!e.roughnessMap,
                metalnessMap: !!e.metalnessMap,
                specularMap: !!e.specularMap,
                alphaMap: !!e.alphaMap,
                gradientMap: !!e.gradientMap,
                combine: e.combine,
                vertexColors: e.vertexColors,
                fog: !!s,
                useFog: e.fog,
                fogExp: s && s.isFogExp2,
                flatShading: e.flatShading,
                sizeAttenuation: e.sizeAttenuation,
                logarithmicDepthBuffer: n.logarithmicDepthBuffer,
                skinning: e.skinning && f > 0,
                maxBones: f,
                useVertexTexture: n.floatVertexTextures,
                morphTargets: e.morphTargets,
                morphNormals: e.morphNormals,
                maxMorphTargets: t.maxMorphTargets,
                maxMorphNormals: t.maxMorphNormals,
                numDirLights: r.directional.length,
                numPointLights: r.point.length,
                numSpotLights: r.spot.length,
                numRectAreaLights: r.rectArea.length,
                numHemiLights: r.hemi.length,
                numClippingPlanes: c,
                numClipIntersection: u,
                dithering: e.dithering,
                shadowMapEnabled: t.shadowMap.enabled && l.receiveShadow && o.length > 0,
                shadowMapType: t.shadowMap.type,
                toneMapping: t.toneMapping,
                physicallyCorrectLights: t.physicallyCorrectLights,
                premultipliedAlpha: e.premultipliedAlpha,
                alphaTest: e.alphaTest,
                doubleSided: e.side === g,
                flipSided: e.side === m,
                depthPacking: void 0 !== e.depthPacking && e.depthPacking
            }
        }, this.getProgramCode = function(e, n) {
            var r = [];
            if (n.shaderID ? r.push(n.shaderID) : (r.push(e.fragmentShader), r.push(e.vertexShader)), void 0 !== e.defines)
                for (var i in e.defines) r.push(i), r.push(e.defines[i]);
            for (var a = 0; a < o.length; a++) r.push(n[o[a]]);
            return r.push(e.onBeforeCompile.toString()), r.push(t.gammaOutput), r.join()
        }, this.acquireProgram = function(i, o, a, s) {
            for (var c, u = 0, l = r.length; u < l; u++) {
                var h = r[u];
                if (h.code === s) {
                    ++(c = h).usedTimes;
                    break
                }
            }
            return void 0 === c && (c = new Vr(t, e, s, i, o, a, n), r.push(c)), c
        }, this.releaseProgram = function(t) {
            if (0 == --t.usedTimes) {
                var e = r.indexOf(t);
                r[e] = r[r.length - 1], r.pop(), t.destroy()
            }
        }, this.programs = r
    }

    function Yr(t, e) {
        return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program && t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
    }

    function Xr(t, e) {
        return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
    }

    function qr() {
        var t = {};
        return {
            get: function(e, n) {
                var r = e.id + "," + n.id,
                    i = t[r];
                return void 0 === i && (i = new function() {
                    var t = [],
                        e = 0,
                        n = [],
                        r = [];
                    return {
                        opaque: n,
                        transparent: r,
                        init: function() {
                            e = 0, n.length = 0, r.length = 0
                        },
                        push: function(i, o, a, s, c) {
                            var u = t[e];
                            void 0 === u ? (u = {
                                id: i.id,
                                object: i,
                                geometry: o,
                                material: a,
                                program: a.program,
                                renderOrder: i.renderOrder,
                                z: s,
                                group: c
                            }, t[e] = u) : (u.id = i.id, u.object = i, u.geometry = o, u.material = a, u.program = a.program, u.renderOrder = i.renderOrder, u.z = s, u.group = c), (!0 === a.transparent ? r : n).push(u), e++
                        },
                        sort: function() {
                            n.length > 1 && n.sort(Yr), r.length > 1 && r.sort(Xr)
                        }
                    }
                }, t[r] = i), i
            },
            dispose: function() {
                t = {}
            }
        }
    }
    var Kr, Zr = 0;

    function Jr() {
        var t = new function() {
                var t = {};
                return {
                    get: function(e) {
                        if (void 0 !== t[e.id]) return t[e.id];
                        var n;
                        switch (e.type) {
                            case "DirectionalLight":
                                n = {
                                    direction: new Ge,
                                    color: new on,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Ue
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    position: new Ge,
                                    direction: new Ge,
                                    color: new on,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Ue
                                };
                                break;
                            case "PointLight":
                                n = {
                                    position: new Ge,
                                    color: new on,
                                    distance: 0,
                                    decay: 0,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new Ue,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                };
                                break;
                            case "HemisphereLight":
                                n = {
                                    direction: new Ge,
                                    skyColor: new on,
                                    groundColor: new on
                                };
                                break;
                            case "RectAreaLight":
                                n = {
                                    color: new on,
                                    position: new Ge,
                                    halfWidth: new Ge,
                                    halfHeight: new Ge
                                }
                        }
                        return t[e.id] = n, n
                    }
                }
            },
            e = {
                id: Zr++,
                hash: {
                    stateID: -1,
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    shadowsLength: -1
                },
                ambient: [0, 0, 0],
                directional: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                point: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: []
            },
            n = new Ge,
            r = new Be,
            i = new Be;
        return {
            setup: function(o, a, s) {
                for (var c = 0, u = 0, l = 0, h = 0, f = 0, d = 0, v = 0, p = 0, m = s.matrixWorldInverse, g = 0, y = o.length; g < y; g++) {
                    var x = o[g],
                        b = x.color,
                        w = x.intensity,
                        _ = x.distance,
                        M = x.shadow && x.shadow.map ? x.shadow.map.texture : null;
                    if (x.isAmbientLight) c += b.r * w, u += b.g * w, l += b.b * w;
                    else if (x.isDirectionalLight) {
                        if ((E = t.get(x)).color.copy(x.color).multiplyScalar(x.intensity), E.direction.setFromMatrixPosition(x.matrixWorld), n.setFromMatrixPosition(x.target.matrixWorld), E.direction.sub(n), E.direction.transformDirection(m), E.shadow = x.castShadow, x.castShadow) {
                            var S = x.shadow;
                            E.shadowBias = S.bias, E.shadowRadius = S.radius, E.shadowMapSize = S.mapSize
                        }
                        e.directionalShadowMap[h] = M, e.directionalShadowMatrix[h] = x.shadow.matrix, e.directional[h] = E, h++
                    } else if (x.isSpotLight)(E = t.get(x)).position.setFromMatrixPosition(x.matrixWorld), E.position.applyMatrix4(m), E.color.copy(b).multiplyScalar(w), E.distance = _, E.direction.setFromMatrixPosition(x.matrixWorld), n.setFromMatrixPosition(x.target.matrixWorld), E.direction.sub(n), E.direction.transformDirection(m), E.coneCos = Math.cos(x.angle), E.penumbraCos = Math.cos(x.angle * (1 - x.penumbra)), E.decay = x.decay, E.shadow = x.castShadow, x.castShadow && (S = x.shadow, E.shadowBias = S.bias, E.shadowRadius = S.radius, E.shadowMapSize = S.mapSize), e.spotShadowMap[d] = M, e.spotShadowMatrix[d] = x.shadow.matrix, e.spot[d] = E, d++;
                    else if (x.isRectAreaLight)(E = t.get(x)).color.copy(b).multiplyScalar(w), E.position.setFromMatrixPosition(x.matrixWorld), E.position.applyMatrix4(m), i.identity(), r.copy(x.matrixWorld), r.premultiply(m), i.extractRotation(r), E.halfWidth.set(.5 * x.width, 0, 0), E.halfHeight.set(0, .5 * x.height, 0), E.halfWidth.applyMatrix4(i), E.halfHeight.applyMatrix4(i), e.rectArea[v] = E, v++;
                    else if (x.isPointLight)(E = t.get(x)).position.setFromMatrixPosition(x.matrixWorld), E.position.applyMatrix4(m), E.color.copy(x.color).multiplyScalar(x.intensity), E.distance = x.distance, E.decay = x.decay, E.shadow = x.castShadow, x.castShadow && (S = x.shadow, E.shadowBias = S.bias, E.shadowRadius = S.radius, E.shadowMapSize = S.mapSize, E.shadowCameraNear = S.camera.near, E.shadowCameraFar = S.camera.far), e.pointShadowMap[f] = M, e.pointShadowMatrix[f] = x.shadow.matrix, e.point[f] = E, f++;
                    else if (x.isHemisphereLight) {
                        var E;
                        (E = t.get(x)).direction.setFromMatrixPosition(x.matrixWorld), E.direction.transformDirection(m), E.direction.normalize(), E.skyColor.copy(x.color).multiplyScalar(w), E.groundColor.copy(x.groundColor).multiplyScalar(w), e.hemi[p] = E, p++
                    }
                }
                e.ambient[0] = c, e.ambient[1] = u, e.ambient[2] = l, e.directional.length = h, e.spot.length = d, e.rectArea.length = v, e.point.length = f, e.hemi.length = p, e.hash.stateID = e.id, e.hash.directionalLength = h, e.hash.pointLength = f, e.hash.spotLength = d, e.hash.rectAreaLength = v, e.hash.hemiLength = p, e.hash.shadowsLength = a.length
            },
            state: e
        }
    }

    function Qr() {
        var t = new Jr,
            e = [],
            n = [];
        return {
            init: function() {
                e.length = 0, n.length = 0
            },
            state: {
                lightsArray: e,
                shadowsArray: n,
                lights: t
            },
            setupLights: function(r) {
                t.setup(e, n, r)
            },
            pushLight: function(t) {
                e.push(t)
            },
            pushShadow: function(t) {
                n.push(t)
            }
        }
    }

    function $r(t) {
        Fn.call(this), this.type = "MeshDepthMaterial", this.depthPacking = De, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(t)
    }

    function ti(t) {
        Fn.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Ge, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(t)
    }

    function ei(t, e, n) {
        for (var r = new tn, i = new Be, o = new Ue, a = new Ue(n, n), s = new Ge, c = new Ge, u = 1, l = 2, h = 1 + (u | l), f = new Array(h), v = new Array(h), y = {}, x = {
                0: m,
                1: p,
                2: g
            }, b = [new Ge(1, 0, 0), new Ge(-1, 0, 0), new Ge(0, 0, 1), new Ge(0, 0, -1), new Ge(0, 1, 0), new Ge(0, -1, 0)], w = [new Ge(0, 1, 0), new Ge(0, 1, 0), new Ge(0, 1, 0), new Ge(0, 1, 0), new Ge(0, 0, 1), new Ge(0, 0, -1)], _ = [new Xe, new Xe, new Xe, new Xe, new Xe, new Xe], M = 0; M !== h; ++M) {
            var S = 0 != (M & u),
                E = 0 != (M & l),
                T = new $r({
                    depthPacking: Oe,
                    morphTargets: S,
                    skinning: E
                });
            f[M] = T;
            var P = new ti({
                morphTargets: S,
                skinning: E
            });
            v[M] = P
        }
        var L = this;

        function A(e, n, r, i, o, a) {
            var s = e.geometry,
                c = null,
                h = f,
                d = e.customDepthMaterial;
            if (r && (h = v, d = e.customDistanceMaterial), d) c = d;
            else {
                var p = !1;
                n.morphTargets && (s && s.isBufferGeometry ? p = s.morphAttributes && s.morphAttributes.position && s.morphAttributes.position.length > 0 : s && s.isGeometry && (p = s.morphTargets && s.morphTargets.length > 0)), e.isSkinnedMesh && !1 === n.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e);
                var m = e.isSkinnedMesh && n.skinning,
                    g = 0;
                p && (g |= u), m && (g |= l), c = h[g]
            }
            if (t.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length) {
                var b = c.uuid,
                    w = n.uuid,
                    _ = y[b];
                void 0 === _ && (_ = {}, y[b] = _);
                var M = _[w];
                void 0 === M && (M = c.clone(), _[w] = M), c = M
            }
            return c.visible = n.visible, c.wireframe = n.wireframe, c.side = null != n.shadowSide ? n.shadowSide : x[n.side], c.clipShadows = n.clipShadows, c.clippingPlanes = n.clippingPlanes, c.clipIntersection = n.clipIntersection, c.wireframeLinewidth = n.wireframeLinewidth, c.linewidth = n.linewidth, r && c.isMeshDistanceMaterial && (c.referencePosition.copy(i), c.nearDistance = o, c.farDistance = a), c
        }

        function z(n, i, o, a) {
            if (!1 !== n.visible) {
                if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && n.castShadow && (!n.frustumCulled || r.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                    var s = e.update(n),
                        u = n.material;
                    if (Array.isArray(u))
                        for (var l = s.groups, h = 0, f = l.length; h < f; h++) {
                            var d = l[h],
                                v = u[d.materialIndex];
                            if (v && v.visible) {
                                var p = A(n, v, a, c, o.near, o.far);
                                t.renderBufferDirect(o, null, s, p, n, d)
                            }
                        } else if (u.visible) {
                            p = A(n, u, a, c, o.near, o.far);
                            t.renderBufferDirect(o, null, s, p, n, null)
                        }
                }
                for (var m = n.children, g = 0, y = m.length; g < y; g++) z(m[g], i, o, a)
            }
        }
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = d, this.render = function(e, n, u) {
            if (!1 !== L.enabled && (!1 !== L.autoUpdate || !1 !== L.needsUpdate) && 0 !== e.length) {
                var l, h = t.context,
                    f = t.state;
                f.disable(h.BLEND), f.buffers.color.setClear(1, 1, 1, 1), f.buffers.depth.setTest(!0), f.setScissorTest(!1);
                for (var d = 0, v = e.length; d < v; d++) {
                    var p = e[d],
                        m = p.shadow,
                        g = p && p.isPointLight;
                    if (void 0 !== m) {
                        var y = m.camera;
                        if (o.copy(m.mapSize), o.min(a), g) {
                            var x = o.x,
                                M = o.y;
                            _[0].set(2 * x, M, x, M), _[1].set(0, M, x, M), _[2].set(3 * x, M, x, M), _[3].set(x, M, x, M), _[4].set(3 * x, 0, x, M), _[5].set(x, 0, x, M), o.x *= 4, o.y *= 2
                        }
                        if (null === m.map) {
                            var S = {
                                minFilter: yt,
                                magFilter: yt,
                                format: kt
                            };
                            m.map = new qe(o.x, o.y, S), m.map.texture.name = p.name + ".shadowMap", y.updateProjectionMatrix()
                        }
                        m.isSpotLightShadow && m.update(p);
                        var E = m.map,
                            T = m.matrix;
                        c.setFromMatrixPosition(p.matrixWorld), y.position.copy(c), g ? (l = 6, T.makeTranslation(-c.x, -c.y, -c.z)) : (l = 1, s.setFromMatrixPosition(p.target.matrixWorld), y.lookAt(s), y.updateMatrixWorld(), T.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), T.multiply(y.projectionMatrix), T.multiply(y.matrixWorldInverse)), t.setRenderTarget(E), t.clear();
                        for (var P = 0; P < l; P++) {
                            if (g) {
                                s.copy(y.position), s.add(b[P]), y.up.copy(w[P]), y.lookAt(s), y.updateMatrixWorld();
                                var A = _[P];
                                f.viewport(A)
                            }
                            i.multiplyMatrices(y.projectionMatrix, y.matrixWorldInverse), r.setFromMatrix(i), z(n, u, y, g)
                        }
                    } else console.warn("THREE.WebGLShadowMap:", p, "has no shadow.")
                }
                L.needsUpdate = !1
            }
        }
    }

    function ni(t, e, n, r, i, o, a) {
        var s, c = {};

        function u(t, e) {
            if (t.width > e || t.height > e) {
                if ("data" in t) return void console.warn("THREE.WebGLRenderer: image in DataTexture is too big (" + t.width + "x" + t.height + ").");
                var n = e / Math.max(t.width, t.height),
                    r = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                return r.width = Math.floor(t.width * n), r.height = Math.floor(t.height * n), r.getContext("2d").drawImage(t, 0, 0, t.width, t.height, 0, 0, r.width, r.height), console.warn("THREE.WebGLRenderer: image is too big (" + t.width + "x" + t.height + "). Resized to " + r.width + "x" + r.height), r
            }
            return t
        }

        function l(t) {
            return ke.isPowerOfTwo(t.width) && ke.isPowerOfTwo(t.height)
        }

        function h(t, e) {
            return t.generateMipmaps && e && t.minFilter !== yt && t.minFilter !== wt
        }

        function f(e, n, i, o) {
            t.generateMipmap(e), r.get(n).__maxMipLevel = Math.log(Math.max(i, o)) * Math.LOG2E
        }

        function d(e, n) {
            if (!i.isWebGL2) return e;
            if (e === t.RED) {
                if (n === t.FLOAT) return t.R32F;
                if (n === t.HALF_FLOAT) return t.R16F;
                if (n === t.UNSIGNED_BYTE) return t.R8
            }
            if (e === t.RGB) {
                if (n === t.FLOAT) return t.RGB32F;
                if (n === t.HALF_FLOAT) return t.RGB16F;
                if (n === t.UNSIGNED_BYTE) return t.RGB8
            }
            if (e === t.RGBA) {
                if (n === t.FLOAT) return t.RGBA32F;
                if (n === t.HALF_FLOAT) return t.RGBA16F;
                if (n === t.UNSIGNED_BYTE) return t.RGBA8
            }
            return e
        }

        function v(e) {
            return e === yt || e === xt || e === bt ? t.NEAREST : t.LINEAR
        }

        function p(e) {
            var n = e.target;
            n.removeEventListener("dispose", p),
                function(e) {
                    var n = r.get(e);
                    if (e.image && n.__image__webglTextureCube) t.deleteTexture(n.__image__webglTextureCube);
                    else {
                        if (void 0 === n.__webglInit) return;
                        t.deleteTexture(n.__webglTexture)
                    }
                    r.remove(e)
                }(n), n.isVideoTexture && delete c[n.id], a.memory.textures--
        }

        function m(e) {
            var n = e.target;
            n.removeEventListener("dispose", m),
                function(e) {
                    var n = r.get(e),
                        i = r.get(e.texture);
                    if (!e) return;
                    void 0 !== i.__webglTexture && t.deleteTexture(i.__webglTexture);
                    e.depthTexture && e.depthTexture.dispose();
                    if (e.isWebGLRenderTargetCube)
                        for (var o = 0; o < 6; o++) t.deleteFramebuffer(n.__webglFramebuffer[o]), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[o]);
                    else t.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer);
                    r.remove(e.texture), r.remove(e)
                }(n), a.memory.textures--
        }

        function g(e, i) {
            var o = r.get(e);
            if (e.isVideoTexture && function(t) {
                    var e = t.id,
                        n = a.render.frame;
                    c[e] !== n && (c[e] = n, t.update())
                }(e), e.version > 0 && o.__version !== e.version) {
                var s = e.image;
                if (void 0 === s) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                else {
                    if (!1 !== s.complete) return void x(o, e, i);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                }
            }
            n.activeTexture(t.TEXTURE0 + i), n.bindTexture(t.TEXTURE_2D, o.__webglTexture)
        }

        function y(n, a, s) {
            var c;
            if (s ? (t.texParameteri(n, t.TEXTURE_WRAP_S, o.convert(a.wrapS)), t.texParameteri(n, t.TEXTURE_WRAP_T, o.convert(a.wrapT)), t.texParameteri(n, t.TEXTURE_MAG_FILTER, o.convert(a.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, o.convert(a.minFilter))) : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), a.wrapS === mt && a.wrapT === mt || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, t.TEXTURE_MAG_FILTER, v(a.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, v(a.minFilter)), a.minFilter !== yt && a.minFilter !== wt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), c = e.get("EXT_texture_filter_anisotropic")) {
                if (a.type === zt && null === e.get("OES_texture_float_linear")) return;
                if (a.type === Ct && null === (i.isWebGL2 || e.get("OES_texture_half_float_linear"))) return;
                (a.anisotropy > 1 || r.get(a).__currentAnisotropy) && (t.texParameterf(n, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, i.getMaxAnisotropy())), r.get(a).__currentAnisotropy = a.anisotropy)
            }
        }

        function x(e, r, c) {
            var v;
            v = r.isDataTexture3D ? t.TEXTURE_3D : t.TEXTURE_2D, void 0 === e.__webglInit && (e.__webglInit = !0, r.addEventListener("dispose", p), e.__webglTexture = t.createTexture(), a.memory.textures++), n.activeTexture(t.TEXTURE0 + c), n.bindTexture(v, e.__webglTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, r.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, r.unpackAlignment);
            var m = u(r.image, i.maxTextureSize);
            (function(t) {
                return !i.isWebGL2 && (t.wrapS !== mt || t.wrapT !== mt || t.minFilter !== yt && t.minFilter !== wt)
            })(r) && !1 === l(m) && (m = function(t) {
                return t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof ImageBitmap ? (void 0 === s && (s = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), s.width = ke.floorPowerOfTwo(t.width), s.height = ke.floorPowerOfTwo(t.height), s.getContext("2d").drawImage(t, 0, 0, s.width, s.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + t.width + "x" + t.height + "). Resized to " + s.width + "x" + s.height), s) : t
            }(m));
            var g = l(m),
                x = o.convert(r.format),
                b = o.convert(r.type),
                w = d(x, b);
            y(v, r, g);
            var _, M = r.mipmaps;
            if (r.isDepthTexture) {
                if (w = t.DEPTH_COMPONENT, r.type === zt) {
                    if (!i.isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
                    w = t.DEPTH_COMPONENT32F
                } else i.isWebGL2 && (w = t.DEPTH_COMPONENT16);
                r.format === Gt && w === t.DEPTH_COMPONENT && r.type !== Pt && r.type !== At && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = Pt, b = o.convert(r.type)), r.format === Ht && (w = t.DEPTH_STENCIL, r.type !== Ot && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = Ot, b = o.convert(r.type))), n.texImage2D(t.TEXTURE_2D, 0, w, m.width, m.height, 0, x, b, null)
            } else if (r.isDataTexture)
                if (M.length > 0 && g) {
                    for (var S = 0, E = M.length; S < E; S++) _ = M[S], n.texImage2D(t.TEXTURE_2D, S, w, _.width, _.height, 0, x, b, _.data);
                    r.generateMipmaps = !1, e.__maxMipLevel = M.length - 1
                } else n.texImage2D(t.TEXTURE_2D, 0, w, m.width, m.height, 0, x, b, m.data), e.__maxMipLevel = 0;
            else if (r.isCompressedTexture) {
                for (S = 0, E = M.length; S < E; S++) _ = M[S], r.format !== kt && r.format !== jt ? n.getCompressedTextureFormats().indexOf(x) > -1 ? n.compressedTexImage2D(t.TEXTURE_2D, S, w, _.width, _.height, 0, _.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(t.TEXTURE_2D, S, w, _.width, _.height, 0, x, b, _.data);
                e.__maxMipLevel = M.length - 1
            } else if (r.isDataTexture3D) n.texImage3D(t.TEXTURE_3D, 0, w, m.width, m.height, m.depth, 0, x, b, m.data), e.__maxMipLevel = 0;
            else if (M.length > 0 && g) {
                for (S = 0, E = M.length; S < E; S++) _ = M[S], n.texImage2D(t.TEXTURE_2D, S, w, x, b, _);
                r.generateMipmaps = !1, e.__maxMipLevel = M.length - 1
            } else n.texImage2D(t.TEXTURE_2D, 0, w, x, b, m), e.__maxMipLevel = 0;
            h(r, g) && f(t.TEXTURE_2D, r, m.width, m.height), e.__version = r.version, r.onUpdate && r.onUpdate(r)
        }

        function b(e, i, a, s) {
            var c = o.convert(i.texture.format),
                u = o.convert(i.texture.type),
                l = d(c, u);
            n.texImage2D(s, 0, l, i.width, i.height, 0, c, u, null), t.bindFramebuffer(t.FRAMEBUFFER, e), t.framebufferTexture2D(t.FRAMEBUFFER, a, s, r.get(i.texture).__webglTexture, 0), t.bindFramebuffer(t.FRAMEBUFFER, null)
        }

        function w(e, n) {
            t.bindRenderbuffer(t.RENDERBUFFER, e), n.depthBuffer && !n.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_COMPONENT16, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)) : n.depthBuffer && n.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)) : t.renderbufferStorage(t.RENDERBUFFER, t.RGBA4, n.width, n.height), t.bindRenderbuffer(t.RENDERBUFFER, null)
        }

        function _(e) {
            var n = r.get(e),
                i = !0 === e.isWebGLRenderTargetCube;
            if (e.depthTexture) {
                if (i) throw new Error("target.depthTexture not supported in Cube render targets");
                ! function(e, n) {
                    if (n && n.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
                    if (t.bindFramebuffer(t.FRAMEBUFFER, e), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    r.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), g(n.depthTexture, 0);
                    var i = r.get(n.depthTexture).__webglTexture;
                    if (n.depthTexture.format === Gt) t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, i, 0);
                    else {
                        if (n.depthTexture.format !== Ht) throw new Error("Unknown depthTexture format");
                        t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, i, 0)
                    }
                }(n.__webglFramebuffer, e)
            } else if (i) {
                n.__webglDepthbuffer = [];
                for (var o = 0; o < 6; o++) t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer[o]), n.__webglDepthbuffer[o] = t.createRenderbuffer(), w(n.__webglDepthbuffer[o], e)
            } else t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer), n.__webglDepthbuffer = t.createRenderbuffer(), w(n.__webglDepthbuffer, e);
            t.bindFramebuffer(t.FRAMEBUFFER, null)
        }
        this.setTexture2D = g, this.setTexture3D = function(e, i) {
            var o = r.get(e);
            e.version > 0 && o.__version !== e.version ? x(o, e, i) : (n.activeTexture(t.TEXTURE0 + i), n.bindTexture(t.TEXTURE_3D, o.__webglTexture))
        }, this.setTextureCube = function(e, s) {
            var c = r.get(e);
            if (6 === e.image.length)
                if (e.version > 0 && c.__version !== e.version) {
                    c.__image__webglTextureCube || (e.addEventListener("dispose", p), c.__image__webglTextureCube = t.createTexture(), a.memory.textures++), n.activeTexture(t.TEXTURE0 + s), n.bindTexture(t.TEXTURE_CUBE_MAP, c.__image__webglTextureCube), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY);
                    for (var v = e && e.isCompressedTexture, m = e.image[0] && e.image[0].isDataTexture, g = [], x = 0; x < 6; x++) g[x] = v || m ? m ? e.image[x].image : e.image[x] : u(e.image[x], i.maxCubemapSize);
                    var b = g[0],
                        w = l(b),
                        _ = o.convert(e.format),
                        M = o.convert(e.type),
                        S = d(_, M);
                    for (y(t.TEXTURE_CUBE_MAP, e, w), x = 0; x < 6; x++)
                        if (v)
                            for (var E, T = g[x].mipmaps, P = 0, L = T.length; P < L; P++) E = T[P], e.format !== kt && e.format !== jt ? n.getCompressedTextureFormats().indexOf(_) > -1 ? n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + x, P, S, E.width, E.height, 0, E.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + x, P, S, E.width, E.height, 0, _, M, E.data);
                        else m ? n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + x, 0, S, g[x].width, g[x].height, 0, _, M, g[x].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + x, 0, S, _, M, g[x]);
                    c.__maxMipLevel = v ? T.length - 1 : 0, h(e, w) && f(t.TEXTURE_CUBE_MAP, e, b.width, b.height), c.__version = e.version, e.onUpdate && e.onUpdate(e)
                } else n.activeTexture(t.TEXTURE0 + s), n.bindTexture(t.TEXTURE_CUBE_MAP, c.__image__webglTextureCube)
        }, this.setTextureCubeDynamic = function(e, i) {
            n.activeTexture(t.TEXTURE0 + i), n.bindTexture(t.TEXTURE_CUBE_MAP, r.get(e).__webglTexture)
        }, this.setupRenderTarget = function(e) {
            var i = r.get(e),
                o = r.get(e.texture);
            e.addEventListener("dispose", m), o.__webglTexture = t.createTexture(), a.memory.textures++;
            var s = !0 === e.isWebGLRenderTargetCube,
                c = l(e);
            if (s) {
                i.__webglFramebuffer = [];
                for (var u = 0; u < 6; u++) i.__webglFramebuffer[u] = t.createFramebuffer()
            } else i.__webglFramebuffer = t.createFramebuffer();
            if (s) {
                for (n.bindTexture(t.TEXTURE_CUBE_MAP, o.__webglTexture), y(t.TEXTURE_CUBE_MAP, e.texture, c), u = 0; u < 6; u++) b(i.__webglFramebuffer[u], e, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + u);
                h(e.texture, c) && f(t.TEXTURE_CUBE_MAP, e.texture, e.width, e.height), n.bindTexture(t.TEXTURE_CUBE_MAP, null)
            } else n.bindTexture(t.TEXTURE_2D, o.__webglTexture), y(t.TEXTURE_2D, e.texture, c), b(i.__webglFramebuffer, e, t.COLOR_ATTACHMENT0, t.TEXTURE_2D), h(e.texture, c) && f(t.TEXTURE_2D, e.texture, e.width, e.height), n.bindTexture(t.TEXTURE_2D, null);
            e.depthBuffer && _(e)
        }, this.updateRenderTargetMipmap = function(e) {
            var i = e.texture;
            if (h(i, l(e))) {
                var o = e.isWebGLRenderTargetCube ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
                    a = r.get(i).__webglTexture;
                n.bindTexture(o, a), f(o, i, e.width, e.height), n.bindTexture(o, null)
            }
        }
    }

    function ri(t, e, n) {
        return {
            convert: function(r) {
                var i;
                if (r === pt) return t.REPEAT;
                if (r === mt) return t.CLAMP_TO_EDGE;
                if (r === gt) return t.MIRRORED_REPEAT;
                if (r === yt) return t.NEAREST;
                if (r === xt) return t.NEAREST_MIPMAP_NEAREST;
                if (r === bt) return t.NEAREST_MIPMAP_LINEAR;
                if (r === wt) return t.LINEAR;
                if (r === _t) return t.LINEAR_MIPMAP_NEAREST;
                if (r === Mt) return t.LINEAR_MIPMAP_LINEAR;
                if (r === St) return t.UNSIGNED_BYTE;
                if (r === Rt) return t.UNSIGNED_SHORT_4_4_4_4;
                if (r === It) return t.UNSIGNED_SHORT_5_5_5_1;
                if (r === Dt) return t.UNSIGNED_SHORT_5_6_5;
                if (r === Et) return t.BYTE;
                if (r === Tt) return t.SHORT;
                if (r === Pt) return t.UNSIGNED_SHORT;
                if (r === Lt) return t.INT;
                if (r === At) return t.UNSIGNED_INT;
                if (r === zt) return t.FLOAT;
                if (r === Ct) {
                    if (n.isWebGL2) return t.HALF_FLOAT;
                    if (null !== (i = e.get("OES_texture_half_float"))) return i.HALF_FLOAT_OES
                }
                if (r === Ft) return t.ALPHA;
                if (r === jt) return t.RGB;
                if (r === kt) return t.RGBA;
                if (r === Ut) return t.LUMINANCE;
                if (r === Bt) return t.LUMINANCE_ALPHA;
                if (r === Gt) return t.DEPTH_COMPONENT;
                if (r === Ht) return t.DEPTH_STENCIL;
                if (r === Vt) return t.RED;
                if (r === A) return t.FUNC_ADD;
                if (r === z) return t.FUNC_SUBTRACT;
                if (r === C) return t.FUNC_REVERSE_SUBTRACT;
                if (r === D) return t.ZERO;
                if (r === O) return t.ONE;
                if (r === F) return t.SRC_COLOR;
                if (r === j) return t.ONE_MINUS_SRC_COLOR;
                if (r === k) return t.SRC_ALPHA;
                if (r === U) return t.ONE_MINUS_SRC_ALPHA;
                if (r === B) return t.DST_ALPHA;
                if (r === N) return t.ONE_MINUS_DST_ALPHA;
                if (r === G) return t.DST_COLOR;
                if (r === H) return t.ONE_MINUS_DST_COLOR;
                if (r === V) return t.SRC_ALPHA_SATURATE;
                if ((r === Wt || r === Yt || r === Xt || r === qt) && null !== (i = e.get("WEBGL_compressed_texture_s3tc"))) {
                    if (r === Wt) return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (r === Yt) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (r === Xt) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (r === qt) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if ((r === Kt || r === Zt || r === Jt || r === Qt) && null !== (i = e.get("WEBGL_compressed_texture_pvrtc"))) {
                    if (r === Kt) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (r === Zt) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (r === Jt) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (r === Qt) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (r === $t && null !== (i = e.get("WEBGL_compressed_texture_etc1"))) return i.COMPRESSED_RGB_ETC1_WEBGL;
                if ((r === te || r === ee || r === ne || r === re || r === ie || r === oe || r === ae || r === se || r === ce || r === ue || r === le || r === he || r === fe || r === de) && null !== (i = e.get("WEBGL_compressed_texture_astc"))) return r;
                if (r === R || r === I) {
                    if (n.isWebGL2) {
                        if (r === R) return t.MIN;
                        if (r === I) return t.MAX
                    }
                    if (null !== (i = e.get("EXT_blend_minmax"))) {
                        if (r === R) return i.MIN_EXT;
                        if (r === I) return i.MAX_EXT
                    }
                }
                if (r === Ot) {
                    if (n.isWebGL2) return t.UNSIGNED_INT_24_8;
                    if (null !== (i = e.get("WEBGL_depth_texture"))) return i.UNSIGNED_INT_24_8_WEBGL
                }
                return 0
            }
        }
    }

    function ii() {
        vn.call(this), this.type = "Group"
    }

    function oi() {
        vn.call(this), this.type = "Camera", this.matrixWorldInverse = new Be, this.projectionMatrix = new Be, this.projectionMatrixInverse = new Be
    }

    function ai(t, e, n, r) {
        oi.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== r ? r : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }

    function si(t) {
        ai.call(this), this.cameras = t || []
    }

    function ci(t) {
        var e = this,
            n = null,
            r = null,
            i = null,
            o = [],
            a = new Be,
            s = new Be,
            c = "stage";
        "undefined" != typeof window && "VRFrameData" in window && (r = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", y, !1));
        var u = new Be,
            l = new Ne,
            h = new Ge,
            f = new ai;
        f.bounds = new Xe(0, 0, .5, 1), f.layers.enable(1);
        var d = new ai;
        d.bounds = new Xe(.5, 0, .5, 1), d.layers.enable(2);
        var v, p, m = new si([f, d]);

        function g() {
            return null !== n && !0 === n.isPresenting
        }

        function y() {
            if (g()) {
                var r = n.getEyeParameters("left"),
                    i = r.renderWidth,
                    o = r.renderHeight;
                p = t.getPixelRatio(), v = t.getSize(), t.setDrawingBufferSize(2 * i, o, 1), w.start()
            } else e.enabled && t.setDrawingBufferSize(v.width, v.height, p), w.stop()
        }
        m.layers.enable(1), m.layers.enable(2);
        var x = [];

        function b(t) {
            for (var e = navigator.getGamepads && navigator.getGamepads(), n = 0, r = 0, i = e.length; n < i; n++) {
                var o = e[n];
                if (o && ("Daydream Controller" === o.id || "Gear VR Controller" === o.id || "Oculus Go Controller" === o.id || "OpenVR Gamepad" === o.id || o.id.startsWith("Oculus Touch") || o.id.startsWith("Spatial Controller"))) {
                    if (r === t) return o;
                    r++
                }
            }
        }
        this.enabled = !1, this.getController = function(t) {
            var e = o[t];
            return void 0 === e && ((e = new ii).matrixAutoUpdate = !1, e.visible = !1, o[t] = e), e
        }, this.getDevice = function() {
            return n
        }, this.setDevice = function(t) {
            void 0 !== t && (n = t), w.setContext(t)
        }, this.setFrameOfReferenceType = function(t) {
            c = t
        }, this.setPoseTarget = function(t) {
            void 0 !== t && (i = t)
        }, this.getCamera = function(t) {
            var e = "stage" === c ? 1.6 : 0;
            if (null === n) return t.position.set(0, e, 0), t;
            if (n.depthNear = t.near, n.depthFar = t.far, n.getFrameData(r), "stage" === c) {
                var v = n.stageParameters;
                v ? a.fromArray(v.sittingToStandingTransform) : a.makeTranslation(0, e, 0)
            }
            var p = r.pose,
                g = null !== i ? i : t;
            if (g.matrix.copy(a), g.matrix.decompose(g.position, g.quaternion, g.scale), null !== p.orientation && (l.fromArray(p.orientation), g.quaternion.multiply(l)), null !== p.position && (l.setFromRotationMatrix(a), h.fromArray(p.position), h.applyQuaternion(l), g.position.add(h)), g.updateMatrixWorld(), !1 === n.isPresenting) return t;
            f.near = t.near, d.near = t.near, f.far = t.far, d.far = t.far, m.matrixWorld.copy(t.matrixWorld), m.matrixWorldInverse.copy(t.matrixWorldInverse), f.matrixWorldInverse.fromArray(r.leftViewMatrix), d.matrixWorldInverse.fromArray(r.rightViewMatrix), s.getInverse(a), "stage" === c && (f.matrixWorldInverse.multiply(s), d.matrixWorldInverse.multiply(s));
            var y = g.parent;
            null !== y && (u.getInverse(y.matrixWorld), f.matrixWorldInverse.multiply(u), d.matrixWorldInverse.multiply(u)), f.matrixWorld.getInverse(f.matrixWorldInverse), d.matrixWorld.getInverse(d.matrixWorldInverse), f.projectionMatrix.fromArray(r.leftProjectionMatrix), d.projectionMatrix.fromArray(r.rightProjectionMatrix), m.projectionMatrix.copy(f.projectionMatrix);
            var w = n.getLayers();
            if (w.length) {
                var _ = w[0];
                null !== _.leftBounds && 4 === _.leftBounds.length && f.bounds.fromArray(_.leftBounds), null !== _.rightBounds && 4 === _.rightBounds.length && d.bounds.fromArray(_.rightBounds)
            }
            return function() {
                for (var t = 0; t < o.length; t++) {
                    var e = o[t],
                        n = b(t);
                    if (void 0 !== n && void 0 !== n.pose) {
                        if (null === n.pose) return;
                        var r = n.pose;
                        !1 === r.hasPosition && e.position.set(.2, -.6, -.05), null !== r.position && e.position.fromArray(r.position), null !== r.orientation && e.quaternion.fromArray(r.orientation), e.matrix.compose(e.position, e.quaternion, e.scale), e.matrix.premultiply(a), e.matrix.decompose(e.position, e.quaternion, e.scale), e.matrixWorldNeedsUpdate = !0, e.visible = !0;
                        var i = "Daydream Controller" === n.id ? 0 : 1;
                        x[t] !== n.buttons[i].pressed && (x[t] = n.buttons[i].pressed, !0 === x[t] ? e.dispatchEvent({
                            type: "selectstart"
                        }) : (e.dispatchEvent({
                            type: "selectend"
                        }), e.dispatchEvent({
                            type: "select"
                        })))
                    } else e.visible = !1
                }
            }(), m
        }, this.getStandingMatrix = function() {
            return a
        }, this.isPresenting = g;
        var w = new cn;
        this.setAnimationLoop = function(t) {
            w.setAnimationLoop(t)
        }, this.submitFrame = function() {
            g() && n.submitFrame()
        }, this.dispose = function() {
            "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", y)
        }
    }

    function ui(t) {
        console.log("THREE.WebGLRenderer", i);
        var e = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
            n = void 0 !== t.context ? t.context : null,
            r = void 0 !== t.alpha && t.alpha,
            o = void 0 === t.depth || t.depth,
            u = void 0 === t.stencil || t.stencil,
            l = void 0 !== t.antialias && t.antialias,
            h = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
            f = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
            d = void 0 !== t.powerPreference ? t.powerPreference : "default",
            v = null,
            y = null;
        this.domElement = e, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = rt, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
        var x, b, w, _, z, C, R, I, D, O, F, j, k, U, B, N, G, H, V = this,
            $ = !1,
            tt = null,
            et = null,
            nt = null,
            it = -1,
            ot = {
                geometry: null,
                program: null,
                wireframe: !1
            },
            at = null,
            st = null,
            ct = new Xe,
            ut = new Xe,
            lt = null,
            ht = 0,
            ft = e.width,
            dt = e.height,
            vt = 1,
            pt = new Xe(0, 0, ft, dt),
            mt = new Xe(0, 0, ft, dt),
            gt = !1,
            yt = new tn,
            xt = new function() {
                var t = this,
                    e = null,
                    n = 0,
                    r = !1,
                    i = !1,
                    o = new $e,
                    a = new He,
                    s = {
                        value: null,
                        needsUpdate: !1
                    };

                function c() {
                    s.value !== e && (s.value = e, s.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0
                }

                function u(e, n, r, i) {
                    var c = null !== e ? e.length : 0,
                        u = null;
                    if (0 !== c) {
                        if (u = s.value, !0 !== i || null === u) {
                            var l = r + 4 * c,
                                h = n.matrixWorldInverse;
                            a.getNormalMatrix(h), (null === u || u.length < l) && (u = new Float32Array(l));
                            for (var f = 0, d = r; f !== c; ++f, d += 4) o.copy(e[f]).applyMatrix4(h, a), o.normal.toArray(u, d), u[d + 3] = o.constant
                        }
                        s.value = u, s.needsUpdate = !0
                    }
                    return t.numPlanes = c, u
                }
                this.uniform = s, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, i, o) {
                    var a = 0 !== t.length || i || 0 !== n || r;
                    return r = i, e = u(t, o, 0), n = t.length, a
                }, this.beginShadows = function() {
                    i = !0, u(null)
                }, this.endShadows = function() {
                    i = !1, c()
                }, this.setState = function(t, o, a, l, h, f) {
                    if (!r || null === t || 0 === t.length || i && !a) i ? u(null) : c();
                    else {
                        var d = i ? 0 : n,
                            v = 4 * d,
                            p = h.clippingState || null;
                        s.value = p, p = u(t, l, v, f);
                        for (var m = 0; m !== v; ++m) p[m] = e[m];
                        h.clippingState = p, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += d
                    }
                }
            },
            bt = !1,
            wt = !1,
            _t = new Be,
            Mt = new Ge;

        function Et() {
            return null === et ? vt : 1
        }
        try {
            var Tt = {
                alpha: r,
                depth: o,
                stencil: u,
                antialias: l,
                premultipliedAlpha: h,
                preserveDrawingBuffer: f,
                powerPreference: d
            };
            if (e.addEventListener("webglcontextlost", Rt, !1), e.addEventListener("webglcontextrestored", It, !1), null === (x = n || e.getContext("webgl", Tt) || e.getContext("experimental-webgl", Tt))) throw null !== e.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
            void 0 === x.getShaderPrecisionFormat && (x.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            })
        } catch (t) {
            console.error("THREE.WebGLRenderer: " + t.message)
        }

        function Pt() {
            b = new function(t) {
                var e = {};
                return {
                    get: function(n) {
                        if (void 0 !== e[n]) return e[n];
                        var r;
                        switch (n) {
                            case "WEBGL_depth_texture":
                                r = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                                break;
                            case "EXT_texture_filter_anisotropic":
                                r = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                r = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                r = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                break;
                            default:
                                r = t.getExtension(n)
                        }
                        return null === r && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), e[n] = r, r
                    }
                }
            }(x), (w = new function(t, e, n) {
                var r;

                function i(e) {
                    if ("highp" === e) {
                        if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp";
                        e = "mediump"
                    }
                    return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                }
                var o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext,
                    a = void 0 !== n.precision ? n.precision : "highp",
                    s = i(a);
                s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."), a = s);
                var c = !0 === n.logarithmicDepthBuffer,
                    u = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
                    l = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                    h = t.getParameter(t.MAX_TEXTURE_SIZE),
                    f = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
                    d = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                    v = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
                    p = t.getParameter(t.MAX_VARYING_VECTORS),
                    m = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
                    g = l > 0,
                    y = o || !!e.get("OES_texture_float");
                return {
                    isWebGL2: o,
                    getMaxAnisotropy: function() {
                        if (void 0 !== r) return r;
                        var n = e.get("EXT_texture_filter_anisotropic");
                        return r = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                    },
                    getMaxPrecision: i,
                    precision: a,
                    logarithmicDepthBuffer: c,
                    maxTextures: u,
                    maxVertexTextures: l,
                    maxTextureSize: h,
                    maxCubemapSize: f,
                    maxAttributes: d,
                    maxVertexUniforms: v,
                    maxVaryings: p,
                    maxFragmentUniforms: m,
                    vertexTextures: g,
                    floatFragmentTextures: y,
                    floatVertexTextures: g && y
                }
            }(x, b, t)).isWebGL2 || (b.get("WEBGL_depth_texture"), b.get("OES_texture_float"), b.get("OES_texture_half_float"), b.get("OES_texture_half_float_linear"), b.get("OES_standard_derivatives"), b.get("OES_element_index_uint"), b.get("ANGLE_instanced_arrays")), b.get("OES_texture_float_linear"), H = new ri(x, b, w), (_ = new function(t, e, n, r) {
                var i = new function() {
                        var e = !1,
                            n = new Xe,
                            r = null,
                            i = new Xe(0, 0, 0, 0);
                        return {
                            setMask: function(n) {
                                r === n || e || (t.colorMask(n, n, n, n), r = n)
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e, r, o, a, s) {
                                !0 === s && (e *= a, r *= a, o *= a), n.set(e, r, o, a), !1 === i.equals(n) && (t.clearColor(e, r, o, a), i.copy(n))
                            },
                            reset: function() {
                                e = !1, r = null, i.set(-1, 0, 0, 0)
                            }
                        }
                    },
                    o = new function() {
                        var e = !1,
                            n = null,
                            r = null,
                            i = null;
                        return {
                            setTest: function(e) {
                                e ? ot(t.DEPTH_TEST) : at(t.DEPTH_TEST)
                            },
                            setMask: function(r) {
                                n === r || e || (t.depthMask(r), n = r)
                            },
                            setFunc: function(e) {
                                if (r !== e) {
                                    if (e) switch (e) {
                                        case W:
                                            t.depthFunc(t.NEVER);
                                            break;
                                        case Y:
                                            t.depthFunc(t.ALWAYS);
                                            break;
                                        case X:
                                            t.depthFunc(t.LESS);
                                            break;
                                        case q:
                                            t.depthFunc(t.LEQUAL);
                                            break;
                                        case K:
                                            t.depthFunc(t.EQUAL);
                                            break;
                                        case Z:
                                            t.depthFunc(t.GEQUAL);
                                            break;
                                        case J:
                                            t.depthFunc(t.GREATER);
                                            break;
                                        case Q:
                                            t.depthFunc(t.NOTEQUAL);
                                            break;
                                        default:
                                            t.depthFunc(t.LEQUAL)
                                    } else t.depthFunc(t.LEQUAL);
                                    r = e
                                }
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e) {
                                i !== e && (t.clearDepth(e), i = e)
                            },
                            reset: function() {
                                e = !1, n = null, r = null, i = null
                            }
                        }
                    },
                    u = new function() {
                        var e = !1,
                            n = null,
                            r = null,
                            i = null,
                            o = null,
                            a = null,
                            s = null,
                            c = null,
                            u = null;
                        return {
                            setTest: function(e) {
                                e ? ot(t.STENCIL_TEST) : at(t.STENCIL_TEST)
                            },
                            setMask: function(r) {
                                n === r || e || (t.stencilMask(r), n = r)
                            },
                            setFunc: function(e, n, a) {
                                r === e && i === n && o === a || (t.stencilFunc(e, n, a), r = e, i = n, o = a)
                            },
                            setOp: function(e, n, r) {
                                a === e && s === n && c === r || (t.stencilOp(e, n, r), a = e, s = n, c = r)
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e) {
                                u !== e && (t.clearStencil(e), u = e)
                            },
                            reset: function() {
                                e = !1, n = null, r = null, i = null, o = null, a = null, s = null, c = null, u = null
                            }
                        }
                    },
                    l = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                    h = new Uint8Array(l),
                    f = new Uint8Array(l),
                    d = new Uint8Array(l),
                    v = {},
                    p = null,
                    y = null,
                    x = null,
                    b = null,
                    w = null,
                    _ = null,
                    z = null,
                    C = null,
                    R = null,
                    I = null,
                    D = !1,
                    O = null,
                    F = null,
                    j = null,
                    k = null,
                    U = null,
                    B = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
                    N = !1,
                    G = 0,
                    H = t.getParameter(t.VERSION); - 1 !== H.indexOf("WebGL") ? (G = parseFloat(/^WebGL\ ([0-9])/.exec(H)[1]), N = G >= 1) : -1 !== H.indexOf("OpenGL ES") && (G = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(H)[1]), N = G >= 2);
                var V = null,
                    $ = {},
                    tt = new Xe,
                    et = new Xe;

                function nt(e, n, r) {
                    var i = new Uint8Array(4),
                        o = t.createTexture();
                    t.bindTexture(e, o), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                    for (var a = 0; a < r; a++) t.texImage2D(n + a, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, i);
                    return o
                }
                var rt = {};

                function it(n, i) {
                    h[n] = 1, 0 === f[n] && (t.enableVertexAttribArray(n), f[n] = 1), d[n] !== i && ((r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), d[n] = i)
                }

                function ot(e) {
                    !0 !== v[e] && (t.enable(e), v[e] = !0)
                }

                function at(e) {
                    !1 !== v[e] && (t.disable(e), v[e] = !1)
                }

                function st(e, r, i, o, a, s, c, u) {
                    if (e !== M) {
                        if (x || (ot(t.BLEND), x = !0), e === L) a = a || r, s = s || i, c = c || o, r === w && a === C || (t.blendEquationSeparate(n.convert(r), n.convert(a)), w = r, C = a), i === _ && o === z && s === R && c === I || (t.blendFuncSeparate(n.convert(i), n.convert(o), n.convert(s), n.convert(c)), _ = i, z = o, R = s, I = c), b = e, D = null;
                        else if (e !== b || u !== D) {
                            if (w === A && C === A || (t.blendEquation(t.FUNC_ADD), w = A, C = A), u) switch (e) {
                                case S:
                                    t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                    break;
                                case E:
                                    t.blendFunc(t.ONE, t.ONE);
                                    break;
                                case T:
                                    t.blendFuncSeparate(t.ZERO, t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ONE_MINUS_SRC_ALPHA);
                                    break;
                                case P:
                                    t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", e)
                            } else switch (e) {
                                case S:
                                    t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                    break;
                                case E:
                                    t.blendFunc(t.SRC_ALPHA, t.ONE);
                                    break;
                                case T:
                                    t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR);
                                    break;
                                case P:
                                    t.blendFunc(t.ZERO, t.SRC_COLOR);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", e)
                            }
                            _ = null, z = null, R = null, I = null, b = e, D = u
                        }
                    } else x && (at(t.BLEND), x = !1)
                }

                function ct(e) {
                    O !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), O = e)
                }

                function ut(e) {
                    e !== a ? (ot(t.CULL_FACE), e !== F && (e === s ? t.cullFace(t.BACK) : e === c ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : at(t.CULL_FACE), F = e
                }

                function lt(e, n, r) {
                    e ? (ot(t.POLYGON_OFFSET_FILL), k === n && U === r || (t.polygonOffset(n, r), k = n, U = r)) : at(t.POLYGON_OFFSET_FILL)
                }

                function ht(e) {
                    void 0 === e && (e = t.TEXTURE0 + B - 1), V !== e && (t.activeTexture(e), V = e)
                }
                return rt[t.TEXTURE_2D] = nt(t.TEXTURE_2D, t.TEXTURE_2D, 1), rt[t.TEXTURE_CUBE_MAP] = nt(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), i.setClear(0, 0, 0, 1), o.setClear(1), u.setClear(0), ot(t.DEPTH_TEST), o.setFunc(q), ct(!1), ut(s), ot(t.CULL_FACE), st(M), {
                    buffers: {
                        color: i,
                        depth: o,
                        stencil: u
                    },
                    initAttributes: function() {
                        for (var t = 0, e = h.length; t < e; t++) h[t] = 0
                    },
                    enableAttribute: function(t) {
                        it(t, 0)
                    },
                    enableAttributeAndDivisor: it,
                    disableUnusedAttributes: function() {
                        for (var e = 0, n = f.length; e !== n; ++e) f[e] !== h[e] && (t.disableVertexAttribArray(e), f[e] = 0)
                    },
                    enable: ot,
                    disable: at,
                    getCompressedTextureFormats: function() {
                        if (null === p && (p = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1") || e.get("WEBGL_compressed_texture_astc")))
                            for (var n = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS), r = 0; r < n.length; r++) p.push(n[r]);
                        return p
                    },
                    useProgram: function(e) {
                        return y !== e && (t.useProgram(e), y = e, !0)
                    },
                    setBlending: st,
                    setMaterial: function(e, n) {
                        e.side === g ? at(t.CULL_FACE) : ot(t.CULL_FACE);
                        var r = e.side === m;
                        n && (r = !r), ct(r), e.blending === S && !1 === e.transparent ? st(M) : st(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), o.setFunc(e.depthFunc), o.setTest(e.depthTest), o.setMask(e.depthWrite), i.setMask(e.colorWrite), lt(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
                    },
                    setFlipSided: ct,
                    setCullFace: ut,
                    setLineWidth: function(e) {
                        e !== j && (N && t.lineWidth(e), j = e)
                    },
                    setPolygonOffset: lt,
                    setScissorTest: function(e) {
                        e ? ot(t.SCISSOR_TEST) : at(t.SCISSOR_TEST)
                    },
                    activeTexture: ht,
                    bindTexture: function(e, n) {
                        null === V && ht();
                        var r = $[V];
                        void 0 === r && (r = {
                            type: void 0,
                            texture: void 0
                        }, $[V] = r), r.type === e && r.texture === n || (t.bindTexture(e, n || rt[e]), r.type = e, r.texture = n)
                    },
                    compressedTexImage2D: function() {
                        try {
                            t.compressedTexImage2D.apply(t, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    texImage2D: function() {
                        try {
                            t.texImage2D.apply(t, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    texImage3D: function() {
                        try {
                            t.texImage3D.apply(t, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    scissor: function(e) {
                        !1 === tt.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), tt.copy(e))
                    },
                    viewport: function(e) {
                        !1 === et.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), et.copy(e))
                    },
                    reset: function() {
                        for (var e = 0; e < f.length; e++) 1 === f[e] && (t.disableVertexAttribArray(e), f[e] = 0);
                        v = {}, p = null, V = null, $ = {}, y = null, b = null, O = null, F = null, i.reset(), o.reset(), u.reset()
                    }
                }
            }(x, b, H, w)).scissor(ut.copy(mt).multiplyScalar(vt)), _.viewport(ct.copy(pt).multiplyScalar(vt)), z = new function(t) {
                var e = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: e,
                    programs: null,
                    autoReset: !0,
                    reset: function() {
                        e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                    },
                    update: function(n, r, i) {
                        switch (i = i || 1, e.calls++, r) {
                            case t.TRIANGLES:
                                e.triangles += i * (n / 3);
                                break;
                            case t.TRIANGLE_STRIP:
                            case t.TRIANGLE_FAN:
                                e.triangles += i * (n - 2);
                                break;
                            case t.LINES:
                                e.lines += i * (n / 2);
                                break;
                            case t.LINE_STRIP:
                                e.lines += i * (n - 1);
                                break;
                            case t.LINE_LOOP:
                                e.lines += i * n;
                                break;
                            case t.POINTS:
                                e.points += i * n;
                                break;
                            default:
                                console.error("THREE.WebGLInfo: Unknown draw mode:", r)
                        }
                    }
                }
            }(x), C = new function() {
                var t = new WeakMap;
                return {
                    get: function(e) {
                        var n = t.get(e);
                        return void 0 === n && (n = {}, t.set(e, n)), n
                    },
                    remove: function(e) {
                        t.delete(e)
                    },
                    update: function(e, n, r) {
                        t.get(e)[n] = r
                    },
                    dispose: function() {
                        t = new WeakMap
                    }
                }
            }, R = new ni(x, b, _, C, w, H, z), I = new un(x), D = new function(t, e, n) {
                var r = {},
                    i = {};

                function o(t) {
                    var a = t.target,
                        s = r[a.id];
                    for (var c in null !== s.index && e.remove(s.index), s.attributes) e.remove(s.attributes[c]);
                    a.removeEventListener("dispose", o), delete r[a.id];
                    var u = i[s.id];
                    u && (e.remove(u), delete i[s.id]), n.memory.geometries--
                }
                return {
                    get: function(t, e) {
                        var i = r[e.id];
                        return i || (e.addEventListener("dispose", o), e.isBufferGeometry ? i = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new zn).setFromObject(t)), i = e._bufferGeometry), r[e.id] = i, n.memory.geometries++, i)
                    },
                    update: function(n) {
                        var r = n.index,
                            i = n.attributes;
                        for (var o in null !== r && e.update(r, t.ELEMENT_ARRAY_BUFFER), i) e.update(i[o], t.ARRAY_BUFFER);
                        var a = n.morphAttributes;
                        for (var o in a)
                            for (var s = a[o], c = 0, u = s.length; c < u; c++) e.update(s[c], t.ARRAY_BUFFER)
                    },
                    getWireframeAttribute: function(n) {
                        var r = i[n.id];
                        if (r) return r;
                        var o, a = [],
                            s = n.index,
                            c = n.attributes;
                        if (null !== s)
                            for (var u = 0, l = (o = s.array).length; u < l; u += 3) {
                                var h = o[u + 0],
                                    f = o[u + 1],
                                    d = o[u + 2];
                                a.push(h, f, f, d, d, h)
                            } else
                                for (u = 0, l = (o = c.position.array).length / 3 - 1; u < l; u += 3) h = u + 0, f = u + 1, d = u + 2, a.push(h, f, f, d, d, h);
                        return r = new(Ln(a) > 65535 ? Sn : _n)(a, 1), e.update(r, t.ELEMENT_ARRAY_BUFFER), i[n.id] = r, r
                    }
                }
            }(x, I, z), O = new function(t, e) {
                var n = {};
                return {
                    update: function(r) {
                        var i = e.render.frame,
                            o = r.geometry,
                            a = t.get(r, o);
                        return n[a.id] !== i && (o.isGeometry && a.updateFromObject(r), t.update(a), n[a.id] = i), a
                    },
                    dispose: function() {
                        n = {}
                    }
                }
            }(D, z), B = new function(t) {
                var e = {},
                    n = new Float32Array(8);
                return {
                    update: function(r, i, o, a) {
                        var s = r.morphTargetInfluences,
                            c = s.length,
                            u = e[i.id];
                        if (void 0 === u) {
                            u = [];
                            for (var l = 0; l < c; l++) u[l] = [l, 0];
                            e[i.id] = u
                        }
                        var h = o.morphTargets && i.morphAttributes.position,
                            f = o.morphNormals && i.morphAttributes.normal;
                        for (l = 0; l < c; l++) 0 !== (d = u[l])[1] && (h && i.removeAttribute("morphTarget" + l), f && i.removeAttribute("morphNormal" + l));
                        for (l = 0; l < c; l++)(d = u[l])[0] = l, d[1] = s[l];
                        for (u.sort(Gn), l = 0; l < 8; l++) {
                            var d;
                            if (d = u[l]) {
                                var v = d[0],
                                    p = d[1];
                                if (p) {
                                    h && i.addAttribute("morphTarget" + l, h[v]), f && i.addAttribute("morphNormal" + l, f[v]), n[l] = p;
                                    continue
                                }
                            }
                            n[l] = 0
                        }
                        a.getUniforms().setValue(t, "morphTargetInfluences", n)
                    }
                }
            }(x), F = new Wr(V, b, w), j = new qr, k = new function() {
                var t = {};
                return {
                    get: function(e, n) {
                        var r;
                        return void 0 === t[e.id] ? (r = new Qr, t[e.id] = {}, t[e.id][n.id] = r) : void 0 === t[e.id][n.id] ? (r = new Qr, t[e.id][n.id] = r) : r = t[e.id][n.id], r
                    },
                    dispose: function() {
                        t = {}
                    }
                }
            }, U = new function(t, e, n, r) {
                var i, o, a = new on(0),
                    s = 0;

                function c(t, n) {
                    e.buffers.color.setClear(t.r, t.g, t.b, n, r)
                }
                return {
                    getClearColor: function() {
                        return a
                    },
                    setClearColor: function(t, e) {
                        a.set(t), c(a, s = void 0 !== e ? e : 1)
                    },
                    getClearAlpha: function() {
                        return s
                    },
                    setClearAlpha: function(t) {
                        c(a, s = t)
                    },
                    render: function(e, r, u, l) {
                        var h = r.background;
                        null === h ? c(a, s) : h && h.isColor && (c(h, 1), l = !0), (t.autoClear || l) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), h && h.isCubeTexture ? (void 0 === o && ((o = new Nn(new Rn(1, 1, 1), new jn({
                            uniforms: nn.clone(sn.cube.uniforms),
                            vertexShader: sn.cube.vertexShader,
                            fragmentShader: sn.cube.fragmentShader,
                            side: m,
                            depthTest: !0,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.removeAttribute("normal"), o.geometry.removeAttribute("uv"), o.onBeforeRender = function(t, e, n) {
                            this.matrixWorld.copyPosition(n.matrixWorld)
                        }, n.update(o)), o.material.uniforms.tCube.value = h, e.push(o, o.geometry, o.material, 0, null)) : h && h.isTexture && (void 0 === i && ((i = new Nn(new Dn(2, 2), new jn({
                            uniforms: nn.clone(sn.background.uniforms),
                            vertexShader: sn.background.vertexShader,
                            fragmentShader: sn.background.fragmentShader,
                            side: p,
                            depthTest: !0,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.removeAttribute("normal"), n.update(i)), i.material.uniforms.t2D.value = h, e.push(i, i.geometry, i.material, 0, null))
                    }
                }
            }(V, _, O, h), N = new function(t, e, n, r) {
                var i;
                this.setMode = function(t) {
                    i = t
                }, this.render = function(e, r) {
                    t.drawArrays(i, e, r), n.update(r, i)
                }, this.renderInstances = function(o, a, s) {
                    var c;
                    if (r.isWebGL2) c = t;
                    else if (null === (c = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    c[r.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](i, a, s, o.maxInstancedCount), n.update(s, i, o.maxInstancedCount)
                }
            }(x, b, z, w), G = new function(t, e, n, r) {
                var i, o, a;
                this.setMode = function(t) {
                    i = t
                }, this.setIndex = function(t) {
                    o = t.type, a = t.bytesPerElement
                }, this.render = function(e, r) {
                    t.drawElements(i, r, o, e * a), n.update(r, i)
                }, this.renderInstances = function(s, c, u) {
                    var l;
                    if (r.isWebGL2) l = t;
                    else if (null === (l = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    l[r.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](i, u, o, c * a, s.maxInstancedCount), n.update(u, i, s.maxInstancedCount)
                }
            }(x, b, z, w), z.programs = F.programs, V.context = x, V.capabilities = w, V.extensions = b, V.properties = C, V.renderLists = j, V.state = _, V.info = z
        }
        Pt();
        var Lt = null;
        "undefined" != typeof navigator && (Lt = "xr" in navigator ? new function(t) {
            var e = t.context,
                n = null,
                r = null,
                i = null,
                o = "stage",
                a = null,
                s = [],
                c = [];

            function u() {
                return null !== r && null !== i
            }
            var l = new ai;
            l.layers.enable(1), l.viewport = new Xe;
            var h = new ai;
            h.layers.enable(2), h.viewport = new Xe;
            var f = new si([l, h]);

            function d(t) {
                var e = s[c.indexOf(t.inputSource)];
                e && e.dispatchEvent({
                    type: t.type
                })
            }

            function v() {
                t.setFramebuffer(null), g.stop()
            }

            function p(t, e) {
                null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld)
            }
            f.layers.enable(1), f.layers.enable(2), this.enabled = !1, this.getController = function(t) {
                var e = s[t];
                return void 0 === e && ((e = new ii).matrixAutoUpdate = !1, e.visible = !1, s[t] = e), e
            }, this.getDevice = function() {
                return n
            }, this.setDevice = function(t) {
                void 0 !== t && (n = t), t instanceof XRDevice && e.setCompatibleXRDevice(t)
            }, this.setFrameOfReferenceType = function(t) {
                o = t
            }, this.setSession = function(n) {
                null !== (r = n) && (r.addEventListener("select", d), r.addEventListener("selectstart", d), r.addEventListener("selectend", d), r.addEventListener("end", v), r.baseLayer = new XRWebGLLayer(r, e), r.requestFrameOfReference(o).then(function(e) {
                    i = e, t.setFramebuffer(r.baseLayer.framebuffer), g.setContext(r), g.start()
                }), c = r.getInputSources(), r.addEventListener("inputsourceschange", function() {
                    c = r.getInputSources(), console.log(c)
                }))
            }, this.getCamera = function(t) {
                if (u()) {
                    var e = t.parent,
                        n = f.cameras;
                    p(f, e);
                    for (var r = 0; r < n.length; r++) p(n[r], e);
                    t.matrixWorld.copy(f.matrixWorld);
                    for (var i = t.children, o = (r = 0, i.length); r < o; r++) i[r].updateMatrixWorld(!0);
                    return f
                }
                return t
            }, this.isPresenting = u;
            var m = null,
                g = new cn;
            g.setAnimationLoop(function(t, e) {
                if (null !== (a = e.getDevicePose(i)))
                    for (var n = r.baseLayer, o = e.views, u = 0; u < o.length; u++) {
                        var l = o[u],
                            h = n.getViewport(l),
                            d = a.getViewMatrix(l),
                            v = f.cameras[u];
                        v.matrix.fromArray(d).getInverse(v.matrix), v.projectionMatrix.fromArray(l.projectionMatrix), v.viewport.set(h.x, h.y, h.width, h.height), 0 === u && (f.matrix.copy(v.matrix), f.projectionMatrix.copy(v.projectionMatrix))
                    }
                for (u = 0; u < s.length; u++) {
                    var p = s[u],
                        g = c[u];
                    if (g) {
                        var y = e.getInputPose(g, i);
                        if (null !== y) {
                            "targetRay" in y ? p.matrix.elements = y.targetRay.transformMatrix : "pointerMatrix" in y && (p.matrix.elements = y.pointerMatrix), p.matrix.decompose(p.position, p.rotation, p.scale), p.visible = !0;
                            continue
                        }
                    }
                    p.visible = !1
                }
                m && m(t)
            }), this.setAnimationLoop = function(t) {
                m = t
            }, this.dispose = function() {}, this.getStandingMatrix = function() {
                return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new THREE.Matrix4
            }, this.submitFrame = function() {}
        }(V) : new ci(V)), this.vr = Lt;
        var At = new ei(V, O, w.maxTextureSize);

        function Rt(t) {
            t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), $ = !0
        }

        function It() {
            console.log("THREE.WebGLRenderer: Context Restored."), $ = !1, Pt()
        }

        function Dt(t) {
            var e = t.target;
            e.removeEventListener("dispose", Dt),
                function(t) {
                    Ot(t), C.remove(t)
                }(e)
        }

        function Ot(t) {
            var e = C.get(t).program;
            t.program = void 0, void 0 !== e && F.releaseProgram(e)
        }
        this.shadowMap = At, this.getContext = function() {
            return x
        }, this.getContextAttributes = function() {
            return x.getContextAttributes()
        }, this.forceContextLoss = function() {
            var t = b.get("WEBGL_lose_context");
            t && t.loseContext()
        }, this.forceContextRestore = function() {
            var t = b.get("WEBGL_lose_context");
            t && t.restoreContext()
        }, this.getPixelRatio = function() {
            return vt
        }, this.setPixelRatio = function(t) {
            void 0 !== t && (vt = t, this.setSize(ft, dt, !1))
        }, this.getSize = function() {
            return {
                width: ft,
                height: dt
            }
        }, this.setSize = function(t, n, r) {
            Lt.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (ft = t, dt = n, e.width = t * vt, e.height = n * vt, !1 !== r && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
        }, this.getDrawingBufferSize = function() {
            return {
                width: ft * vt,
                height: dt * vt
            }
        }, this.setDrawingBufferSize = function(t, n, r) {
            ft = t, dt = n, vt = r, e.width = t * r, e.height = n * r, this.setViewport(0, 0, t, n)
        }, this.getCurrentViewport = function() {
            return ct
        }, this.setViewport = function(t, e, n, r) {
            pt.set(t, dt - e - r, n, r), _.viewport(ct.copy(pt).multiplyScalar(vt))
        }, this.setScissor = function(t, e, n, r) {
            mt.set(t, dt - e - r, n, r), _.scissor(ut.copy(mt).multiplyScalar(vt))
        }, this.setScissorTest = function(t) {
            _.setScissorTest(gt = t)
        }, this.getClearColor = function() {
            return U.getClearColor()
        }, this.setClearColor = function() {
            U.setClearColor.apply(U, arguments)
        }, this.getClearAlpha = function() {
            return U.getClearAlpha()
        }, this.setClearAlpha = function() {
            U.setClearAlpha.apply(U, arguments)
        }, this.clear = function(t, e, n) {
            var r = 0;
            (void 0 === t || t) && (r |= x.COLOR_BUFFER_BIT), (void 0 === e || e) && (r |= x.DEPTH_BUFFER_BIT), (void 0 === n || n) && (r |= x.STENCIL_BUFFER_BIT), x.clear(r)
        }, this.clearColor = function() {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }, this.dispose = function() {
            e.removeEventListener("webglcontextlost", Rt, !1), e.removeEventListener("webglcontextrestored", It, !1), j.dispose(), k.dispose(), C.dispose(), O.dispose(), Lt.dispose(), jt.stop()
        }, this.renderBufferImmediate = function(t, e) {
            _.initAttributes();
            var n = C.get(t);
            t.hasPositions && !n.position && (n.position = x.createBuffer()), t.hasNormals && !n.normal && (n.normal = x.createBuffer()), t.hasUvs && !n.uv && (n.uv = x.createBuffer()), t.hasColors && !n.color && (n.color = x.createBuffer());
            var r = e.getAttributes();
            t.hasPositions && (x.bindBuffer(x.ARRAY_BUFFER, n.position), x.bufferData(x.ARRAY_BUFFER, t.positionArray, x.DYNAMIC_DRAW), _.enableAttribute(r.position), x.vertexAttribPointer(r.position, 3, x.FLOAT, !1, 0, 0)), t.hasNormals && (x.bindBuffer(x.ARRAY_BUFFER, n.normal), x.bufferData(x.ARRAY_BUFFER, t.normalArray, x.DYNAMIC_DRAW), _.enableAttribute(r.normal), x.vertexAttribPointer(r.normal, 3, x.FLOAT, !1, 0, 0)), t.hasUvs && (x.bindBuffer(x.ARRAY_BUFFER, n.uv), x.bufferData(x.ARRAY_BUFFER, t.uvArray, x.DYNAMIC_DRAW), _.enableAttribute(r.uv), x.vertexAttribPointer(r.uv, 2, x.FLOAT, !1, 0, 0)), t.hasColors && (x.bindBuffer(x.ARRAY_BUFFER, n.color), x.bufferData(x.ARRAY_BUFFER, t.colorArray, x.DYNAMIC_DRAW), _.enableAttribute(r.color), x.vertexAttribPointer(r.color, 3, x.FLOAT, !1, 0, 0)), _.disableUnusedAttributes(), x.drawArrays(x.TRIANGLES, 0, t.count), t.count = 0
        }, this.renderBufferDirect = function(t, e, n, r, i, o) {
            var a = i.isMesh && i.normalMatrix.determinant() < 0;
            _.setMaterial(r, a);
            var s = Gt(t, e, r, i),
                c = !1;
            ot.geometry === n.id && ot.program === s.id && ot.wireframe === (!0 === r.wireframe) || (ot.geometry = n.id, ot.program = s.id, ot.wireframe = !0 === r.wireframe, c = !0), i.morphTargetInfluences && (B.update(i, n, r, s), c = !0);
            var u, l = n.index,
                h = n.attributes.position,
                f = 1;
            !0 === r.wireframe && (l = D.getWireframeAttribute(n), f = 2);
            var d = N;
            null !== l && (u = I.get(l), (d = G).setIndex(u)), c && (! function(t, e, n) {
                if (n && n.isInstancedBufferGeometry & !w.isWebGL2 && null === b.get("ANGLE_instanced_arrays")) return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                _.initAttributes();
                var r = n.attributes,
                    i = e.getAttributes(),
                    o = t.defaultAttributeValues;
                for (var a in i) {
                    var s = i[a];
                    if (s >= 0) {
                        var c = r[a];
                        if (void 0 !== c) {
                            var u = c.normalized,
                                l = c.itemSize,
                                h = I.get(c);
                            if (void 0 === h) continue;
                            var f = h.buffer,
                                d = h.type,
                                v = h.bytesPerElement;
                            if (c.isInterleavedBufferAttribute) {
                                var p = c.data,
                                    m = p.stride,
                                    g = c.offset;
                                p && p.isInstancedInterleavedBuffer ? (_.enableAttributeAndDivisor(s, p.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = p.meshPerAttribute * p.count)) : _.enableAttribute(s), x.bindBuffer(x.ARRAY_BUFFER, f), x.vertexAttribPointer(s, l, d, u, m * v, g * v)
                            } else c.isInstancedBufferAttribute ? (_.enableAttributeAndDivisor(s, c.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = c.meshPerAttribute * c.count)) : _.enableAttribute(s), x.bindBuffer(x.ARRAY_BUFFER, f), x.vertexAttribPointer(s, l, d, u, 0, 0)
                        } else if (void 0 !== o) {
                            var y = o[a];
                            if (void 0 !== y) switch (y.length) {
                                case 2:
                                    x.vertexAttrib2fv(s, y);
                                    break;
                                case 3:
                                    x.vertexAttrib3fv(s, y);
                                    break;
                                case 4:
                                    x.vertexAttrib4fv(s, y);
                                    break;
                                default:
                                    x.vertexAttrib1fv(s, y)
                            }
                        }
                    }
                }
                _.disableUnusedAttributes()
            }(r, s, n), null !== l && x.bindBuffer(x.ELEMENT_ARRAY_BUFFER, u.buffer));
            var v = 1 / 0;
            null !== l ? v = l.count : void 0 !== h && (v = h.count);
            var p = n.drawRange.start * f,
                m = n.drawRange.count * f,
                g = null !== o ? o.start * f : 0,
                y = null !== o ? o.count * f : 1 / 0,
                M = Math.max(p, g),
                S = Math.min(v, p + m, g + y) - 1,
                E = Math.max(0, S - M + 1);
            if (0 !== E) {
                if (i.isMesh)
                    if (!0 === r.wireframe) _.setLineWidth(r.wireframeLinewidth * Et()), d.setMode(x.LINES);
                    else switch (i.drawMode) {
                        case Me:
                            d.setMode(x.TRIANGLES);
                            break;
                        case Se:
                            d.setMode(x.TRIANGLE_STRIP);
                            break;
                        case Ee:
                            d.setMode(x.TRIANGLE_FAN)
                    } else if (i.isLine) {
                        var T = r.linewidth;
                        void 0 === T && (T = 1), _.setLineWidth(T * Et()), i.isLineSegments ? d.setMode(x.LINES) : i.isLineLoop ? d.setMode(x.LINE_LOOP) : d.setMode(x.LINE_STRIP)
                    } else i.isPoints ? d.setMode(x.POINTS) : i.isSprite && d.setMode(x.TRIANGLES);
                n && n.isInstancedBufferGeometry ? n.maxInstancedCount > 0 && d.renderInstances(n, M, E) : d.render(M, E)
            }
        }, this.compile = function(t, e) {
            (y = k.get(t, e)).init(), t.traverse(function(t) {
                t.isLight && (y.pushLight(t), t.castShadow && y.pushShadow(t))
            }), y.setupLights(e), t.traverse(function(e) {
                if (e.material)
                    if (Array.isArray(e.material))
                        for (var n = 0; n < e.material.length; n++) Nt(e.material[n], t.fog, e);
                    else Nt(e.material, t.fog, e)
            })
        };
        var Ft = null;
        var jt = new cn;

        function Ut(t, e, n, r) {
            for (var i = 0, o = t.length; i < o; i++) {
                var a = t[i],
                    s = a.object,
                    c = a.geometry,
                    u = void 0 === r ? a.material : r,
                    l = a.group;
                if (n.isArrayCamera) {
                    st = n;
                    for (var h = n.cameras, f = 0, d = h.length; f < d; f++) {
                        var v = h[f];
                        if (s.layers.test(v.layers)) {
                            if ("viewport" in v) _.viewport(ct.copy(v.viewport));
                            else {
                                var p = v.bounds,
                                    m = p.x * ft,
                                    g = p.y * dt,
                                    x = p.z * ft,
                                    b = p.w * dt;
                                _.viewport(ct.set(m, g, x, b).multiplyScalar(vt))
                            }
                            y.setupLights(v), Bt(s, e, v, c, u, l)
                        }
                    }
                } else st = null, Bt(s, e, n, c, u, l)
            }
        }

        function Bt(t, e, n, r, i, o) {
            if (t.onBeforeRender(V, e, n, r, i, o), y = k.get(e, st || n), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                _.setMaterial(i);
                var a = Gt(n, e.fog, i, t);
                ot.geometry = null, ot.program = null, ot.wireframe = !1,
                    function(t, e) {
                        t.render(function(t) {
                            V.renderBufferImmediate(t, e)
                        })
                    }(t, a)
            } else V.renderBufferDirect(n, e.fog, r, i, t, o);
            t.onAfterRender(V, e, n, r, i, o), y = k.get(e, st || n)
        }

        function Nt(t, e, n) {
            var r = C.get(t),
                i = y.state.lights,
                o = y.state.shadowsArray,
                a = r.lightsHash,
                s = i.state.hash,
                c = F.getParameters(t, i.state, o, e, xt.numPlanes, xt.numIntersection, n),
                u = F.getProgramCode(t, c),
                l = r.program,
                h = !0;
            if (void 0 === l) t.addEventListener("dispose", Dt);
            else if (l.code !== u) Ot(t);
            else if (a.stateID !== s.stateID || a.directionalLength !== s.directionalLength || a.pointLength !== s.pointLength || a.spotLength !== s.spotLength || a.rectAreaLength !== s.rectAreaLength || a.hemiLength !== s.hemiLength || a.shadowsLength !== s.shadowsLength) a.stateID = s.stateID, a.directionalLength = s.directionalLength, a.pointLength = s.pointLength, a.spotLength = s.spotLength, a.rectAreaLength = s.rectAreaLength, a.hemiLength = s.hemiLength, a.shadowsLength = s.shadowsLength, h = !1;
            else {
                if (void 0 !== c.shaderID) return;
                h = !1
            }
            if (h) {
                if (c.shaderID) {
                    var f = sn[c.shaderID];
                    r.shader = {
                        name: t.type,
                        uniforms: nn.clone(f.uniforms),
                        vertexShader: f.vertexShader,
                        fragmentShader: f.fragmentShader
                    }
                } else r.shader = {
                    name: t.type,
                    uniforms: t.uniforms,
                    vertexShader: t.vertexShader,
                    fragmentShader: t.fragmentShader
                };
                t.onBeforeCompile(r.shader, V), u = F.getProgramCode(t, c), l = F.acquireProgram(t, r.shader, c, u), r.program = l, t.program = l
            }
            var d = l.getAttributes();
            if (t.morphTargets) {
                t.numSupportedMorphTargets = 0;
                for (var v = 0; v < V.maxMorphTargets; v++) d["morphTarget" + v] >= 0 && t.numSupportedMorphTargets++
            }
            if (t.morphNormals) {
                t.numSupportedMorphNormals = 0;
                for (v = 0; v < V.maxMorphNormals; v++) d["morphNormal" + v] >= 0 && t.numSupportedMorphNormals++
            }
            var p = r.shader.uniforms;
            (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (r.numClippingPlanes = xt.numPlanes, r.numIntersection = xt.numIntersection, p.clippingPlanes = xt.uniform), r.fog = e, void 0 === a && (r.lightsHash = a = {}), a.stateID = s.stateID, a.directionalLength = s.directionalLength, a.pointLength = s.pointLength, a.spotLength = s.spotLength, a.rectAreaLength = s.rectAreaLength, a.hemiLength = s.hemiLength, a.shadowsLength = s.shadowsLength, t.lights && (p.ambientLightColor.value = i.state.ambient, p.directionalLights.value = i.state.directional, p.spotLights.value = i.state.spot, p.rectAreaLights.value = i.state.rectArea, p.pointLights.value = i.state.point, p.hemisphereLights.value = i.state.hemi, p.directionalShadowMap.value = i.state.directionalShadowMap, p.directionalShadowMatrix.value = i.state.directionalShadowMatrix, p.spotShadowMap.value = i.state.spotShadowMap, p.spotShadowMatrix.value = i.state.spotShadowMatrix, p.pointShadowMap.value = i.state.pointShadowMap, p.pointShadowMatrix.value = i.state.pointShadowMatrix);
            var m = r.program.getUniforms(),
                g = Dr.seqWithValue(m.seq, p);
            r.uniformsList = g
        }

        function Gt(t, e, n, r) {
            ht = 0;
            var i = C.get(n),
                o = y.state.lights,
                a = i.lightsHash,
                s = o.state.hash;
            if (bt && (wt || t !== at)) {
                var c = t === at && n.id === it;
                xt.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, t, i, c)
            }!1 === n.needsUpdate && (void 0 === i.program ? n.needsUpdate = !0 : n.fog && i.fog !== e ? n.needsUpdate = !0 : (!n.lights || a.stateID === s.stateID && a.directionalLength === s.directionalLength && a.pointLength === s.pointLength && a.spotLength === s.spotLength && a.rectAreaLength === s.rectAreaLength && a.hemiLength === s.hemiLength && a.shadowsLength === s.shadowsLength) && (void 0 === i.numClippingPlanes || i.numClippingPlanes === xt.numPlanes && i.numIntersection === xt.numIntersection) || (n.needsUpdate = !0)), n.needsUpdate && (Nt(n, e, r), n.needsUpdate = !1);
            var u = !1,
                l = !1,
                h = !1,
                f = i.program,
                d = f.getUniforms(),
                v = i.shader.uniforms;
            if (_.useProgram(f.program) && (u = !0, l = !0, h = !0), n.id !== it && (it = n.id, l = !0), u || at !== t) {
                if (d.setValue(x, "projectionMatrix", t.projectionMatrix), w.logarithmicDepthBuffer && d.setValue(x, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), at !== t && (at = t, l = !0, h = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.envMap) {
                    var p = d.map.cameraPosition;
                    void 0 !== p && p.setValue(x, Mt.setFromMatrixPosition(t.matrixWorld))
                }(n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && d.setValue(x, "viewMatrix", t.matrixWorldInverse)
            }
            if (n.skinning) {
                d.setOptional(x, r, "bindMatrix"), d.setOptional(x, r, "bindMatrixInverse");
                var g = r.skeleton;
                if (g) {
                    var b = g.bones;
                    if (w.floatVertexTextures) {
                        if (void 0 === g.boneTexture) {
                            var M = Math.sqrt(4 * b.length);
                            M = ke.ceilPowerOfTwo(M), M = Math.max(M, 4);
                            var S = new Float32Array(M * M * 4);
                            S.set(g.boneMatrices);
                            var E = new Ze(S, M, M, kt, zt);
                            E.needsUpdate = !0, g.boneMatrices = S, g.boneTexture = E, g.boneTextureSize = M
                        }
                        d.setValue(x, "boneTexture", g.boneTexture), d.setValue(x, "boneTextureSize", g.boneTextureSize)
                    } else d.setOptional(x, g, "boneMatrices")
                }
            }
            return l && (d.setValue(x, "toneMappingExposure", V.toneMappingExposure), d.setValue(x, "toneMappingWhitePoint", V.toneMappingWhitePoint), n.lights && function(t, e) {
                t.ambientLightColor.needsUpdate = e, t.directionalLights.needsUpdate = e, t.pointLights.needsUpdate = e, t.spotLights.needsUpdate = e, t.rectAreaLights.needsUpdate = e, t.hemisphereLights.needsUpdate = e
            }(v, h), e && n.fog && function(t, e) {
                t.fogColor.value = e.color, e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
            }(v, e), n.isMeshBasicMaterial ? Ht(v, n) : n.isMeshLambertMaterial ? (Ht(v, n), function(t, e) {
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
            }(v, n)) : n.isMeshPhongMaterial ? (Ht(v, n), n.isMeshToonMaterial ? function(t, e) {
                Vt(t, e), e.gradientMap && (t.gradientMap.value = e.gradientMap)
            }(v, n) : Vt(v, n)) : n.isMeshStandardMaterial ? (Ht(v, n), n.isMeshPhysicalMaterial ? function(t, e) {
                Wt(t, e), t.reflectivity.value = e.reflectivity, t.clearCoat.value = e.clearCoat, t.clearCoatRoughness.value = e.clearCoatRoughness
            }(v, n) : Wt(v, n)) : n.isMeshMatcapMaterial ? (Ht(v, n), function(t, e) {
                e.matcap && (t.matcap.value = e.matcap);
                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === m && (t.bumpScale.value *= -1));
                e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === m && t.normalScale.value.negate());
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }(v, n)) : n.isMeshDepthMaterial ? (Ht(v, n), function(t, e) {
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }(v, n)) : n.isMeshDistanceMaterial ? (Ht(v, n), function(t, e) {
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
                t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
            }(v, n)) : n.isMeshNormalMaterial ? (Ht(v, n), function(t, e) {
                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === m && (t.bumpScale.value *= -1));
                e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === m && t.normalScale.value.negate());
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }(v, n)) : n.isLineBasicMaterial ? (function(t, e) {
                t.diffuse.value = e.color, t.opacity.value = e.opacity
            }(v, n), n.isLineDashedMaterial && function(t, e) {
                t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
            }(v, n)) : n.isPointsMaterial ? function(t, e) {
                t.diffuse.value = e.color, t.opacity.value = e.opacity, t.size.value = e.size * vt, t.scale.value = .5 * dt, t.map.value = e.map, null !== e.map && (!0 === e.map.matrixAutoUpdate && e.map.updateMatrix(), t.uvTransform.value.copy(e.map.matrix))
            }(v, n) : n.isSpriteMaterial ? function(t, e) {
                t.diffuse.value = e.color, t.opacity.value = e.opacity, t.rotation.value = e.rotation, t.map.value = e.map, null !== e.map && (!0 === e.map.matrixAutoUpdate && e.map.updateMatrix(), t.uvTransform.value.copy(e.map.matrix))
            }(v, n) : n.isShadowMaterial && (v.color.value = n.color, v.opacity.value = n.opacity), void 0 !== v.ltc_1 && (v.ltc_1.value = an.LTC_1), void 0 !== v.ltc_2 && (v.ltc_2.value = an.LTC_2), Dr.upload(x, i.uniformsList, v, V)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (Dr.upload(x, i.uniformsList, v, V), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && d.setValue(x, "center", r.center), d.setValue(x, "modelViewMatrix", r.modelViewMatrix), d.setValue(x, "normalMatrix", r.normalMatrix), d.setValue(x, "modelMatrix", r.matrixWorld), f
        }

        function Ht(t, e) {
            var n;
            t.opacity.value = e.opacity, e.color && (t.diffuse.value = e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap && e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio, t.maxMipLevel.value = C.get(e.envMap).__maxMipLevel), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map ? n = e.map : e.specularMap ? n = e.specularMap : e.displacementMap ? n = e.displacementMap : e.normalMap ? n = e.normalMap : e.bumpMap ? n = e.bumpMap : e.roughnessMap ? n = e.roughnessMap : e.metalnessMap ? n = e.metalnessMap : e.alphaMap ? n = e.alphaMap : e.emissiveMap && (n = e.emissiveMap), void 0 !== n && (n.isWebGLRenderTarget && (n = n.texture), !0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
        }

        function Vt(t, e) {
            t.specular.value = e.specular, t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === m && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === m && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
        }

        function Wt(t, e) {
            t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === m && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === m && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
        }
        jt.setAnimationLoop(function(t) {
            Lt.isPresenting() || Ft && Ft(t)
        }), "undefined" != typeof window && jt.setContext(window), this.setAnimationLoop = function(t) {
            Ft = t, Lt.setAnimationLoop(t), jt.start()
        }, this.render = function(t, e, n, r) {
            if (e && e.isCamera) {
                if (!$) {
                    ot.geometry = null, ot.program = null, ot.wireframe = !1, it = -1, at = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), Lt.enabled && (e = Lt.getCamera(e)), (y = k.get(t, e)).init(), t.onBeforeRender(V, t, e, n), _t.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), yt.setFromMatrix(_t), wt = this.localClippingEnabled, bt = xt.init(this.clippingPlanes, wt, e), (v = j.get(t, e)).init(),
                        function t(e, n, r) {
                            if (!1 === e.visible) return;
                            var i = e.layers.test(n.layers);
                            if (i)
                                if (e.isLight) y.pushLight(e), e.castShadow && y.pushShadow(e);
                                else if (e.isSprite) {
                                if (!e.frustumCulled || yt.intersectsSprite(e)) {
                                    r && Mt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(_t);
                                    var o = O.update(e),
                                        a = e.material;
                                    v.push(e, o, a, Mt.z, null)
                                }
                            } else if (e.isImmediateRenderObject) r && Mt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(_t), v.push(e, null, e.material, Mt.z, null);
                            else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.update(), !e.frustumCulled || yt.intersectsObject(e))) {
                                r && Mt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(_t);
                                var o = O.update(e),
                                    a = e.material;
                                if (Array.isArray(a))
                                    for (var s = o.groups, c = 0, u = s.length; c < u; c++) {
                                        var l = s[c],
                                            h = a[l.materialIndex];
                                        h && h.visible && v.push(e, o, h, Mt.z, l)
                                    } else a.visible && v.push(e, o, a, Mt.z, null)
                            }
                            var f = e.children;
                            for (var c = 0, u = f.length; c < u; c++) t(f[c], n, r)
                        }(t, e, V.sortObjects), !0 === V.sortObjects && v.sort(), bt && xt.beginShadows();
                    var i = y.state.shadowsArray;
                    At.render(i, t, e), y.setupLights(e), bt && xt.endShadows(), this.info.autoReset && this.info.reset(), void 0 === n && (n = null), this.setRenderTarget(n), U.render(v, t, e, r);
                    var o = v.opaque,
                        a = v.transparent;
                    if (t.overrideMaterial) {
                        var s = t.overrideMaterial;
                        o.length && Ut(o, t, e, s), a.length && Ut(a, t, e, s)
                    } else o.length && Ut(o, t, e), a.length && Ut(a, t, e);
                    n && R.updateRenderTargetMipmap(n), _.buffers.depth.setTest(!0), _.buffers.depth.setMask(!0), _.buffers.color.setMask(!0), _.setPolygonOffset(!1), t.onAfterRender(V, t, e), Lt.enabled && Lt.submitFrame(), v = null, y = null
                }
            } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
        }, this.allocTextureUnit = function() {
            var t = ht;
            return t >= w.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + t + " texture units while this GPU supports only " + w.maxTextures), ht += 1, t
        }, this.setTexture2D = function() {
            var t = !1;
            return function(e, n) {
                e && e.isWebGLRenderTarget && (t || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), t = !0), e = e.texture), R.setTexture2D(e, n)
            }
        }(), this.setTexture3D = function(t, e) {
            R.setTexture3D(t, e)
        }, this.setTexture = function() {
            var t = !1;
            return function(e, n) {
                t || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), t = !0), R.setTexture2D(e, n)
            }
        }(), this.setTextureCube = function() {
            var t = !1;
            return function(e, n) {
                e && e.isWebGLRenderTargetCube && (t || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), t = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? R.setTextureCube(e, n) : R.setTextureCubeDynamic(e, n)
            }
        }(), this.setFramebuffer = function(t) {
            tt = t
        }, this.getRenderTarget = function() {
            return et
        }, this.setRenderTarget = function(t) {
            et = t, t && void 0 === C.get(t).__webglFramebuffer && R.setupRenderTarget(t);
            var e = tt,
                n = !1;
            if (t) {
                var r = C.get(t).__webglFramebuffer;
                t.isWebGLRenderTargetCube ? (e = r[t.activeCubeFace], n = !0) : e = r, ct.copy(t.viewport), ut.copy(t.scissor), lt = t.scissorTest
            } else ct.copy(pt).multiplyScalar(vt), ut.copy(mt).multiplyScalar(vt), lt = gt;
            if (nt !== e && (x.bindFramebuffer(x.FRAMEBUFFER, e), nt = e), _.viewport(ct), _.scissor(ut), _.setScissorTest(lt), n) {
                var i = C.get(t.texture);
                x.framebufferTexture2D(x.FRAMEBUFFER, x.COLOR_ATTACHMENT0, x.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace, i.__webglTexture, t.activeMipMapLevel)
            }
        }, this.readRenderTargetPixels = function(t, e, n, r, i, o) {
            if (t && t.isWebGLRenderTarget) {
                var a = C.get(t).__webglFramebuffer;
                if (a) {
                    var s = !1;
                    a !== nt && (x.bindFramebuffer(x.FRAMEBUFFER, a), s = !0);
                    try {
                        var c = t.texture,
                            u = c.format,
                            l = c.type;
                        if (u !== kt && H.convert(u) !== x.getParameter(x.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        if (!(l === St || H.convert(l) === x.getParameter(x.IMPLEMENTATION_COLOR_READ_TYPE) || l === zt && (w.isWebGL2 || b.get("OES_texture_float") || b.get("WEBGL_color_buffer_float")) || l === Ct && (w.isWebGL2 ? b.get("EXT_color_buffer_float") : b.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        x.checkFramebufferStatus(x.FRAMEBUFFER) === x.FRAMEBUFFER_COMPLETE ? e >= 0 && e <= t.width - r && n >= 0 && n <= t.height - i && x.readPixels(e, n, r, i, H.convert(u), H.convert(l), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        s && x.bindFramebuffer(x.FRAMEBUFFER, nt)
                    }
                }
            } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
        }, this.copyFramebufferToTexture = function(t, e, n) {
            var r = e.image.width,
                i = e.image.height,
                o = H.convert(e.format);
            this.setTexture2D(e, 0), x.copyTexImage2D(x.TEXTURE_2D, n || 0, o, t.x, t.y, r, i, 0)
        }, this.copyTextureToTexture = function(t, e, n, r) {
            var i = e.image.width,
                o = e.image.height,
                a = H.convert(n.format),
                s = H.convert(n.type);
            this.setTexture2D(n, 0), e.isDataTexture ? x.texSubImage2D(x.TEXTURE_2D, r || 0, t.x, t.y, i, o, a, s, e.image.data) : x.texSubImage2D(x.TEXTURE_2D, r || 0, t.x, t.y, a, s, e.image)
        }
    }

    function li(t, e) {
        this.name = "", this.color = new on(t), this.density = void 0 !== e ? e : 25e-5
    }

    function hi(t, e, n) {
        this.name = "", this.color = new on(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== n ? n : 1e3
    }

    function fi() {
        vn.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0
    }

    function di(t, e) {
        this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }

    function vi(t, e, n, r) {
        this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === r
    }

    function pi(t) {
        Fn.call(this), this.type = "SpriteMaterial", this.color = new on(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(t)
    }

    function mi(t) {
        if (vn.call(this), this.type = "Sprite", void 0 === Kr) {
            Kr = new zn;
            var e = new di(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
            Kr.setIndex([0, 1, 2, 0, 2, 3]), Kr.addAttribute("position", new vi(e, 3, 0, !1)), Kr.addAttribute("uv", new vi(e, 2, 3, !1))
        }
        this.geometry = Kr, this.material = void 0 !== t ? t : new pi, this.center = new Ue(.5, .5)
    }

    function gi() {
        vn.call(this), this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        })
    }

    function yi(t, e) {
        if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === e) this.calculateInverses();
        else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
        else {
            console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
            for (var n = 0, r = this.bones.length; n < r; n++) this.boneInverses.push(new Be)
        }
    }

    function xi() {
        vn.call(this), this.type = "Bone"
    }

    function bi(t, e) {
        Nn.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Be, this.bindMatrixInverse = new Be;
        var n = new yi(this.initBones());
        this.bind(n, this.matrixWorld), this.normalizeSkinWeights()
    }

    function wi(t) {
        Fn.call(this), this.type = "LineBasicMaterial", this.color = new on(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(t)
    }

    function _i(t, e, n) {
        1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), vn.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new zn, this.material = void 0 !== e ? e : new wi({
            color: 16777215 * Math.random()
        })
    }

    function Mi(t, e) {
        _i.call(this, t, e), this.type = "LineSegments"
    }

    function Si(t, e) {
        _i.call(this, t, e), this.type = "LineLoop"
    }

    function Ei(t) {
        Fn.call(this), this.type = "PointsMaterial", this.color = new on(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.lights = !1, this.setValues(t)
    }

    function Ti(t, e) {
        vn.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new zn, this.material = void 0 !== e ? e : new Ei({
            color: 16777215 * Math.random()
        })
    }

    function Pi(t, e, n, r, i, o, a, s, c) {
        Ye.call(this, t, e, n, r, i, o, a, s, c), this.generateMipmaps = !1
    }

    function Li(t, e, n, r, i, o, a, s, c, u, l, h) {
        Ye.call(this, null, o, a, s, c, u, r, i, l, h), this.image = {
            width: e,
            height: n
        }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
    }

    function Ai(t, e, n, r, i, o, a, s, c) {
        Ye.call(this, t, e, n, r, i, o, a, s, c), this.needsUpdate = !0
    }

    function zi(t, e, n, r, i, o, a, s, c, u) {
        if ((u = void 0 !== u ? u : Gt) !== Gt && u !== Ht) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === n && u === Gt && (n = Pt), void 0 === n && u === Ht && (n = Ot), Ye.call(this, null, r, i, o, a, s, u, n, c), this.image = {
            width: t,
            height: e
        }, this.magFilter = void 0 !== a ? a : yt, this.minFilter = void 0 !== s ? s : yt, this.flipY = !1, this.generateMipmaps = !1
    }

    function Ci(t) {
        zn.call(this), this.type = "WireframeGeometry";
        var e, n, r, i, o, a, s, c, u, l, h = [],
            f = [0, 0],
            d = {},
            v = ["a", "b", "c"];
        if (t && t.isGeometry) {
            var p = t.faces;
            for (e = 0, r = p.length; e < r; e++) {
                var m = p[e];
                for (n = 0; n < 3; n++) s = m[v[n]], c = m[v[(n + 1) % 3]], f[0] = Math.min(s, c), f[1] = Math.max(s, c), void 0 === d[u = f[0] + "," + f[1]] && (d[u] = {
                    index1: f[0],
                    index2: f[1]
                })
            }
            for (u in d) a = d[u], l = t.vertices[a.index1], h.push(l.x, l.y, l.z), l = t.vertices[a.index2], h.push(l.x, l.y, l.z)
        } else if (t && t.isBufferGeometry) {
            var g, y, x, b, w, _, M;
            if (l = new Ge, null !== t.index) {
                for (g = t.attributes.position, y = t.index, 0 === (x = t.groups).length && (x = [{
                        start: 0,
                        count: y.count,
                        materialIndex: 0
                    }]), i = 0, o = x.length; i < o; ++i)
                    for (e = w = (b = x[i]).start, r = w + b.count; e < r; e += 3)
                        for (n = 0; n < 3; n++) s = y.getX(e + n), c = y.getX(e + (n + 1) % 3), f[0] = Math.min(s, c), f[1] = Math.max(s, c), void 0 === d[u = f[0] + "," + f[1]] && (d[u] = {
                            index1: f[0],
                            index2: f[1]
                        });
                for (u in d) a = d[u], l.fromBufferAttribute(g, a.index1), h.push(l.x, l.y, l.z), l.fromBufferAttribute(g, a.index2), h.push(l.x, l.y, l.z)
            } else
                for (e = 0, r = (g = t.attributes.position).count / 3; e < r; e++)
                    for (n = 0; n < 3; n++) _ = 3 * e + n, l.fromBufferAttribute(g, _), h.push(l.x, l.y, l.z), M = 3 * e + (n + 1) % 3, l.fromBufferAttribute(g, M), h.push(l.x, l.y, l.z)
        }
        this.addAttribute("position", new En(h, 3))
    }

    function Ri(t, e, n) {
        mn.call(this), this.type = "ParametricGeometry", this.parameters = {
            func: t,
            slices: e,
            stacks: n
        }, this.fromBufferGeometry(new Ii(t, e, n)), this.mergeVertices()
    }

    function Ii(t, e, n) {
        zn.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
            func: t,
            slices: e,
            stacks: n
        };
        var r, i, o = [],
            a = [],
            s = [],
            c = [],
            u = new Ge,
            l = new Ge,
            h = new Ge,
            f = new Ge,
            d = new Ge;
        t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        var v = e + 1;
        for (r = 0; r <= n; r++) {
            var p = r / n;
            for (i = 0; i <= e; i++) {
                var m = i / e;
                t(m, p, l), a.push(l.x, l.y, l.z), m - 1e-5 >= 0 ? (t(m - 1e-5, p, h), f.subVectors(l, h)) : (t(m + 1e-5, p, h), f.subVectors(h, l)), p - 1e-5 >= 0 ? (t(m, p - 1e-5, h), d.subVectors(l, h)) : (t(m, p + 1e-5, h), d.subVectors(h, l)), u.crossVectors(f, d).normalize(), s.push(u.x, u.y, u.z), c.push(m, p)
            }
        }
        for (r = 0; r < n; r++)
            for (i = 0; i < e; i++) {
                var g = r * v + i,
                    y = r * v + i + 1,
                    x = (r + 1) * v + i + 1,
                    b = (r + 1) * v + i;
                o.push(g, y, b), o.push(y, x, b)
            }
        this.setIndex(o), this.addAttribute("position", new En(a, 3)), this.addAttribute("normal", new En(s, 3)), this.addAttribute("uv", new En(c, 2))
    }

    function Di(t, e, n, r) {
        mn.call(this), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: t,
            indices: e,
            radius: n,
            detail: r
        }, this.fromBufferGeometry(new Oi(t, e, n, r)), this.mergeVertices()
    }

    function Oi(t, e, n, r) {
        zn.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
            vertices: t,
            indices: e,
            radius: n,
            detail: r
        }, n = n || 1;
        var i = [],
            o = [];

        function a(t, e, n, r) {
            var i, o, a = Math.pow(2, r),
                c = [];
            for (i = 0; i <= a; i++) {
                c[i] = [];
                var u = t.clone().lerp(n, i / a),
                    l = e.clone().lerp(n, i / a),
                    h = a - i;
                for (o = 0; o <= h; o++) c[i][o] = 0 === o && i === a ? u : u.clone().lerp(l, o / h)
            }
            for (i = 0; i < a; i++)
                for (o = 0; o < 2 * (a - i) - 1; o++) {
                    var f = Math.floor(o / 2);
                    o % 2 == 0 ? (s(c[i][f + 1]), s(c[i + 1][f]), s(c[i][f])) : (s(c[i][f + 1]), s(c[i + 1][f + 1]), s(c[i + 1][f]))
                }
        }

        function s(t) {
            i.push(t.x, t.y, t.z)
        }

        function c(e, n) {
            var r = 3 * e;
            n.x = t[r + 0], n.y = t[r + 1], n.z = t[r + 2]
        }

        function u(t, e, n, r) {
            r < 0 && 1 === t.x && (o[e] = t.x - 1), 0 === n.x && 0 === n.z && (o[e] = r / 2 / Math.PI + .5)
        }

        function l(t) {
            return Math.atan2(t.z, -t.x)
        }

        function h(t) {
            return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
        }! function(t) {
            for (var n = new Ge, r = new Ge, i = new Ge, o = 0; o < e.length; o += 3) c(e[o + 0], n), c(e[o + 1], r), c(e[o + 2], i), a(n, r, i, t)
        }(r = r || 0),
        function(t) {
            for (var e = new Ge, n = 0; n < i.length; n += 3) e.x = i[n + 0], e.y = i[n + 1], e.z = i[n + 2], e.normalize().multiplyScalar(t), i[n + 0] = e.x, i[n + 1] = e.y, i[n + 2] = e.z
        }(n),
        function() {
            for (var t = new Ge, e = 0; e < i.length; e += 3) {
                t.x = i[e + 0], t.y = i[e + 1], t.z = i[e + 2];
                var n = l(t) / 2 / Math.PI + .5,
                    r = h(t) / Math.PI + .5;
                o.push(n, 1 - r)
            }(function() {
                for (var t = new Ge, e = new Ge, n = new Ge, r = new Ge, a = new Ue, s = new Ue, c = new Ue, h = 0, f = 0; h < i.length; h += 9, f += 6) {
                    t.set(i[h + 0], i[h + 1], i[h + 2]), e.set(i[h + 3], i[h + 4], i[h + 5]), n.set(i[h + 6], i[h + 7], i[h + 8]), a.set(o[f + 0], o[f + 1]), s.set(o[f + 2], o[f + 3]), c.set(o[f + 4], o[f + 5]), r.copy(t).add(e).add(n).divideScalar(3);
                    var d = l(r);
                    u(a, f + 0, t, d), u(s, f + 2, e, d), u(c, f + 4, n, d)
                }
            })(),
            function() {
                for (var t = 0; t < o.length; t += 6) {
                    var e = o[t + 0],
                        n = o[t + 2],
                        r = o[t + 4],
                        i = Math.max(e, n, r),
                        a = Math.min(e, n, r);
                    i > .9 && a < .1 && (e < .2 && (o[t + 0] += 1), n < .2 && (o[t + 2] += 1), r < .2 && (o[t + 4] += 1))
                }
            }()
        }(), this.addAttribute("position", new En(i, 3)), this.addAttribute("normal", new En(i.slice(), 3)), this.addAttribute("uv", new En(o, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals()
    }

    function Fi(t, e) {
        mn.call(this), this.type = "TetrahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new ji(t, e)), this.mergeVertices()
    }

    function ji(t, e) {
        Oi.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function ki(t, e) {
        mn.call(this), this.type = "OctahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new Ui(t, e)), this.mergeVertices()
    }

    function Ui(t, e) {
        Oi.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function Bi(t, e) {
        mn.call(this), this.type = "IcosahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new Ni(t, e)), this.mergeVertices()
    }

    function Ni(t, e) {
        var n = (1 + Math.sqrt(5)) / 2,
            r = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1];
        Oi.call(this, r, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function Gi(t, e) {
        mn.call(this), this.type = "DodecahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new Hi(t, e)), this.mergeVertices()
    }

    function Hi(t, e) {
        var n = (1 + Math.sqrt(5)) / 2,
            r = 1 / n,
            i = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r];
        Oi.call(this, i, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function Vi(t, e, n, r, i, o) {
        mn.call(this), this.type = "TubeGeometry", this.parameters = {
            path: t,
            tubularSegments: e,
            radius: n,
            radialSegments: r,
            closed: i
        }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
        var a = new Wi(t, e, n, r, i);
        this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices()
    }

    function Wi(t, e, n, r, i) {
        zn.call(this), this.type = "TubeBufferGeometry", this.parameters = {
            path: t,
            tubularSegments: e,
            radius: n,
            radialSegments: r,
            closed: i
        }, e = e || 64, n = n || 1, r = r || 8, i = i || !1;
        var o = t.computeFrenetFrames(e, i);
        this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
        var a, s, c = new Ge,
            u = new Ge,
            l = new Ue,
            h = new Ge,
            f = [],
            d = [],
            v = [],
            p = [];

        function m(i) {
            h = t.getPointAt(i / e, h);
            var a = o.normals[i],
                l = o.binormals[i];
            for (s = 0; s <= r; s++) {
                var v = s / r * Math.PI * 2,
                    p = Math.sin(v),
                    m = -Math.cos(v);
                u.x = m * a.x + p * l.x, u.y = m * a.y + p * l.y, u.z = m * a.z + p * l.z, u.normalize(), d.push(u.x, u.y, u.z), c.x = h.x + n * u.x, c.y = h.y + n * u.y, c.z = h.z + n * u.z, f.push(c.x, c.y, c.z)
            }
        }! function() {
            for (a = 0; a < e; a++) m(a);
            m(!1 === i ? e : 0),
                function() {
                    for (a = 0; a <= e; a++)
                        for (s = 0; s <= r; s++) l.x = a / e, l.y = s / r, v.push(l.x, l.y)
                }(),
                function() {
                    for (s = 1; s <= e; s++)
                        for (a = 1; a <= r; a++) {
                            var t = (r + 1) * (s - 1) + (a - 1),
                                n = (r + 1) * s + (a - 1),
                                i = (r + 1) * s + a,
                                o = (r + 1) * (s - 1) + a;
                            p.push(t, n, o), p.push(n, i, o)
                        }
                }()
        }(), this.setIndex(p), this.addAttribute("position", new En(f, 3)), this.addAttribute("normal", new En(d, 3)), this.addAttribute("uv", new En(v, 2))
    }

    function Yi(t, e, n, r, i, o, a) {
        mn.call(this), this.type = "TorusKnotGeometry", this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: n,
            radialSegments: r,
            p: i,
            q: o
        }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Xi(t, e, n, r, i, o)), this.mergeVertices()
    }

    function Xi(t, e, n, r, i, o) {
        zn.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: n,
            radialSegments: r,
            p: i,
            q: o
        }, t = t || 1, e = e || .4, n = Math.floor(n) || 64, r = Math.floor(r) || 8, i = i || 2, o = o || 3;
        var a, s, c = [],
            u = [],
            l = [],
            h = [],
            f = new Ge,
            d = new Ge,
            v = new Ge,
            p = new Ge,
            m = new Ge,
            g = new Ge,
            y = new Ge;
        for (a = 0; a <= n; ++a) {
            var x = a / n * i * Math.PI * 2;
            for (P(x, i, o, t, v), P(x + .01, i, o, t, p), g.subVectors(p, v), y.addVectors(p, v), m.crossVectors(g, y), y.crossVectors(m, g), m.normalize(), y.normalize(), s = 0; s <= r; ++s) {
                var b = s / r * Math.PI * 2,
                    w = -e * Math.cos(b),
                    _ = e * Math.sin(b);
                f.x = v.x + (w * y.x + _ * m.x), f.y = v.y + (w * y.y + _ * m.y), f.z = v.z + (w * y.z + _ * m.z), u.push(f.x, f.y, f.z), d.subVectors(f, v).normalize(), l.push(d.x, d.y, d.z), h.push(a / n), h.push(s / r)
            }
        }
        for (s = 1; s <= n; s++)
            for (a = 1; a <= r; a++) {
                var M = (r + 1) * (s - 1) + (a - 1),
                    S = (r + 1) * s + (a - 1),
                    E = (r + 1) * s + a,
                    T = (r + 1) * (s - 1) + a;
                c.push(M, S, T), c.push(S, E, T)
            }

        function P(t, e, n, r, i) {
            var o = Math.cos(t),
                a = Math.sin(t),
                s = n / e * t,
                c = Math.cos(s);
            i.x = r * (2 + c) * .5 * o, i.y = r * (2 + c) * a * .5, i.z = r * Math.sin(s) * .5
        }
        this.setIndex(c), this.addAttribute("position", new En(u, 3)), this.addAttribute("normal", new En(l, 3)), this.addAttribute("uv", new En(h, 2))
    }

    function qi(t, e, n, r, i) {
        mn.call(this), this.type = "TorusGeometry", this.parameters = {
            radius: t,
            tube: e,
            radialSegments: n,
            tubularSegments: r,
            arc: i
        }, this.fromBufferGeometry(new Ki(t, e, n, r, i)), this.mergeVertices()
    }

    function Ki(t, e, n, r, i) {
        zn.call(this), this.type = "TorusBufferGeometry", this.parameters = {
            radius: t,
            tube: e,
            radialSegments: n,
            tubularSegments: r,
            arc: i
        }, t = t || 1, e = e || .4, n = Math.floor(n) || 8, r = Math.floor(r) || 6, i = i || 2 * Math.PI;
        var o, a, s = [],
            c = [],
            u = [],
            l = [],
            h = new Ge,
            f = new Ge,
            d = new Ge;
        for (o = 0; o <= n; o++)
            for (a = 0; a <= r; a++) {
                var v = a / r * i,
                    p = o / n * Math.PI * 2;
                f.x = (t + e * Math.cos(p)) * Math.cos(v), f.y = (t + e * Math.cos(p)) * Math.sin(v), f.z = e * Math.sin(p), c.push(f.x, f.y, f.z), h.x = t * Math.cos(v), h.y = t * Math.sin(v), d.subVectors(f, h).normalize(), u.push(d.x, d.y, d.z), l.push(a / r), l.push(o / n)
            }
        for (o = 1; o <= n; o++)
            for (a = 1; a <= r; a++) {
                var m = (r + 1) * o + a - 1,
                    g = (r + 1) * (o - 1) + a - 1,
                    y = (r + 1) * (o - 1) + a,
                    x = (r + 1) * o + a;
                s.push(m, g, x), s.push(g, y, x)
            }
        this.setIndex(s), this.addAttribute("position", new En(c, 3)), this.addAttribute("normal", new En(u, 3)), this.addAttribute("uv", new En(l, 2))
    }
    $r.prototype = Object.create(Fn.prototype), $r.prototype.constructor = $r, $r.prototype.isMeshDepthMaterial = !0, $r.prototype.copy = function(t) {
        return Fn.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
    }, ti.prototype = Object.create(Fn.prototype), ti.prototype.constructor = ti, ti.prototype.isMeshDistanceMaterial = !0, ti.prototype.copy = function(t) {
        return Fn.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
    }, ii.prototype = Object.assign(Object.create(vn.prototype), {
        constructor: ii,
        isGroup: !0
    }), oi.prototype = Object.assign(Object.create(vn.prototype), {
        constructor: oi,
        isCamera: !0,
        copy: function(t, e) {
            return vn.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
        },
        getWorldDirection: function(t) {
            void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new Ge), this.updateMatrixWorld(!0);
            var e = this.matrixWorld.elements;
            return t.set(-e[8], -e[9], -e[10]).normalize()
        },
        updateMatrixWorld: function(t) {
            vn.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }), ai.prototype = Object.assign(Object.create(oi.prototype), {
        constructor: ai,
        isPerspectiveCamera: !0,
        copy: function(t, e) {
            return oi.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
        },
        setFocalLength: function(t) {
            var e = .5 * this.getFilmHeight() / t;
            this.fov = 2 * ke.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            var t = Math.tan(.5 * ke.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / t
        },
        getEffectiveFOV: function() {
            return 2 * ke.RAD2DEG * Math.atan(Math.tan(.5 * ke.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(t, e, n, r, i, o) {
            this.aspect = t / e, null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var t = this.near,
                e = t * Math.tan(.5 * ke.DEG2RAD * this.fov) / this.zoom,
                n = 2 * e,
                r = this.aspect * n,
                i = -.5 * r,
                o = this.view;
            if (null !== this.view && this.view.enabled) {
                var a = o.fullWidth,
                    s = o.fullHeight;
                i += o.offsetX * r / a, e -= o.offsetY * n / s, r *= o.width / a, n *= o.height / s
            }
            var c = this.filmOffset;
            0 !== c && (i += t * c / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, e, e - n, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(t) {
            var e = vn.prototype.toJSON.call(this, t);
            return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
        }
    }), si.prototype = Object.assign(Object.create(ai.prototype), {
        constructor: si,
        isArrayCamera: !0
    }), li.prototype.isFogExp2 = !0, li.prototype.clone = function() {
        return new li(this.color, this.density)
    }, li.prototype.toJSON = function() {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        }
    }, hi.prototype.isFog = !0, hi.prototype.clone = function() {
        return new hi(this.color, this.near, this.far)
    }, hi.prototype.toJSON = function() {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }, fi.prototype = Object.assign(Object.create(vn.prototype), {
        constructor: fi,
        copy: function(t, e) {
            return vn.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
        },
        toJSON: function(t) {
            var e = vn.prototype.toJSON.call(this, t);
            return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
        }
    }), Object.defineProperty(di.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }), Object.assign(di.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function() {},
        setArray: function(t) {
            if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t, this
        },
        setDynamic: function(t) {
            return this.dynamic = t, this
        },
        copy: function(t) {
            return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this
        },
        copyAt: function(t, e, n) {
            t *= this.stride, n *= e.stride;
            for (var r = 0, i = this.stride; r < i; r++) this.array[t + r] = e.array[n + r];
            return this
        },
        set: function(t, e) {
            return void 0 === e && (e = 0), this.array.set(t, e), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        onUpload: function(t) {
            return this.onUploadCallback = t, this
        }
    }), Object.defineProperties(vi.prototype, {
        count: {
            get: function() {
                return this.data.count
            }
        },
        array: {
            get: function() {
                return this.data.array
            }
        }
    }), Object.assign(vi.prototype, {
        isInterleavedBufferAttribute: !0,
        setX: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset] = e, this
        },
        setY: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 1] = e, this
        },
        setZ: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 2] = e, this
        },
        setW: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 3] = e, this
        },
        getX: function(t) {
            return this.data.array[t * this.data.stride + this.offset]
        },
        getY: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 1]
        },
        getZ: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 2]
        },
        getW: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 3]
        },
        setXY: function(t, e, n) {
            return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
        },
        setXYZ: function(t, e, n, r) {
            return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this
        },
        setXYZW: function(t, e, n, r, i) {
            return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this.data.array[t + 3] = i, this
        }
    }), pi.prototype = Object.create(Fn.prototype), pi.prototype.constructor = pi, pi.prototype.isSpriteMaterial = !0, pi.prototype.copy = function(t) {
        return Fn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
    }, mi.prototype = Object.assign(Object.create(vn.prototype), {
        constructor: mi,
        isSprite: !0,
        raycast: function() {
            var t = new Ge,
                e = new Ge,
                n = new Ge,
                r = new Ue,
                i = new Ue,
                o = new Be,
                a = new Ge,
                s = new Ge,
                c = new Ge,
                u = new Ue,
                l = new Ue,
                h = new Ue;

            function f(t, e, n, a, s, c) {
                r.subVectors(t, n).addScalar(.5).multiply(a), void 0 !== s ? (i.x = c * r.x - s * r.y, i.y = s * r.x + c * r.y) : i.copy(r), t.copy(e), t.x += i.x, t.y += i.y, t.applyMatrix4(o)
            }
            return function(r, i) {
                e.setFromMatrixScale(this.matrixWorld), o.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), n.setFromMatrixPosition(this.modelViewMatrix);
                var d, v, p = this.material.rotation;
                0 !== p && (v = Math.cos(p), d = Math.sin(p));
                var m = this.center;
                f(a.set(-.5, -.5, 0), n, m, e, d, v), f(s.set(.5, -.5, 0), n, m, e, d, v), f(c.set(.5, .5, 0), n, m, e, d, v), u.set(0, 0), l.set(1, 0), h.set(1, 1);
                var g = r.ray.intersectTriangle(a, s, c, !1, t);
                if (null !== g || (f(s.set(-.5, .5, 0), n, m, e, d, v), l.set(0, 1), null !== (g = r.ray.intersectTriangle(a, c, s, !1, t)))) {
                    var y = r.ray.origin.distanceTo(t);
                    y < r.near || y > r.far || i.push({
                        distance: y,
                        point: t.clone(),
                        uv: Un.getUV(t, a, s, c, u, l, h, new Ue),
                        face: null,
                        object: this
                    })
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.material).copy(this)
        },
        copy: function(t) {
            return vn.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this
        }
    }), gi.prototype = Object.assign(Object.create(vn.prototype), {
        constructor: gi,
        copy: function(t) {
            vn.prototype.copy.call(this, t, !1);
            for (var e = t.levels, n = 0, r = e.length; n < r; n++) {
                var i = e[n];
                this.addLevel(i.object.clone(), i.distance)
            }
            return this
        },
        addLevel: function(t, e) {
            void 0 === e && (e = 0), e = Math.abs(e);
            for (var n = this.levels, r = 0; r < n.length && !(e < n[r].distance); r++);
            n.splice(r, 0, {
                distance: e,
                object: t
            }), this.add(t)
        },
        getObjectForDistance: function(t) {
            for (var e = this.levels, n = 1, r = e.length; n < r && !(t < e[n].distance); n++);
            return e[n - 1].object
        },
        raycast: function() {
            var t = new Ge;
            return function(e, n) {
                t.setFromMatrixPosition(this.matrixWorld);
                var r = e.ray.origin.distanceTo(t);
                this.getObjectForDistance(r).raycast(e, n)
            }
        }(),
        update: function() {
            var t = new Ge,
                e = new Ge;
            return function(n) {
                var r = this.levels;
                if (r.length > 1) {
                    t.setFromMatrixPosition(n.matrixWorld), e.setFromMatrixPosition(this.matrixWorld);
                    var i = t.distanceTo(e);
                    r[0].object.visible = !0;
                    for (var o = 1, a = r.length; o < a && i >= r[o].distance; o++) r[o - 1].object.visible = !1, r[o].object.visible = !0;
                    for (; o < a; o++) r[o].object.visible = !1
                }
            }
        }(),
        toJSON: function(t) {
            var e = vn.prototype.toJSON.call(this, t);
            e.object.levels = [];
            for (var n = this.levels, r = 0, i = n.length; r < i; r++) {
                var o = n[r];
                e.object.levels.push({
                    object: o.object.uuid,
                    distance: o.distance
                })
            }
            return e
        }
    }), Object.assign(yi.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var t = 0, e = this.bones.length; t < e; t++) {
                var n = new Be;
                this.bones[t] && n.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(n)
            }
        },
        pose: function() {
            var t, e, n;
            for (e = 0, n = this.bones.length; e < n; e++)(t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
            for (e = 0, n = this.bones.length; e < n; e++)(t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
        },
        update: function() {
            var t = new Be,
                e = new Be;
            return function() {
                for (var n = this.bones, r = this.boneInverses, i = this.boneMatrices, o = this.boneTexture, a = 0, s = n.length; a < s; a++) {
                    var c = n[a] ? n[a].matrixWorld : e;
                    t.multiplyMatrices(c, r[a]), t.toArray(i, 16 * a)
                }
                void 0 !== o && (o.needsUpdate = !0)
            }
        }(),
        clone: function() {
            return new yi(this.bones, this.boneInverses)
        },
        getBoneByName: function(t) {
            for (var e = 0, n = this.bones.length; e < n; e++) {
                var r = this.bones[e];
                if (r.name === t) return r
            }
        }
    }), xi.prototype = Object.assign(Object.create(vn.prototype), {
        constructor: xi,
        isBone: !0
    }), bi.prototype = Object.assign(Object.create(Nn.prototype), {
        constructor: bi,
        isSkinnedMesh: !0,
        initBones: function() {
            var t, e, n, r, i = [];
            if (this.geometry && void 0 !== this.geometry.bones) {
                for (n = 0, r = this.geometry.bones.length; n < r; n++) e = this.geometry.bones[n], t = new xi, i.push(t), t.name = e.name, t.position.fromArray(e.pos), t.quaternion.fromArray(e.rotq), void 0 !== e.scl && t.scale.fromArray(e.scl);
                for (n = 0, r = this.geometry.bones.length; n < r; n++) - 1 !== (e = this.geometry.bones[n]).parent && null !== e.parent && void 0 !== i[e.parent] ? i[e.parent].add(i[n]) : this.add(i[n])
            }
            return this.updateMatrixWorld(!0), i
        },
        bind: function(t, e) {
            this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            var t, e;
            if (this.geometry && this.geometry.isGeometry)
                for (e = 0; e < this.geometry.skinWeights.length; e++) {
                    var n = this.geometry.skinWeights[e];
                    (t = 1 / n.manhattanLength()) !== 1 / 0 ? n.multiplyScalar(t) : n.set(1, 0, 0, 0)
                } else if (this.geometry && this.geometry.isBufferGeometry) {
                    var r = new Xe,
                        i = this.geometry.attributes.skinWeight;
                    for (e = 0; e < i.count; e++) r.x = i.getX(e), r.y = i.getY(e), r.z = i.getZ(e), r.w = i.getW(e), (t = 1 / r.manhattanLength()) !== 1 / 0 ? r.multiplyScalar(t) : r.set(1, 0, 0, 0), i.setXYZW(e, r.x, r.y, r.z, r.w)
                }
        },
        updateMatrixWorld: function(t) {
            Nn.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), wi.prototype = Object.create(Fn.prototype), wi.prototype.constructor = wi, wi.prototype.isLineBasicMaterial = !0, wi.prototype.copy = function(t) {
        return Fn.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
    }, _i.prototype = Object.assign(Object.create(vn.prototype), {
        constructor: _i,
        isLine: !0,
        computeLineDistances: function() {
            var t = new Ge,
                e = new Ge;
            return function() {
                var n = this.geometry;
                if (n.isBufferGeometry)
                    if (null === n.index) {
                        for (var r = n.attributes.position, i = [0], o = 1, a = r.count; o < a; o++) t.fromBufferAttribute(r, o - 1), e.fromBufferAttribute(r, o), i[o] = i[o - 1], i[o] += t.distanceTo(e);
                        n.addAttribute("lineDistance", new En(i, 1))
                    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (n.isGeometry) {
                    var s = n.vertices;
                    (i = n.lineDistances)[0] = 0;
                    for (o = 1, a = s.length; o < a; o++) i[o] = i[o - 1], i[o] += s[o - 1].distanceTo(s[o])
                }
                return this
            }
        }(),
        raycast: function() {
            var t = new Be,
                e = new kn,
                n = new Qe;
            return function(r, i) {
                var o = r.linePrecision,
                    a = this.geometry,
                    s = this.matrixWorld;
                if (null === a.boundingSphere && a.computeBoundingSphere(), n.copy(a.boundingSphere), n.applyMatrix4(s), n.radius += o, !1 !== r.ray.intersectsSphere(n)) {
                    t.getInverse(s), e.copy(r.ray).applyMatrix4(t);
                    var c = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        u = c * c,
                        l = new Ge,
                        h = new Ge,
                        f = new Ge,
                        d = new Ge,
                        v = this && this.isLineSegments ? 2 : 1;
                    if (a.isBufferGeometry) {
                        var p = a.index,
                            m = a.attributes.position.array;
                        if (null !== p)
                            for (var g = p.array, y = 0, x = g.length - 1; y < x; y += v) {
                                var b = g[y],
                                    w = g[y + 1];
                                if (l.fromArray(m, 3 * b), h.fromArray(m, 3 * w), !(e.distanceSqToSegment(l, h, d, f) > u)) d.applyMatrix4(this.matrixWorld), (S = r.ray.origin.distanceTo(d)) < r.near || S > r.far || i.push({
                                    distance: S,
                                    point: f.clone().applyMatrix4(this.matrixWorld),
                                    index: y,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            } else
                                for (y = 0, x = m.length / 3 - 1; y < x; y += v) {
                                    if (l.fromArray(m, 3 * y), h.fromArray(m, 3 * y + 3), !(e.distanceSqToSegment(l, h, d, f) > u)) d.applyMatrix4(this.matrixWorld), (S = r.ray.origin.distanceTo(d)) < r.near || S > r.far || i.push({
                                        distance: S,
                                        point: f.clone().applyMatrix4(this.matrixWorld),
                                        index: y,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                    } else if (a.isGeometry) {
                        var _ = a.vertices,
                            M = _.length;
                        for (y = 0; y < M - 1; y += v) {
                            var S;
                            if (!(e.distanceSqToSegment(_[y], _[y + 1], d, f) > u)) d.applyMatrix4(this.matrixWorld), (S = r.ray.origin.distanceTo(d)) < r.near || S > r.far || i.push({
                                distance: S,
                                point: f.clone().applyMatrix4(this.matrixWorld),
                                index: y,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    }
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), Mi.prototype = Object.assign(Object.create(_i.prototype), {
        constructor: Mi,
        isLineSegments: !0,
        computeLineDistances: function() {
            var t = new Ge,
                e = new Ge;
            return function() {
                var n = this.geometry;
                if (n.isBufferGeometry)
                    if (null === n.index) {
                        for (var r = n.attributes.position, i = [], o = 0, a = r.count; o < a; o += 2) t.fromBufferAttribute(r, o), e.fromBufferAttribute(r, o + 1), i[o] = 0 === o ? 0 : i[o - 1], i[o + 1] = i[o] + t.distanceTo(e);
                        n.addAttribute("lineDistance", new En(i, 1))
                    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (n.isGeometry) {
                    var s = n.vertices;
                    for (i = n.lineDistances, o = 0, a = s.length; o < a; o += 2) t.copy(s[o]), e.copy(s[o + 1]), i[o] = 0 === o ? 0 : i[o - 1], i[o + 1] = i[o] + t.distanceTo(e)
                }
                return this
            }
        }()
    }), Si.prototype = Object.assign(Object.create(_i.prototype), {
        constructor: Si,
        isLineLoop: !0
    }), Ei.prototype = Object.create(Fn.prototype), Ei.prototype.constructor = Ei, Ei.prototype.isPointsMaterial = !0, Ei.prototype.copy = function(t) {
        return Fn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
    }, Ti.prototype = Object.assign(Object.create(vn.prototype), {
        constructor: Ti,
        isPoints: !0,
        raycast: function() {
            var t = new Be,
                e = new kn,
                n = new Qe;
            return function(r, i) {
                var o = this,
                    a = this.geometry,
                    s = this.matrixWorld,
                    c = r.params.Points.threshold;
                if (null === a.boundingSphere && a.computeBoundingSphere(), n.copy(a.boundingSphere), n.applyMatrix4(s), n.radius += c, !1 !== r.ray.intersectsSphere(n)) {
                    t.getInverse(s), e.copy(r.ray).applyMatrix4(t);
                    var u = c / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        l = u * u,
                        h = new Ge,
                        f = new Ge;
                    if (a.isBufferGeometry) {
                        var d = a.index,
                            v = a.attributes.position.array;
                        if (null !== d)
                            for (var p = d.array, m = 0, g = p.length; m < g; m++) {
                                var y = p[m];
                                h.fromArray(v, 3 * y), w(h, y)
                            } else {
                                m = 0;
                                for (var x = v.length / 3; m < x; m++) h.fromArray(v, 3 * m), w(h, m)
                            }
                    } else {
                        var b = a.vertices;
                        for (m = 0, x = b.length; m < x; m++) w(b[m], m)
                    }
                }

                function w(t, n) {
                    var a = e.distanceSqToPoint(t);
                    if (a < l) {
                        e.closestPointToPoint(t, f), f.applyMatrix4(s);
                        var c = r.ray.origin.distanceTo(f);
                        if (c < r.near || c > r.far) return;
                        i.push({
                            distance: c,
                            distanceToRay: Math.sqrt(a),
                            point: f.clone(),
                            index: n,
                            face: null,
                            object: o
                        })
                    }
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), Pi.prototype = Object.assign(Object.create(Ye.prototype), {
        constructor: Pi,
        isVideoTexture: !0,
        update: function() {
            var t = this.image;
            t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }), Li.prototype = Object.create(Ye.prototype), Li.prototype.constructor = Li, Li.prototype.isCompressedTexture = !0, Ai.prototype = Object.create(Ye.prototype), Ai.prototype.constructor = Ai, Ai.prototype.isCanvasTexture = !0, zi.prototype = Object.create(Ye.prototype), zi.prototype.constructor = zi, zi.prototype.isDepthTexture = !0, Ci.prototype = Object.create(zn.prototype), Ci.prototype.constructor = Ci, Ri.prototype = Object.create(mn.prototype), Ri.prototype.constructor = Ri, Ii.prototype = Object.create(zn.prototype), Ii.prototype.constructor = Ii, Di.prototype = Object.create(mn.prototype), Di.prototype.constructor = Di, Oi.prototype = Object.create(zn.prototype), Oi.prototype.constructor = Oi, Fi.prototype = Object.create(mn.prototype), Fi.prototype.constructor = Fi, ji.prototype = Object.create(Oi.prototype), ji.prototype.constructor = ji, ki.prototype = Object.create(mn.prototype), ki.prototype.constructor = ki, Ui.prototype = Object.create(Oi.prototype), Ui.prototype.constructor = Ui, Bi.prototype = Object.create(mn.prototype), Bi.prototype.constructor = Bi, Ni.prototype = Object.create(Oi.prototype), Ni.prototype.constructor = Ni, Gi.prototype = Object.create(mn.prototype), Gi.prototype.constructor = Gi, Hi.prototype = Object.create(Oi.prototype), Hi.prototype.constructor = Hi, Vi.prototype = Object.create(mn.prototype), Vi.prototype.constructor = Vi, Wi.prototype = Object.create(zn.prototype), Wi.prototype.constructor = Wi, Yi.prototype = Object.create(mn.prototype), Yi.prototype.constructor = Yi, Xi.prototype = Object.create(zn.prototype), Xi.prototype.constructor = Xi, qi.prototype = Object.create(mn.prototype), qi.prototype.constructor = qi, Ki.prototype = Object.create(zn.prototype), Ki.prototype.constructor = Ki;
    var Zi = function(t, e, n) {
        n = n || 2;
        var r, i, o, a, s, c, u, l = e && e.length,
            h = l ? e[0] * n : t.length,
            f = Ji(t, 0, h, n, !0),
            d = [];
        if (!f) return d;
        if (l && (f = function(t, e, n, r) {
                var i, o, a, s, c, u = [];
                for (i = 0, o = e.length; i < o; i++) a = e[i] * r, s = i < o - 1 ? e[i + 1] * r : t.length, (c = Ji(t, a, s, r, !1)) === c.next && (c.steiner = !0), u.push(so(c));
                for (u.sort(io), i = 0; i < u.length; i++) oo(u[i], n), n = Qi(n, n.next);
                return n
            }(t, e, f, n)), t.length > 80 * n) {
            r = o = t[0], i = a = t[1];
            for (var v = n; v < h; v += n) s = t[v], c = t[v + 1], s < r && (r = s), c < i && (i = c), s > o && (o = s), c > a && (a = c);
            u = 0 !== (u = Math.max(o - r, a - i)) ? 1 / u : 0
        }
        return $i(f, d, n, r, i, u), d
    };

    function Ji(t, e, n, r, i) {
        var o, a;
        if (i === function(t, e, n, r) {
                for (var i = 0, o = e, a = n - r; o < n; o += r) i += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o;
                return i
            }(t, e, n, r) > 0)
            for (o = e; o < n; o += r) a = mo(o, t[o], t[o + 1], a);
        else
            for (o = n - r; o >= e; o -= r) a = mo(o, t[o], t[o + 1], a);
        return a && ho(a, a.next) && (go(a), a = a.next), a
    }

    function Qi(t, e) {
        if (!t) return t;
        e || (e = t);
        var n, r = t;
        do {
            if (n = !1, r.steiner || !ho(r, r.next) && 0 !== lo(r.prev, r, r.next)) r = r.next;
            else {
                if (go(r), (r = e = r.prev) === r.next) break;
                n = !0
            }
        } while (n || r !== e);
        return e
    }

    function $i(t, e, n, r, i, o, a) {
        if (t) {
            !a && o && function(t, e, n, r) {
                var i = t;
                do {
                    null === i.z && (i.z = ao(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next
                } while (i !== t);
                i.prevZ.nextZ = null, i.prevZ = null,
                    function(t) {
                        var e, n, r, i, o, a, s, c, u = 1;
                        do {
                            for (n = t, t = null, o = null, a = 0; n;) {
                                for (a++, r = n, s = 0, e = 0; e < u && (s++, r = r.nextZ); e++);
                                for (c = u; s > 0 || c > 0 && r;) 0 !== s && (0 === c || !r || n.z <= r.z) ? (i = n, n = n.nextZ, s--) : (i = r, r = r.nextZ, c--), o ? o.nextZ = i : t = i, i.prevZ = o, o = i;
                                n = r
                            }
                            o.nextZ = null, u *= 2
                        } while (a > 1)
                    }(i)
            }(t, r, i, o);
            for (var s, c, u = t; t.prev !== t.next;)
                if (s = t.prev, c = t.next, o ? eo(t, r, i, o) : to(t)) e.push(s.i / n), e.push(t.i / n), e.push(c.i / n), go(t), t = c.next, u = c.next;
                else if ((t = c) === u) {
                a ? 1 === a ? $i(t = no(t, e, n), e, n, r, i, o, 2) : 2 === a && ro(t, e, n, r, i, o) : $i(Qi(t), e, n, r, i, o, 1);
                break
            }
        }
    }

    function to(t) {
        var e = t.prev,
            n = t,
            r = t.next;
        if (lo(e, n, r) >= 0) return !1;
        for (var i = t.next.next; i !== t.prev;) {
            if (co(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) && lo(i.prev, i, i.next) >= 0) return !1;
            i = i.next
        }
        return !0
    }

    function eo(t, e, n, r) {
        var i = t.prev,
            o = t,
            a = t.next;
        if (lo(i, o, a) >= 0) return !1;
        for (var s = i.x < o.x ? i.x < a.x ? i.x : a.x : o.x < a.x ? o.x : a.x, c = i.y < o.y ? i.y < a.y ? i.y : a.y : o.y < a.y ? o.y : a.y, u = i.x > o.x ? i.x > a.x ? i.x : a.x : o.x > a.x ? o.x : a.x, l = i.y > o.y ? i.y > a.y ? i.y : a.y : o.y > a.y ? o.y : a.y, h = ao(s, c, e, n, r), f = ao(u, l, e, n, r), d = t.nextZ; d && d.z <= f;) {
            if (d !== t.prev && d !== t.next && co(i.x, i.y, o.x, o.y, a.x, a.y, d.x, d.y) && lo(d.prev, d, d.next) >= 0) return !1;
            d = d.nextZ
        }
        for (d = t.prevZ; d && d.z >= h;) {
            if (d !== t.prev && d !== t.next && co(i.x, i.y, o.x, o.y, a.x, a.y, d.x, d.y) && lo(d.prev, d, d.next) >= 0) return !1;
            d = d.prevZ
        }
        return !0
    }

    function no(t, e, n) {
        var r = t;
        do {
            var i = r.prev,
                o = r.next.next;
            !ho(i, o) && fo(i, r, r.next, o) && vo(i, o) && vo(o, i) && (e.push(i.i / n), e.push(r.i / n), e.push(o.i / n), go(r), go(r.next), r = t = o), r = r.next
        } while (r !== t);
        return r
    }

    function ro(t, e, n, r, i, o) {
        var a = t;
        do {
            for (var s = a.next.next; s !== a.prev;) {
                if (a.i !== s.i && uo(a, s)) {
                    var c = po(a, s);
                    return a = Qi(a, a.next), c = Qi(c, c.next), $i(a, e, n, r, i, o), void $i(c, e, n, r, i, o)
                }
                s = s.next
            }
            a = a.next
        } while (a !== t)
    }

    function io(t, e) {
        return t.x - e.x
    }

    function oo(t, e) {
        if (e = function(t, e) {
                var n, r = e,
                    i = t.x,
                    o = t.y,
                    a = -1 / 0;
                do {
                    if (o <= r.y && o >= r.next.y && r.next.y !== r.y) {
                        var s = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                        if (s <= i && s > a) {
                            if (a = s, s === i) {
                                if (o === r.y) return r;
                                if (o === r.next.y) return r.next
                            }
                            n = r.x < r.next.x ? r : r.next
                        }
                    }
                    r = r.next
                } while (r !== e);
                if (!n) return null;
                if (i === a) return n.prev;
                var c, u = n,
                    l = n.x,
                    h = n.y,
                    f = 1 / 0;
                r = n.next;
                for (; r !== u;) i >= r.x && r.x >= l && i !== r.x && co(o < h ? i : a, o, l, h, o < h ? a : i, o, r.x, r.y) && ((c = Math.abs(o - r.y) / (i - r.x)) < f || c === f && r.x > n.x) && vo(r, t) && (n = r, f = c), r = r.next;
                return n
            }(t, e)) {
            var n = po(e, t);
            Qi(n, n.next)
        }
    }

    function ao(t, e, n, r, i) {
        return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
    }

    function so(t) {
        var e = t,
            n = t;
        do {
            e.x < n.x && (n = e), e = e.next
        } while (e !== t);
        return n
    }

    function co(t, e, n, r, i, o, a, s) {
        return (i - a) * (e - s) - (t - a) * (o - s) >= 0 && (t - a) * (r - s) - (n - a) * (e - s) >= 0 && (n - a) * (o - s) - (i - a) * (r - s) >= 0
    }

    function uo(t, e) {
        return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
            var n = t;
            do {
                if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && fo(n, n.next, t, e)) return !0;
                n = n.next
            } while (n !== t);
            return !1
        }(t, e) && vo(t, e) && vo(e, t) && function(t, e) {
            var n = t,
                r = !1,
                i = (t.x + e.x) / 2,
                o = (t.y + e.y) / 2;
            do {
                n.y > o != n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next
            } while (n !== t);
            return r
        }(t, e)
    }

    function lo(t, e, n) {
        return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
    }

    function ho(t, e) {
        return t.x === e.x && t.y === e.y
    }

    function fo(t, e, n, r) {
        return !!(ho(t, e) && ho(n, r) || ho(t, r) && ho(n, e)) || lo(t, e, n) > 0 != lo(t, e, r) > 0 && lo(n, r, t) > 0 != lo(n, r, e) > 0
    }

    function vo(t, e) {
        return lo(t.prev, t, t.next) < 0 ? lo(t, e, t.next) >= 0 && lo(t, t.prev, e) >= 0 : lo(t, e, t.prev) < 0 || lo(t, t.next, e) < 0
    }

    function po(t, e) {
        var n = new yo(t.i, t.x, t.y),
            r = new yo(e.i, e.x, e.y),
            i = t.next,
            o = e.prev;
        return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r
    }

    function mo(t, e, n, r) {
        var i = new yo(t, e, n);
        return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
    }

    function go(t) {
        t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
    }

    function yo(t, e, n) {
        this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
    }
    var xo = {
        area: function(t) {
            for (var e = t.length, n = 0, r = e - 1, i = 0; i < e; r = i++) n += t[r].x * t[i].y - t[i].x * t[r].y;
            return .5 * n
        },
        isClockWise: function(t) {
            return xo.area(t) < 0
        },
        triangulateShape: function(t, e) {
            var n = [],
                r = [],
                i = [];
            bo(t), wo(n, t);
            var o = t.length;
            e.forEach(bo);
            for (var a = 0; a < e.length; a++) r.push(o), o += e[a].length, wo(n, e[a]);
            var s = Zi(n, r);
            for (a = 0; a < s.length; a += 3) i.push(s.slice(a, a + 3));
            return i
        }
    };

    function bo(t) {
        var e = t.length;
        e > 2 && t[e - 1].equals(t[0]) && t.pop()
    }

    function wo(t, e) {
        for (var n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
    }

    function _o(t, e) {
        mn.call(this), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: t,
            options: e
        }, this.fromBufferGeometry(new Mo(t, e)), this.mergeVertices()
    }

    function Mo(t, e) {
        zn.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
            shapes: t,
            options: e
        };
        for (var n = this, r = [], i = [], o = 0, a = (t = Array.isArray(t) ? t : [t]).length; o < a; o++) {
            s(t[o])
        }

        function s(t) {
            var o = [],
                a = void 0 !== e.curveSegments ? e.curveSegments : 12,
                s = void 0 !== e.steps ? e.steps : 1,
                c = void 0 !== e.depth ? e.depth : 100,
                u = void 0 === e.bevelEnabled || e.bevelEnabled,
                l = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                h = void 0 !== e.bevelSize ? e.bevelSize : l - 2,
                f = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
                d = e.extrudePath,
                v = void 0 !== e.UVGenerator ? e.UVGenerator : So;
            void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), c = e.amount);
            var p, m, g, y, x, b, w, _, M = !1;
            d && (p = d.getSpacedPoints(s), M = !0, u = !1, m = d.computeFrenetFrames(s, !1), g = new Ge, y = new Ge, x = new Ge), u || (f = 0, l = 0, h = 0);
            var S = t.extractPoints(a),
                E = S.shape,
                T = S.holes;
            if (!xo.isClockWise(E))
                for (E = E.reverse(), w = 0, _ = T.length; w < _; w++) b = T[w], xo.isClockWise(b) && (T[w] = b.reverse());
            var P = xo.triangulateShape(E, T),
                L = E;
            for (w = 0, _ = T.length; w < _; w++) b = T[w], E = E.concat(b);

            function A(t, e, n) {
                return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t)
            }
            var z, C, R, I, D, O, F = E.length,
                j = P.length;

            function k(t, e, n) {
                var r, i, o, a = t.x - e.x,
                    s = t.y - e.y,
                    c = n.x - t.x,
                    u = n.y - t.y,
                    l = a * a + s * s,
                    h = a * u - s * c;
                if (Math.abs(h) > Number.EPSILON) {
                    var f = Math.sqrt(l),
                        d = Math.sqrt(c * c + u * u),
                        v = e.x - s / f,
                        p = e.y + a / f,
                        m = ((n.x - u / d - v) * u - (n.y + c / d - p) * c) / (a * u - s * c),
                        g = (r = v + a * m - t.x) * r + (i = p + s * m - t.y) * i;
                    if (g <= 2) return new Ue(r, i);
                    o = Math.sqrt(g / 2)
                } else {
                    var y = !1;
                    a > Number.EPSILON ? c > Number.EPSILON && (y = !0) : a < -Number.EPSILON ? c < -Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(u) && (y = !0), y ? (r = -s, i = a, o = Math.sqrt(l)) : (r = a, i = s, o = Math.sqrt(l / 2))
                }
                return new Ue(r / o, i / o)
            }
            for (var U = [], B = 0, N = L.length, G = N - 1, H = B + 1; B < N; B++, G++, H++) G === N && (G = 0), H === N && (H = 0), U[B] = k(L[B], L[G], L[H]);
            var V, W, Y = [],
                X = U.concat();
            for (w = 0, _ = T.length; w < _; w++) {
                for (b = T[w], V = [], B = 0, G = (N = b.length) - 1, H = B + 1; B < N; B++, G++, H++) G === N && (G = 0), H === N && (H = 0), V[B] = k(b[B], b[G], b[H]);
                Y.push(V), X = X.concat(V)
            }
            for (z = 0; z < f; z++) {
                for (R = z / f, I = l * Math.cos(R * Math.PI / 2), C = h * Math.sin(R * Math.PI / 2), B = 0, N = L.length; B < N; B++) K((D = A(L[B], U[B], C)).x, D.y, -I);
                for (w = 0, _ = T.length; w < _; w++)
                    for (b = T[w], V = Y[w], B = 0, N = b.length; B < N; B++) K((D = A(b[B], V[B], C)).x, D.y, -I)
            }
            for (C = h, B = 0; B < F; B++) D = u ? A(E[B], X[B], C) : E[B], M ? (y.copy(m.normals[0]).multiplyScalar(D.x), g.copy(m.binormals[0]).multiplyScalar(D.y), x.copy(p[0]).add(y).add(g), K(x.x, x.y, x.z)) : K(D.x, D.y, 0);
            for (W = 1; W <= s; W++)
                for (B = 0; B < F; B++) D = u ? A(E[B], X[B], C) : E[B], M ? (y.copy(m.normals[W]).multiplyScalar(D.x), g.copy(m.binormals[W]).multiplyScalar(D.y), x.copy(p[W]).add(y).add(g), K(x.x, x.y, x.z)) : K(D.x, D.y, c / s * W);
            for (z = f - 1; z >= 0; z--) {
                for (R = z / f, I = l * Math.cos(R * Math.PI / 2), C = h * Math.sin(R * Math.PI / 2), B = 0, N = L.length; B < N; B++) K((D = A(L[B], U[B], C)).x, D.y, c + I);
                for (w = 0, _ = T.length; w < _; w++)
                    for (b = T[w], V = Y[w], B = 0, N = b.length; B < N; B++) D = A(b[B], V[B], C), M ? K(D.x, D.y + p[s - 1].y, p[s - 1].x + I) : K(D.x, D.y, c + I)
            }

            function q(t, e) {
                var n, r;
                for (B = t.length; --B >= 0;) {
                    n = B, (r = B - 1) < 0 && (r = t.length - 1);
                    var i = 0,
                        o = s + 2 * f;
                    for (i = 0; i < o; i++) {
                        var a = F * i,
                            c = F * (i + 1);
                        J(e + n + a, e + r + a, e + r + c, e + n + c)
                    }
                }
            }

            function K(t, e, n) {
                o.push(t), o.push(e), o.push(n)
            }

            function Z(t, e, i) {
                Q(t), Q(e), Q(i);
                var o = r.length / 3,
                    a = v.generateTopUV(n, r, o - 3, o - 2, o - 1);
                $(a[0]), $(a[1]), $(a[2])
            }

            function J(t, e, i, o) {
                Q(t), Q(e), Q(o), Q(e), Q(i), Q(o);
                var a = r.length / 3,
                    s = v.generateSideWallUV(n, r, a - 6, a - 3, a - 2, a - 1);
                $(s[0]), $(s[1]), $(s[3]), $(s[1]), $(s[2]), $(s[3])
            }

            function Q(t) {
                r.push(o[3 * t + 0]), r.push(o[3 * t + 1]), r.push(o[3 * t + 2])
            }

            function $(t) {
                i.push(t.x), i.push(t.y)
            }! function() {
                var t = r.length / 3;
                if (u) {
                    var e = 0,
                        i = F * e;
                    for (B = 0; B < j; B++) Z((O = P[B])[2] + i, O[1] + i, O[0] + i);
                    for (i = F * (e = s + 2 * f), B = 0; B < j; B++) Z((O = P[B])[0] + i, O[1] + i, O[2] + i)
                } else {
                    for (B = 0; B < j; B++) Z((O = P[B])[2], O[1], O[0]);
                    for (B = 0; B < j; B++) Z((O = P[B])[0] + F * s, O[1] + F * s, O[2] + F * s)
                }
                n.addGroup(t, r.length / 3 - t, 0)
            }(),
            function() {
                var t = r.length / 3,
                    e = 0;
                for (q(L, e), e += L.length, w = 0, _ = T.length; w < _; w++) q(b = T[w], e), e += b.length;
                n.addGroup(t, r.length / 3 - t, 1)
            }()
        }
        this.addAttribute("position", new En(r, 3)), this.addAttribute("uv", new En(i, 2)), this.computeVertexNormals()
    }
    _o.prototype = Object.create(mn.prototype), _o.prototype.constructor = _o, _o.prototype.toJSON = function() {
        var t = mn.prototype.toJSON.call(this);
        return Eo(this.parameters.shapes, this.parameters.options, t)
    }, Mo.prototype = Object.create(zn.prototype), Mo.prototype.constructor = Mo, Mo.prototype.toJSON = function() {
        var t = zn.prototype.toJSON.call(this);
        return Eo(this.parameters.shapes, this.parameters.options, t)
    };
    var So = {
        generateTopUV: function(t, e, n, r, i) {
            var o = e[3 * n],
                a = e[3 * n + 1],
                s = e[3 * r],
                c = e[3 * r + 1],
                u = e[3 * i],
                l = e[3 * i + 1];
            return [new Ue(o, a), new Ue(s, c), new Ue(u, l)]
        },
        generateSideWallUV: function(t, e, n, r, i, o) {
            var a = e[3 * n],
                s = e[3 * n + 1],
                c = e[3 * n + 2],
                u = e[3 * r],
                l = e[3 * r + 1],
                h = e[3 * r + 2],
                f = e[3 * i],
                d = e[3 * i + 1],
                v = e[3 * i + 2],
                p = e[3 * o],
                m = e[3 * o + 1],
                g = e[3 * o + 2];
            return Math.abs(s - l) < .01 ? [new Ue(a, 1 - c), new Ue(u, 1 - h), new Ue(f, 1 - v), new Ue(p, 1 - g)] : [new Ue(s, 1 - c), new Ue(l, 1 - h), new Ue(d, 1 - v), new Ue(m, 1 - g)]
        }
    };

    function Eo(t, e, n) {
        if (n.shapes = [], Array.isArray(t))
            for (var r = 0, i = t.length; r < i; r++) {
                var o = t[r];
                n.shapes.push(o.uuid)
            } else n.shapes.push(t.uuid);
        return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n
    }

    function To(t, e) {
        mn.call(this), this.type = "TextGeometry", this.parameters = {
            text: t,
            parameters: e
        }, this.fromBufferGeometry(new Po(t, e)), this.mergeVertices()
    }

    function Po(t, e) {
        var n = (e = e || {}).font;
        if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new mn;
        var r = n.generateShapes(t, e.size);
        e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), Mo.call(this, r, e), this.type = "TextBufferGeometry"
    }

    function Lo(t, e, n, r, i, o, a) {
        mn.call(this), this.type = "SphereGeometry", this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: n,
            phiStart: r,
            phiLength: i,
            thetaStart: o,
            thetaLength: a
        }, this.fromBufferGeometry(new Ao(t, e, n, r, i, o, a)), this.mergeVertices()
    }

    function Ao(t, e, n, r, i, o, a) {
        zn.call(this), this.type = "SphereBufferGeometry", this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: n,
            phiStart: r,
            phiLength: i,
            thetaStart: o,
            thetaLength: a
        }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), n = Math.max(2, Math.floor(n) || 6), r = void 0 !== r ? r : 0, i = void 0 !== i ? i : 2 * Math.PI;
        var s, c, u = (o = void 0 !== o ? o : 0) + (a = void 0 !== a ? a : Math.PI),
            l = 0,
            h = [],
            f = new Ge,
            d = new Ge,
            v = [],
            p = [],
            m = [],
            g = [];
        for (c = 0; c <= n; c++) {
            var y = [],
                x = c / n;
            for (s = 0; s <= e; s++) {
                var b = s / e;
                f.x = -t * Math.cos(r + b * i) * Math.sin(o + x * a), f.y = t * Math.cos(o + x * a), f.z = t * Math.sin(r + b * i) * Math.sin(o + x * a), p.push(f.x, f.y, f.z), d.set(f.x, f.y, f.z).normalize(), m.push(d.x, d.y, d.z), g.push(b, 1 - x), y.push(l++)
            }
            h.push(y)
        }
        for (c = 0; c < n; c++)
            for (s = 0; s < e; s++) {
                var w = h[c][s + 1],
                    _ = h[c][s],
                    M = h[c + 1][s],
                    S = h[c + 1][s + 1];
                (0 !== c || o > 0) && v.push(w, _, S), (c !== n - 1 || u < Math.PI) && v.push(_, M, S)
            }
        this.setIndex(v), this.addAttribute("position", new En(p, 3)), this.addAttribute("normal", new En(m, 3)), this.addAttribute("uv", new En(g, 2))
    }

    function zo(t, e, n, r, i, o) {
        mn.call(this), this.type = "RingGeometry", this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: n,
            phiSegments: r,
            thetaStart: i,
            thetaLength: o
        }, this.fromBufferGeometry(new Co(t, e, n, r, i, o)), this.mergeVertices()
    }

    function Co(t, e, n, r, i, o) {
        zn.call(this), this.type = "RingBufferGeometry", this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: n,
            phiSegments: r,
            thetaStart: i,
            thetaLength: o
        }, t = t || .5, e = e || 1, i = void 0 !== i ? i : 0, o = void 0 !== o ? o : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8;
        var a, s, c, u = [],
            l = [],
            h = [],
            f = [],
            d = t,
            v = (e - t) / (r = void 0 !== r ? Math.max(1, r) : 1),
            p = new Ge,
            m = new Ue;
        for (s = 0; s <= r; s++) {
            for (c = 0; c <= n; c++) a = i + c / n * o, p.x = d * Math.cos(a), p.y = d * Math.sin(a), l.push(p.x, p.y, p.z), h.push(0, 0, 1), m.x = (p.x / e + 1) / 2, m.y = (p.y / e + 1) / 2, f.push(m.x, m.y);
            d += v
        }
        for (s = 0; s < r; s++) {
            var g = s * (n + 1);
            for (c = 0; c < n; c++) {
                var y = a = c + g,
                    x = a + n + 1,
                    b = a + n + 2,
                    w = a + 1;
                u.push(y, x, w), u.push(x, b, w)
            }
        }
        this.setIndex(u), this.addAttribute("position", new En(l, 3)), this.addAttribute("normal", new En(h, 3)), this.addAttribute("uv", new En(f, 2))
    }

    function Ro(t, e, n, r) {
        mn.call(this), this.type = "LatheGeometry", this.parameters = {
            points: t,
            segments: e,
            phiStart: n,
            phiLength: r
        }, this.fromBufferGeometry(new Io(t, e, n, r)), this.mergeVertices()
    }

    function Io(t, e, n, r) {
        zn.call(this), this.type = "LatheBufferGeometry", this.parameters = {
            points: t,
            segments: e,
            phiStart: n,
            phiLength: r
        }, e = Math.floor(e) || 12, n = n || 0, r = r || 2 * Math.PI, r = ke.clamp(r, 0, 2 * Math.PI);
        var i, o, a, s = [],
            c = [],
            u = [],
            l = 1 / e,
            h = new Ge,
            f = new Ue;
        for (o = 0; o <= e; o++) {
            var d = n + o * l * r,
                v = Math.sin(d),
                p = Math.cos(d);
            for (a = 0; a <= t.length - 1; a++) h.x = t[a].x * v, h.y = t[a].y, h.z = t[a].x * p, c.push(h.x, h.y, h.z), f.x = o / e, f.y = a / (t.length - 1), u.push(f.x, f.y)
        }
        for (o = 0; o < e; o++)
            for (a = 0; a < t.length - 1; a++) {
                var m = i = a + o * t.length,
                    g = i + t.length,
                    y = i + t.length + 1,
                    x = i + 1;
                s.push(m, g, x), s.push(g, y, x)
            }
        if (this.setIndex(s), this.addAttribute("position", new En(c, 3)), this.addAttribute("uv", new En(u, 2)), this.computeVertexNormals(), r === 2 * Math.PI) {
            var b = this.attributes.normal.array,
                w = new Ge,
                _ = new Ge,
                M = new Ge;
            for (i = e * t.length * 3, o = 0, a = 0; o < t.length; o++, a += 3) w.x = b[a + 0], w.y = b[a + 1], w.z = b[a + 2], _.x = b[i + a + 0], _.y = b[i + a + 1], _.z = b[i + a + 2], M.addVectors(w, _).normalize(), b[a + 0] = b[i + a + 0] = M.x, b[a + 1] = b[i + a + 1] = M.y, b[a + 2] = b[i + a + 2] = M.z
        }
    }

    function Do(t, e) {
        mn.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
            shapes: t,
            curveSegments: e
        }, this.fromBufferGeometry(new Oo(t, e)), this.mergeVertices()
    }

    function Oo(t, e) {
        zn.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
            shapes: t,
            curveSegments: e
        }, e = e || 12;
        var n = [],
            r = [],
            i = [],
            o = [],
            a = 0,
            s = 0;
        if (!1 === Array.isArray(t)) u(t);
        else
            for (var c = 0; c < t.length; c++) u(t[c]), this.addGroup(a, s, c), a += s, s = 0;

        function u(t) {
            var a, c, u, l = r.length / 3,
                h = t.extractPoints(e),
                f = h.shape,
                d = h.holes;
            if (!1 === xo.isClockWise(f))
                for (f = f.reverse(), a = 0, c = d.length; a < c; a++) u = d[a], !0 === xo.isClockWise(u) && (d[a] = u.reverse());
            var v = xo.triangulateShape(f, d);
            for (a = 0, c = d.length; a < c; a++) u = d[a], f = f.concat(u);
            for (a = 0, c = f.length; a < c; a++) {
                var p = f[a];
                r.push(p.x, p.y, 0), i.push(0, 0, 1), o.push(p.x, p.y)
            }
            for (a = 0, c = v.length; a < c; a++) {
                var m = v[a],
                    g = m[0] + l,
                    y = m[1] + l,
                    x = m[2] + l;
                n.push(g, y, x), s += 3
            }
        }
        this.setIndex(n), this.addAttribute("position", new En(r, 3)), this.addAttribute("normal", new En(i, 3)), this.addAttribute("uv", new En(o, 2))
    }

    function Fo(t, e) {
        if (e.shapes = [], Array.isArray(t))
            for (var n = 0, r = t.length; n < r; n++) {
                var i = t[n];
                e.shapes.push(i.uuid)
            } else e.shapes.push(t.uuid);
        return e
    }

    function jo(t, e) {
        zn.call(this), this.type = "EdgesGeometry", this.parameters = {
            thresholdAngle: e
        }, e = void 0 !== e ? e : 1;
        var n, r, i, o, a = [],
            s = Math.cos(ke.DEG2RAD * e),
            c = [0, 0],
            u = {},
            l = ["a", "b", "c"];
        t.isBufferGeometry ? (o = new mn).fromBufferGeometry(t) : o = t.clone(), o.mergeVertices(), o.computeFaceNormals();
        for (var h = o.vertices, f = o.faces, d = 0, v = f.length; d < v; d++)
            for (var p = f[d], m = 0; m < 3; m++) n = p[l[m]], r = p[l[(m + 1) % 3]], c[0] = Math.min(n, r), c[1] = Math.max(n, r), void 0 === u[i = c[0] + "," + c[1]] ? u[i] = {
                index1: c[0],
                index2: c[1],
                face1: d,
                face2: void 0
            } : u[i].face2 = d;
        for (i in u) {
            var g = u[i];
            if (void 0 === g.face2 || f[g.face1].normal.dot(f[g.face2].normal) <= s) {
                var y = h[g.index1];
                a.push(y.x, y.y, y.z), y = h[g.index2], a.push(y.x, y.y, y.z)
            }
        }
        this.addAttribute("position", new En(a, 3))
    }

    function ko(t, e, n, r, i, o, a, s) {
        mn.call(this), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: n,
            radialSegments: r,
            heightSegments: i,
            openEnded: o,
            thetaStart: a,
            thetaLength: s
        }, this.fromBufferGeometry(new Uo(t, e, n, r, i, o, a, s)), this.mergeVertices()
    }

    function Uo(t, e, n, r, i, o, a, s) {
        zn.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: n,
            radialSegments: r,
            heightSegments: i,
            openEnded: o,
            thetaStart: a,
            thetaLength: s
        };
        var c = this;
        t = void 0 !== t ? t : 1, e = void 0 !== e ? e : 1, n = n || 1, r = Math.floor(r) || 8, i = Math.floor(i) || 1, o = void 0 !== o && o, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : 2 * Math.PI;
        var u = [],
            l = [],
            h = [],
            f = [],
            d = 0,
            v = [],
            p = n / 2,
            m = 0;

        function g(n) {
            var i, o, v, g = new Ue,
                y = new Ge,
                x = 0,
                b = !0 === n ? t : e,
                w = !0 === n ? 1 : -1;
            for (o = d, i = 1; i <= r; i++) l.push(0, p * w, 0), h.push(0, w, 0), f.push(.5, .5), d++;
            for (v = d, i = 0; i <= r; i++) {
                var _ = i / r * s + a,
                    M = Math.cos(_),
                    S = Math.sin(_);
                y.x = b * S, y.y = p * w, y.z = b * M, l.push(y.x, y.y, y.z), h.push(0, w, 0), g.x = .5 * M + .5, g.y = .5 * S * w + .5, f.push(g.x, g.y), d++
            }
            for (i = 0; i < r; i++) {
                var E = o + i,
                    T = v + i;
                !0 === n ? u.push(T, T + 1, E) : u.push(T + 1, T, E), x += 3
            }
            c.addGroup(m, x, !0 === n ? 1 : 2), m += x
        }! function() {
            var o, g, y = new Ge,
                x = new Ge,
                b = 0,
                w = (e - t) / n;
            for (g = 0; g <= i; g++) {
                var _ = [],
                    M = g / i,
                    S = M * (e - t) + t;
                for (o = 0; o <= r; o++) {
                    var E = o / r,
                        T = E * s + a,
                        P = Math.sin(T),
                        L = Math.cos(T);
                    x.x = S * P, x.y = -M * n + p, x.z = S * L, l.push(x.x, x.y, x.z), y.set(P, w, L).normalize(), h.push(y.x, y.y, y.z), f.push(E, 1 - M), _.push(d++)
                }
                v.push(_)
            }
            for (o = 0; o < r; o++)
                for (g = 0; g < i; g++) {
                    var A = v[g][o],
                        z = v[g + 1][o],
                        C = v[g + 1][o + 1],
                        R = v[g][o + 1];
                    u.push(A, z, R), u.push(z, C, R), b += 6
                }
            c.addGroup(m, b, 0), m += b
        }(), !1 === o && (t > 0 && g(!0), e > 0 && g(!1)), this.setIndex(u), this.addAttribute("position", new En(l, 3)), this.addAttribute("normal", new En(h, 3)), this.addAttribute("uv", new En(f, 2))
    }

    function Bo(t, e, n, r, i, o, a) {
        ko.call(this, 0, t, e, n, r, i, o, a), this.type = "ConeGeometry", this.parameters = {
            radius: t,
            height: e,
            radialSegments: n,
            heightSegments: r,
            openEnded: i,
            thetaStart: o,
            thetaLength: a
        }
    }

    function No(t, e, n, r, i, o, a) {
        Uo.call(this, 0, t, e, n, r, i, o, a), this.type = "ConeBufferGeometry", this.parameters = {
            radius: t,
            height: e,
            radialSegments: n,
            heightSegments: r,
            openEnded: i,
            thetaStart: o,
            thetaLength: a
        }
    }

    function Go(t, e, n, r) {
        mn.call(this), this.type = "CircleGeometry", this.parameters = {
            radius: t,
            segments: e,
            thetaStart: n,
            thetaLength: r
        }, this.fromBufferGeometry(new Ho(t, e, n, r)), this.mergeVertices()
    }

    function Ho(t, e, n, r) {
        zn.call(this), this.type = "CircleBufferGeometry", this.parameters = {
            radius: t,
            segments: e,
            thetaStart: n,
            thetaLength: r
        }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
        var i, o, a = [],
            s = [],
            c = [],
            u = [],
            l = new Ge,
            h = new Ue;
        for (s.push(0, 0, 0), c.push(0, 0, 1), u.push(.5, .5), o = 0, i = 3; o <= e; o++, i += 3) {
            var f = n + o / e * r;
            l.x = t * Math.cos(f), l.y = t * Math.sin(f), s.push(l.x, l.y, l.z), c.push(0, 0, 1), h.x = (s[i] / t + 1) / 2, h.y = (s[i + 1] / t + 1) / 2, u.push(h.x, h.y)
        }
        for (i = 1; i <= e; i++) a.push(i, i + 1, 0);
        this.setIndex(a), this.addAttribute("position", new En(s, 3)), this.addAttribute("normal", new En(c, 3)), this.addAttribute("uv", new En(u, 2))
    }
    To.prototype = Object.create(mn.prototype), To.prototype.constructor = To, Po.prototype = Object.create(Mo.prototype), Po.prototype.constructor = Po, Lo.prototype = Object.create(mn.prototype), Lo.prototype.constructor = Lo, Ao.prototype = Object.create(zn.prototype), Ao.prototype.constructor = Ao, zo.prototype = Object.create(mn.prototype), zo.prototype.constructor = zo, Co.prototype = Object.create(zn.prototype), Co.prototype.constructor = Co, Ro.prototype = Object.create(mn.prototype), Ro.prototype.constructor = Ro, Io.prototype = Object.create(zn.prototype), Io.prototype.constructor = Io, Do.prototype = Object.create(mn.prototype), Do.prototype.constructor = Do, Do.prototype.toJSON = function() {
        var t = mn.prototype.toJSON.call(this);
        return Fo(this.parameters.shapes, t)
    }, Oo.prototype = Object.create(zn.prototype), Oo.prototype.constructor = Oo, Oo.prototype.toJSON = function() {
        var t = zn.prototype.toJSON.call(this);
        return Fo(this.parameters.shapes, t)
    }, jo.prototype = Object.create(zn.prototype), jo.prototype.constructor = jo, ko.prototype = Object.create(mn.prototype), ko.prototype.constructor = ko, Uo.prototype = Object.create(zn.prototype), Uo.prototype.constructor = Uo, Bo.prototype = Object.create(ko.prototype), Bo.prototype.constructor = Bo, No.prototype = Object.create(Uo.prototype), No.prototype.constructor = No, Go.prototype = Object.create(mn.prototype), Go.prototype.constructor = Go, Ho.prototype = Object.create(zn.prototype), Ho.prototype.constructor = Ho;
    var Vo = Object.freeze({
        WireframeGeometry: Ci,
        ParametricGeometry: Ri,
        ParametricBufferGeometry: Ii,
        TetrahedronGeometry: Fi,
        TetrahedronBufferGeometry: ji,
        OctahedronGeometry: ki,
        OctahedronBufferGeometry: Ui,
        IcosahedronGeometry: Bi,
        IcosahedronBufferGeometry: Ni,
        DodecahedronGeometry: Gi,
        DodecahedronBufferGeometry: Hi,
        PolyhedronGeometry: Di,
        PolyhedronBufferGeometry: Oi,
        TubeGeometry: Vi,
        TubeBufferGeometry: Wi,
        TorusKnotGeometry: Yi,
        TorusKnotBufferGeometry: Xi,
        TorusGeometry: qi,
        TorusBufferGeometry: Ki,
        TextGeometry: To,
        TextBufferGeometry: Po,
        SphereGeometry: Lo,
        SphereBufferGeometry: Ao,
        RingGeometry: zo,
        RingBufferGeometry: Co,
        PlaneGeometry: In,
        PlaneBufferGeometry: Dn,
        LatheGeometry: Ro,
        LatheBufferGeometry: Io,
        ShapeGeometry: Do,
        ShapeBufferGeometry: Oo,
        ExtrudeGeometry: _o,
        ExtrudeBufferGeometry: Mo,
        EdgesGeometry: jo,
        ConeGeometry: Bo,
        ConeBufferGeometry: No,
        CylinderGeometry: ko,
        CylinderBufferGeometry: Uo,
        CircleGeometry: Go,
        CircleBufferGeometry: Ho,
        BoxGeometry: Cn,
        BoxBufferGeometry: Rn
    });

    function Wo(t) {
        Fn.call(this), this.type = "ShadowMaterial", this.color = new on(0), this.transparent = !0, this.setValues(t)
    }

    function Yo(t) {
        jn.call(this, t), this.type = "RawShaderMaterial"
    }

    function Xo(t) {
        Fn.call(this), this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new on(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new on(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fe, this.normalScale = new Ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    function qo(t) {
        Xo.call(this), this.defines = {
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(t)
    }

    function Ko(t) {
        Fn.call(this), this.type = "MeshPhongMaterial", this.color = new on(16777215), this.specular = new on(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new on(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fe, this.normalScale = new Ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = $, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    function Zo(t) {
        Ko.call(this), this.defines = {
            TOON: ""
        }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t)
    }

    function Jo(t) {
        Fn.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fe, this.normalScale = new Ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    function Qo(t) {
        Fn.call(this), this.type = "MeshLambertMaterial", this.color = new on(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new on(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = $, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    function $o(t) {
        if (Fn.call(this), this.defines = {
                MATCAP: ""
            }, this.type = "MeshMatcapMaterial", this.color = new on(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fe, this.normalScale = new Ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.lights = !1, this.setValues(t), null === this.matcap) {
            var e = document.createElement("canvas");
            e.width = 1, e.height = 1;
            var n = e.getContext("2d");
            n.fillStyle = "#fff", n.fillRect(0, 0, 1, 1), this.matcap = new THREE.CanvasTexture(e)
        }
    }

    function ta(t) {
        wi.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
    }
    Wo.prototype = Object.create(Fn.prototype), Wo.prototype.constructor = Wo, Wo.prototype.isShadowMaterial = !0, Wo.prototype.copy = function(t) {
        return Fn.prototype.copy.call(this, t), this.color.copy(t.color), this
    }, Yo.prototype = Object.create(jn.prototype), Yo.prototype.constructor = Yo, Yo.prototype.isRawShaderMaterial = !0, Xo.prototype = Object.create(Fn.prototype), Xo.prototype.constructor = Xo, Xo.prototype.isMeshStandardMaterial = !0, Xo.prototype.copy = function(t) {
        return Fn.prototype.copy.call(this, t), this.defines = {
            STANDARD: ""
        }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, qo.prototype = Object.create(Xo.prototype), qo.prototype.constructor = qo, qo.prototype.isMeshPhysicalMaterial = !0, qo.prototype.copy = function(t) {
        return Xo.prototype.copy.call(this, t), this.defines = {
            PHYSICAL: ""
        }, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this
    }, Ko.prototype = Object.create(Fn.prototype), Ko.prototype.constructor = Ko, Ko.prototype.isMeshPhongMaterial = !0, Ko.prototype.copy = function(t) {
        return Fn.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, Zo.prototype = Object.create(Ko.prototype), Zo.prototype.constructor = Zo, Zo.prototype.isMeshToonMaterial = !0, Zo.prototype.copy = function(t) {
        return Ko.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this
    }, Jo.prototype = Object.create(Fn.prototype), Jo.prototype.constructor = Jo, Jo.prototype.isMeshNormalMaterial = !0, Jo.prototype.copy = function(t) {
        return Fn.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, Qo.prototype = Object.create(Fn.prototype), Qo.prototype.constructor = Qo, Qo.prototype.isMeshLambertMaterial = !0, Qo.prototype.copy = function(t) {
        return Fn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, $o.prototype = Object.create(Fn.prototype), $o.prototype.constructor = $o, $o.prototype.isMeshMatcapMaterial = !0, $o.prototype.copy = function(t) {
        return Fn.prototype.copy.call(this, t), this.defines = {
            MATCAP: ""
        }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, ta.prototype = Object.create(wi.prototype), ta.prototype.constructor = ta, ta.prototype.isLineDashedMaterial = !0, ta.prototype.copy = function(t) {
        return wi.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
    };
    var ea = Object.freeze({
            ShadowMaterial: Wo,
            SpriteMaterial: pi,
            RawShaderMaterial: Yo,
            ShaderMaterial: jn,
            PointsMaterial: Ei,
            MeshPhysicalMaterial: qo,
            MeshStandardMaterial: Xo,
            MeshPhongMaterial: Ko,
            MeshToonMaterial: Zo,
            MeshNormalMaterial: Jo,
            MeshLambertMaterial: Qo,
            MeshDepthMaterial: $r,
            MeshDistanceMaterial: ti,
            MeshBasicMaterial: Bn,
            MeshMatcapMaterial: $o,
            LineDashedMaterial: ta,
            LineBasicMaterial: wi,
            Material: Fn
        }),
        na = {
            enabled: !1,
            files: {},
            add: function(t, e) {
                !1 !== this.enabled && (this.files[t] = e)
            },
            get: function(t) {
                if (!1 !== this.enabled) return this.files[t]
            },
            remove: function(t) {
                delete this.files[t]
            },
            clear: function() {
                this.files = {}
            }
        };

    function ra(t, e, n) {
        var r = this,
            i = !1,
            o = 0,
            a = 0,
            s = void 0;
        this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
            a++, !1 === i && void 0 !== r.onStart && r.onStart(t, o, a), i = !0
        }, this.itemEnd = function(t) {
            o++, void 0 !== r.onProgress && r.onProgress(t, o, a), o === a && (i = !1, void 0 !== r.onLoad && r.onLoad())
        }, this.itemError = function(t) {
            void 0 !== r.onError && r.onError(t)
        }, this.resolveURL = function(t) {
            return s ? s(t) : t
        }, this.setURLModifier = function(t) {
            return s = t, this
        }
    }
    var ia = new ra,
        oa = {};

    function aa(t) {
        this.manager = void 0 !== t ? t : ia
    }

    function sa(t) {
        this.manager = void 0 !== t ? t : ia, this._parser = null
    }

    function ca(t) {
        this.manager = void 0 !== t ? t : ia, this._parser = null
    }

    function ua(t) {
        this.manager = void 0 !== t ? t : ia
    }

    function la(t) {
        this.manager = void 0 !== t ? t : ia
    }

    function ha(t) {
        this.manager = void 0 !== t ? t : ia
    }

    function fa() {
        this.type = "Curve", this.arcLengthDivisions = 200
    }

    function da(t, e, n, r, i, o, a, s) {
        fa.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = n || 1, this.yRadius = r || 1, this.aStartAngle = i || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = s || 0
    }

    function va(t, e, n, r, i, o) {
        da.call(this, t, e, n, n, r, i, o), this.type = "ArcCurve"
    }

    function pa() {
        var t = 0,
            e = 0,
            n = 0,
            r = 0;

        function i(i, o, a, s) {
            t = i, e = a, n = -3 * i + 3 * o - 2 * a - s, r = 2 * i - 2 * o + a + s
        }
        return {
            initCatmullRom: function(t, e, n, r, o) {
                i(e, n, o * (n - t), o * (r - e))
            },
            initNonuniformCatmullRom: function(t, e, n, r, o, a, s) {
                var c = (e - t) / o - (n - t) / (o + a) + (n - e) / a,
                    u = (n - e) / a - (r - e) / (a + s) + (r - n) / s;
                i(e, n, c *= a, u *= a)
            },
            calc: function(i) {
                var o = i * i;
                return t + e * i + n * o + r * (o * i)
            }
        }
    }
    Object.assign(aa.prototype, {
        load: function(t, e, n, r) {
            void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
            var i = this,
                o = na.get(t);
            if (void 0 !== o) return i.manager.itemStart(t), setTimeout(function() {
                e && e(o), i.manager.itemEnd(t)
            }, 0), o;
            if (void 0 === oa[t]) {
                var a = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (a) {
                    var s = a[1],
                        c = !!a[2],
                        u = a[3];
                    u = window.decodeURIComponent(u), c && (u = window.atob(u));
                    try {
                        var l, h = (this.responseType || "").toLowerCase();
                        switch (h) {
                            case "arraybuffer":
                            case "blob":
                                for (var f = new Uint8Array(u.length), d = 0; d < u.length; d++) f[d] = u.charCodeAt(d);
                                l = "blob" === h ? new Blob([f.buffer], {
                                    type: s
                                }) : f.buffer;
                                break;
                            case "document":
                                var v = new DOMParser;
                                l = v.parseFromString(u, s);
                                break;
                            case "json":
                                l = JSON.parse(u);
                                break;
                            default:
                                l = u
                        }
                        window.setTimeout(function() {
                            e && e(l), i.manager.itemEnd(t)
                        }, 0)
                    } catch (e) {
                        window.setTimeout(function() {
                            r && r(e), i.manager.itemEnd(t), i.manager.itemError(t)
                        }, 0)
                    }
                } else {
                    oa[t] = [], oa[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: r
                    });
                    var p = new XMLHttpRequest;
                    for (var m in p.open("GET", t, !0), p.addEventListener("load", function(e) {
                            var n = this.response;
                            na.add(t, n);
                            var r = oa[t];
                            if (delete oa[t], 200 === this.status || 0 === this.status) {
                                0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                                for (var o = 0, a = r.length; o < a; o++) {
                                    (s = r[o]).onLoad && s.onLoad(n)
                                }
                                i.manager.itemEnd(t)
                            } else {
                                for (o = 0, a = r.length; o < a; o++) {
                                    var s;
                                    (s = r[o]).onError && s.onError(e)
                                }
                                i.manager.itemEnd(t), i.manager.itemError(t)
                            }
                        }, !1), p.addEventListener("progress", function(e) {
                            for (var n = oa[t], r = 0, i = n.length; r < i; r++) {
                                var o = n[r];
                                o.onProgress && o.onProgress(e)
                            }
                        }, !1), p.addEventListener("error", function(e) {
                            var n = oa[t];
                            delete oa[t];
                            for (var r = 0, o = n.length; r < o; r++) {
                                var a = n[r];
                                a.onError && a.onError(e)
                            }
                            i.manager.itemEnd(t), i.manager.itemError(t)
                        }, !1), p.addEventListener("abort", function(e) {
                            var n = oa[t];
                            delete oa[t];
                            for (var r = 0, o = n.length; r < o; r++) {
                                var a = n[r];
                                a.onError && a.onError(e)
                            }
                            i.manager.itemEnd(t), i.manager.itemError(t)
                        }, !1), void 0 !== this.responseType && (p.responseType = this.responseType), void 0 !== this.withCredentials && (p.withCredentials = this.withCredentials), p.overrideMimeType && p.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) p.setRequestHeader(m, this.requestHeader[m]);
                    p.send(null)
                }
                return i.manager.itemStart(t), p
            }
            oa[t].push({
                onLoad: e,
                onProgress: n,
                onError: r
            })
        },
        setPath: function(t) {
            return this.path = t, this
        },
        setResponseType: function(t) {
            return this.responseType = t, this
        },
        setWithCredentials: function(t) {
            return this.withCredentials = t, this
        },
        setMimeType: function(t) {
            return this.mimeType = t, this
        },
        setRequestHeader: function(t) {
            return this.requestHeader = t, this
        }
    }), Object.assign(sa.prototype, {
        load: function(t, e, n, r) {
            var i = this,
                o = [],
                a = new Li;
            a.image = o;
            var s = new aa(this.manager);

            function c(c) {
                s.load(t[c], function(t) {
                    var n = i._parser(t, !0);
                    o[c] = {
                        width: n.width,
                        height: n.height,
                        format: n.format,
                        mipmaps: n.mipmaps
                    }, 6 === (u += 1) && (1 === n.mipmapCount && (a.minFilter = wt), a.format = n.format, a.needsUpdate = !0, e && e(a))
                }, n, r)
            }
            if (s.setPath(this.path), s.setResponseType("arraybuffer"), Array.isArray(t))
                for (var u = 0, l = 0, h = t.length; l < h; ++l) c(l);
            else s.load(t, function(t) {
                var n = i._parser(t, !0);
                if (n.isCubemap)
                    for (var r = n.mipmaps.length / n.mipmapCount, s = 0; s < r; s++) {
                        o[s] = {
                            mipmaps: []
                        };
                        for (var c = 0; c < n.mipmapCount; c++) o[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + c]), o[s].format = n.format, o[s].width = n.width, o[s].height = n.height
                    } else a.image.width = n.width, a.image.height = n.height, a.mipmaps = n.mipmaps;
                1 === n.mipmapCount && (a.minFilter = wt), a.format = n.format, a.needsUpdate = !0, e && e(a)
            }, n, r);
            return a
        },
        setPath: function(t) {
            return this.path = t, this
        }
    }), Object.assign(ca.prototype, {
        load: function(t, e, n, r) {
            var i = this,
                o = new Ze,
                a = new aa(this.manager);
            return a.setResponseType("arraybuffer"), a.load(t, function(t) {
                var n = i._parser(t);
                n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width, o.image.height = n.height, o.image.data = n.data), o.wrapS = void 0 !== n.wrapS ? n.wrapS : mt, o.wrapT = void 0 !== n.wrapT ? n.wrapT : mt, o.magFilter = void 0 !== n.magFilter ? n.magFilter : wt, o.minFilter = void 0 !== n.minFilter ? n.minFilter : Mt, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (o.format = n.format), void 0 !== n.type && (o.type = n.type), void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps), 1 === n.mipmapCount && (o.minFilter = wt), o.needsUpdate = !0, e && e(o, n))
            }, n, r), o
        }
    }), Object.assign(ua.prototype, {
        crossOrigin: "anonymous",
        load: function(t, e, n, r) {
            void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
            var i = this,
                o = na.get(t);
            if (void 0 !== o) return i.manager.itemStart(t), setTimeout(function() {
                e && e(o), i.manager.itemEnd(t)
            }, 0), o;
            var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

            function s() {
                a.removeEventListener("load", s, !1), a.removeEventListener("error", c, !1), na.add(t, this), e && e(this), i.manager.itemEnd(t)
            }

            function c(e) {
                a.removeEventListener("load", s, !1), a.removeEventListener("error", c, !1), r && r(e), i.manager.itemEnd(t), i.manager.itemError(t)
            }
            return a.addEventListener("load", s, !1), a.addEventListener("error", c, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), i.manager.itemStart(t), a.src = t, a
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t, this
        },
        setPath: function(t) {
            return this.path = t, this
        }
    }), Object.assign(la.prototype, {
        crossOrigin: "anonymous",
        load: function(t, e, n, r) {
            var i = new Hn,
                o = new ua(this.manager);
            o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
            var a = 0;

            function s(n) {
                o.load(t[n], function(t) {
                    i.images[n] = t, 6 === ++a && (i.needsUpdate = !0, e && e(i))
                }, void 0, r)
            }
            for (var c = 0; c < t.length; ++c) s(c);
            return i
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t, this
        },
        setPath: function(t) {
            return this.path = t, this
        }
    }), Object.assign(ha.prototype, {
        crossOrigin: "anonymous",
        load: function(t, e, n, r) {
            var i = new Ye,
                o = new ua(this.manager);
            return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, function(n) {
                i.image = n;
                var r = t.search(/\.jpe?g$/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                i.format = r ? jt : kt, i.needsUpdate = !0, void 0 !== e && e(i)
            }, n, r), i
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t, this
        },
        setPath: function(t) {
            return this.path = t, this
        }
    }), Object.assign(fa.prototype, {
        getPoint: function() {
            return console.warn("THREE.Curve: .getPoint() not implemented."), null
        },
        getPointAt: function(t, e) {
            var n = this.getUtoTmapping(t);
            return this.getPoint(n, e)
        },
        getPoints: function(t) {
            void 0 === t && (t = 5);
            for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
            return e
        },
        getSpacedPoints: function(t) {
            void 0 === t && (t = 5);
            for (var e = [], n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
            return e
        },
        getLength: function() {
            var t = this.getLengths();
            return t[t.length - 1]
        },
        getLengths: function(t) {
            if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            var e, n, r = [],
                i = this.getPoint(0),
                o = 0;
            for (r.push(0), n = 1; n <= t; n++) o += (e = this.getPoint(n / t)).distanceTo(i), r.push(o), i = e;
            return this.cacheArcLengths = r, r
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.getLengths()
        },
        getUtoTmapping: function(t, e) {
            var n, r = this.getLengths(),
                i = 0,
                o = r.length;
            n = e || t * r[o - 1];
            for (var a, s = 0, c = o - 1; s <= c;)
                if ((a = r[i = Math.floor(s + (c - s) / 2)] - n) < 0) s = i + 1;
                else {
                    if (!(a > 0)) {
                        c = i;
                        break
                    }
                    c = i - 1
                }
            if (r[i = c] === n) return i / (o - 1);
            var u = r[i];
            return (i + (n - u) / (r[i + 1] - u)) / (o - 1)
        },
        getTangent: function(t) {
            var e = t - 1e-4,
                n = t + 1e-4;
            e < 0 && (e = 0), n > 1 && (n = 1);
            var r = this.getPoint(e);
            return this.getPoint(n).clone().sub(r).normalize()
        },
        getTangentAt: function(t) {
            var e = this.getUtoTmapping(t);
            return this.getTangent(e)
        },
        computeFrenetFrames: function(t, e) {
            var n, r, i, o = new Ge,
                a = [],
                s = [],
                c = [],
                u = new Ge,
                l = new Be;
            for (n = 0; n <= t; n++) r = n / t, a[n] = this.getTangentAt(r), a[n].normalize();
            s[0] = new Ge, c[0] = new Ge;
            var h = Number.MAX_VALUE,
                f = Math.abs(a[0].x),
                d = Math.abs(a[0].y),
                v = Math.abs(a[0].z);
            for (f <= h && (h = f, o.set(1, 0, 0)), d <= h && (h = d, o.set(0, 1, 0)), v <= h && o.set(0, 0, 1), u.crossVectors(a[0], o).normalize(), s[0].crossVectors(a[0], u), c[0].crossVectors(a[0], s[0]), n = 1; n <= t; n++) s[n] = s[n - 1].clone(), c[n] = c[n - 1].clone(), u.crossVectors(a[n - 1], a[n]), u.length() > Number.EPSILON && (u.normalize(), i = Math.acos(ke.clamp(a[n - 1].dot(a[n]), -1, 1)), s[n].applyMatrix4(l.makeRotationAxis(u, i))), c[n].crossVectors(a[n], s[n]);
            if (!0 === e)
                for (i = Math.acos(ke.clamp(s[0].dot(s[t]), -1, 1)), i /= t, a[0].dot(u.crossVectors(s[0], s[t])) > 0 && (i = -i), n = 1; n <= t; n++) s[n].applyMatrix4(l.makeRotationAxis(a[n], i * n)), c[n].crossVectors(a[n], s[n]);
            return {
                tangents: a,
                normals: s,
                binormals: c
            }
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions, this
        },
        toJSON: function() {
            var t = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
        },
        fromJSON: function(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions, this
        }
    }), da.prototype = Object.create(fa.prototype), da.prototype.constructor = da, da.prototype.isEllipseCurve = !0, da.prototype.getPoint = function(t, e) {
        for (var n = e || new Ue, r = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, o = Math.abs(i) < Number.EPSILON; i < 0;) i += r;
        for (; i > r;) i -= r;
        i < Number.EPSILON && (i = o ? 0 : r), !0 !== this.aClockwise || o || (i === r ? i = -r : i -= r);
        var a = this.aStartAngle + t * i,
            s = this.aX + this.xRadius * Math.cos(a),
            c = this.aY + this.yRadius * Math.sin(a);
        if (0 !== this.aRotation) {
            var u = Math.cos(this.aRotation),
                l = Math.sin(this.aRotation),
                h = s - this.aX,
                f = c - this.aY;
            s = h * u - f * l + this.aX, c = h * l + f * u + this.aY
        }
        return n.set(s, c)
    }, da.prototype.copy = function(t) {
        return fa.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
    }, da.prototype.toJSON = function() {
        var t = fa.prototype.toJSON.call(this);
        return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
    }, da.prototype.fromJSON = function(t) {
        return fa.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
    }, va.prototype = Object.create(da.prototype), va.prototype.constructor = va, va.prototype.isArcCurve = !0;
    var ma = new Ge,
        ga = new pa,
        ya = new pa,
        xa = new pa;

    function ba(t, e, n, r) {
        fa.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = n || "centripetal", this.tension = r || .5
    }

    function wa(t, e, n, r, i) {
        var o = .5 * (r - e),
            a = .5 * (i - n),
            s = t * t;
        return (2 * n - 2 * r + o + a) * (t * s) + (-3 * n + 3 * r - 2 * o - a) * s + o * t + n
    }

    function _a(t, e, n, r) {
        return function(t, e) {
            var n = 1 - t;
            return n * n * e
        }(t, e) + function(t, e) {
            return 2 * (1 - t) * t * e
        }(t, n) + function(t, e) {
            return t * t * e
        }(t, r)
    }

    function Ma(t, e, n, r, i) {
        return function(t, e) {
            var n = 1 - t;
            return n * n * n * e
        }(t, e) + function(t, e) {
            var n = 1 - t;
            return 3 * n * n * t * e
        }(t, n) + function(t, e) {
            return 3 * (1 - t) * t * t * e
        }(t, r) + function(t, e) {
            return t * t * t * e
        }(t, i)
    }

    function Sa(t, e, n, r) {
        fa.call(this), this.type = "CubicBezierCurve", this.v0 = t || new Ue, this.v1 = e || new Ue, this.v2 = n || new Ue, this.v3 = r || new Ue
    }

    function Ea(t, e, n, r) {
        fa.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new Ge, this.v1 = e || new Ge, this.v2 = n || new Ge, this.v3 = r || new Ge
    }

    function Ta(t, e) {
        fa.call(this), this.type = "LineCurve", this.v1 = t || new Ue, this.v2 = e || new Ue
    }

    function Pa(t, e) {
        fa.call(this), this.type = "LineCurve3", this.v1 = t || new Ge, this.v2 = e || new Ge
    }

    function La(t, e, n) {
        fa.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new Ue, this.v1 = e || new Ue, this.v2 = n || new Ue
    }

    function Aa(t, e, n) {
        fa.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new Ge, this.v1 = e || new Ge, this.v2 = n || new Ge
    }

    function za(t) {
        fa.call(this), this.type = "SplineCurve", this.points = t || []
    }
    ba.prototype = Object.create(fa.prototype), ba.prototype.constructor = ba, ba.prototype.isCatmullRomCurve3 = !0, ba.prototype.getPoint = function(t, e) {
        var n, r, i, o, a = e || new Ge,
            s = this.points,
            c = s.length,
            u = (c - (this.closed ? 0 : 1)) * t,
            l = Math.floor(u),
            h = u - l;
        if (this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / c) + 1) * c : 0 === h && l === c - 1 && (l = c - 2, h = 1), this.closed || l > 0 ? n = s[(l - 1) % c] : (ma.subVectors(s[0], s[1]).add(s[0]), n = ma), r = s[l % c], i = s[(l + 1) % c], this.closed || l + 2 < c ? o = s[(l + 2) % c] : (ma.subVectors(s[c - 1], s[c - 2]).add(s[c - 1]), o = ma), "centripetal" === this.curveType || "chordal" === this.curveType) {
            var f = "chordal" === this.curveType ? .5 : .25,
                d = Math.pow(n.distanceToSquared(r), f),
                v = Math.pow(r.distanceToSquared(i), f),
                p = Math.pow(i.distanceToSquared(o), f);
            v < 1e-4 && (v = 1), d < 1e-4 && (d = v), p < 1e-4 && (p = v), ga.initNonuniformCatmullRom(n.x, r.x, i.x, o.x, d, v, p), ya.initNonuniformCatmullRom(n.y, r.y, i.y, o.y, d, v, p), xa.initNonuniformCatmullRom(n.z, r.z, i.z, o.z, d, v, p)
        } else "catmullrom" === this.curveType && (ga.initCatmullRom(n.x, r.x, i.x, o.x, this.tension), ya.initCatmullRom(n.y, r.y, i.y, o.y, this.tension), xa.initCatmullRom(n.z, r.z, i.z, o.z, this.tension));
        return a.set(ga.calc(h), ya.calc(h), xa.calc(h)), a
    }, ba.prototype.copy = function(t) {
        fa.prototype.copy.call(this, t), this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var r = t.points[e];
            this.points.push(r.clone())
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
    }, ba.prototype.toJSON = function() {
        var t = fa.prototype.toJSON.call(this);
        t.points = [];
        for (var e = 0, n = this.points.length; e < n; e++) {
            var r = this.points[e];
            t.points.push(r.toArray())
        }
        return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
    }, ba.prototype.fromJSON = function(t) {
        fa.prototype.fromJSON.call(this, t), this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var r = t.points[e];
            this.points.push((new Ge).fromArray(r))
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
    }, Sa.prototype = Object.create(fa.prototype), Sa.prototype.constructor = Sa, Sa.prototype.isCubicBezierCurve = !0, Sa.prototype.getPoint = function(t, e) {
        var n = e || new Ue,
            r = this.v0,
            i = this.v1,
            o = this.v2,
            a = this.v3;
        return n.set(Ma(t, r.x, i.x, o.x, a.x), Ma(t, r.y, i.y, o.y, a.y)), n
    }, Sa.prototype.copy = function(t) {
        return fa.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
    }, Sa.prototype.toJSON = function() {
        var t = fa.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
    }, Sa.prototype.fromJSON = function(t) {
        return fa.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
    }, Ea.prototype = Object.create(fa.prototype), Ea.prototype.constructor = Ea, Ea.prototype.isCubicBezierCurve3 = !0, Ea.prototype.getPoint = function(t, e) {
        var n = e || new Ge,
            r = this.v0,
            i = this.v1,
            o = this.v2,
            a = this.v3;
        return n.set(Ma(t, r.x, i.x, o.x, a.x), Ma(t, r.y, i.y, o.y, a.y), Ma(t, r.z, i.z, o.z, a.z)), n
    }, Ea.prototype.copy = function(t) {
        return fa.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
    }, Ea.prototype.toJSON = function() {
        var t = fa.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
    }, Ea.prototype.fromJSON = function(t) {
        return fa.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
    }, Ta.prototype = Object.create(fa.prototype), Ta.prototype.constructor = Ta, Ta.prototype.isLineCurve = !0, Ta.prototype.getPoint = function(t, e) {
        var n = e || new Ue;
        return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
    }, Ta.prototype.getPointAt = function(t, e) {
        return this.getPoint(t, e)
    }, Ta.prototype.getTangent = function() {
        return this.v2.clone().sub(this.v1).normalize()
    }, Ta.prototype.copy = function(t) {
        return fa.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }, Ta.prototype.toJSON = function() {
        var t = fa.prototype.toJSON.call(this);
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }, Ta.prototype.fromJSON = function(t) {
        return fa.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }, Pa.prototype = Object.create(fa.prototype), Pa.prototype.constructor = Pa, Pa.prototype.isLineCurve3 = !0, Pa.prototype.getPoint = function(t, e) {
        var n = e || new Ge;
        return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
    }, Pa.prototype.getPointAt = function(t, e) {
        return this.getPoint(t, e)
    }, Pa.prototype.copy = function(t) {
        return fa.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }, Pa.prototype.toJSON = function() {
        var t = fa.prototype.toJSON.call(this);
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }, Pa.prototype.fromJSON = function(t) {
        return fa.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }, La.prototype = Object.create(fa.prototype), La.prototype.constructor = La, La.prototype.isQuadraticBezierCurve = !0, La.prototype.getPoint = function(t, e) {
        var n = e || new Ue,
            r = this.v0,
            i = this.v1,
            o = this.v2;
        return n.set(_a(t, r.x, i.x, o.x), _a(t, r.y, i.y, o.y)), n
    }, La.prototype.copy = function(t) {
        return fa.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }, La.prototype.toJSON = function() {
        var t = fa.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }, La.prototype.fromJSON = function(t) {
        return fa.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }, Aa.prototype = Object.create(fa.prototype), Aa.prototype.constructor = Aa, Aa.prototype.isQuadraticBezierCurve3 = !0, Aa.prototype.getPoint = function(t, e) {
        var n = e || new Ge,
            r = this.v0,
            i = this.v1,
            o = this.v2;
        return n.set(_a(t, r.x, i.x, o.x), _a(t, r.y, i.y, o.y), _a(t, r.z, i.z, o.z)), n
    }, Aa.prototype.copy = function(t) {
        return fa.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }, Aa.prototype.toJSON = function() {
        var t = fa.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }, Aa.prototype.fromJSON = function(t) {
        return fa.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }, za.prototype = Object.create(fa.prototype), za.prototype.constructor = za, za.prototype.isSplineCurve = !0, za.prototype.getPoint = function(t, e) {
        var n = e || new Ue,
            r = this.points,
            i = (r.length - 1) * t,
            o = Math.floor(i),
            a = i - o,
            s = r[0 === o ? o : o - 1],
            c = r[o],
            u = r[o > r.length - 2 ? r.length - 1 : o + 1],
            l = r[o > r.length - 3 ? r.length - 1 : o + 2];
        return n.set(wa(a, s.x, c.x, u.x, l.x), wa(a, s.y, c.y, u.y, l.y)), n
    }, za.prototype.copy = function(t) {
        fa.prototype.copy.call(this, t), this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var r = t.points[e];
            this.points.push(r.clone())
        }
        return this
    }, za.prototype.toJSON = function() {
        var t = fa.prototype.toJSON.call(this);
        t.points = [];
        for (var e = 0, n = this.points.length; e < n; e++) {
            var r = this.points[e];
            t.points.push(r.toArray())
        }
        return t
    }, za.prototype.fromJSON = function(t) {
        fa.prototype.fromJSON.call(this, t), this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var r = t.points[e];
            this.points.push((new Ue).fromArray(r))
        }
        return this
    };
    var Ca = Object.freeze({
        ArcCurve: va,
        CatmullRomCurve3: ba,
        CubicBezierCurve: Sa,
        CubicBezierCurve3: Ea,
        EllipseCurve: da,
        LineCurve: Ta,
        LineCurve3: Pa,
        QuadraticBezierCurve: La,
        QuadraticBezierCurve3: Aa,
        SplineCurve: za
    });

    function Ra() {
        fa.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
    }

    function Ia(t) {
        Ra.call(this), this.type = "Path", this.currentPoint = new Ue, t && this.setFromPoints(t)
    }

    function Da(t) {
        Ia.call(this, t), this.uuid = ke.generateUUID(), this.type = "Shape", this.holes = []
    }

    function Oa(t, e) {
        vn.call(this), this.type = "Light", this.color = new on(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
    }

    function Fa(t, e, n) {
        Oa.call(this, t, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(vn.DefaultUp), this.updateMatrix(), this.groundColor = new on(e)
    }

    function ja(t) {
        this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new Ue(512, 512), this.map = null, this.matrix = new Be
    }

    function ka() {
        ja.call(this, new ai(50, 1, .5, 500))
    }

    function Ua(t, e, n, r, i, o) {
        Oa.call(this, t, e), this.type = "SpotLight", this.position.copy(vn.DefaultUp), this.updateMatrix(), this.target = new vn, Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI
            },
            set: function(t) {
                this.intensity = t / Math.PI
            }
        }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.penumbra = void 0 !== i ? i : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new ka
    }

    function Ba(t, e, n, r) {
        Oa.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI
            },
            set: function(t) {
                this.intensity = t / (4 * Math.PI)
            }
        }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== r ? r : 1, this.shadow = new ja(new ai(90, 1, .5, 500))
    }

    function Na(t, e, n, r, i, o) {
        oi.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = r, this.near = void 0 !== i ? i : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
    }

    function Ga() {
        ja.call(this, new Na(-5, 5, 5, -5, .5, 500))
    }

    function Ha(t, e) {
        Oa.call(this, t, e), this.type = "DirectionalLight", this.position.copy(vn.DefaultUp), this.updateMatrix(), this.target = new vn, this.shadow = new Ga
    }

    function Va(t, e) {
        Oa.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
    }

    function Wa(t, e, n, r) {
        Oa.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== r ? r : 10
    }
    Ra.prototype = Object.assign(Object.create(fa.prototype), {
        constructor: Ra,
        add: function(t) {
            this.curves.push(t)
        },
        closePath: function() {
            var t = this.curves[0].getPoint(0),
                e = this.curves[this.curves.length - 1].getPoint(1);
            t.equals(e) || this.curves.push(new Ta(e, t))
        },
        getPoint: function(t) {
            for (var e = t * this.getLength(), n = this.getCurveLengths(), r = 0; r < n.length;) {
                if (n[r] >= e) {
                    var i = n[r] - e,
                        o = this.curves[r],
                        a = o.getLength(),
                        s = 0 === a ? 0 : 1 - i / a;
                    return o.getPointAt(s)
                }
                r++
            }
            return null
        },
        getLength: function() {
            var t = this.getCurveLengths();
            return t[t.length - 1]
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            for (var t = [], e = 0, n = 0, r = this.curves.length; n < r; n++) e += this.curves[n].getLength(), t.push(e);
            return this.cacheLengths = t, t
        },
        getSpacedPoints: function(t) {
            void 0 === t && (t = 40);
            for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
            return this.autoClose && e.push(e[0]), e
        },
        getPoints: function(t) {
            t = t || 12;
            for (var e, n = [], r = 0, i = this.curves; r < i.length; r++)
                for (var o = i[r], a = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t, s = o.getPoints(a), c = 0; c < s.length; c++) {
                    var u = s[c];
                    e && e.equals(u) || (n.push(u), e = u)
                }
            return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
        },
        copy: function(t) {
            fa.prototype.copy.call(this, t), this.curves = [];
            for (var e = 0, n = t.curves.length; e < n; e++) {
                var r = t.curves[e];
                this.curves.push(r.clone())
            }
            return this.autoClose = t.autoClose, this
        },
        toJSON: function() {
            var t = fa.prototype.toJSON.call(this);
            t.autoClose = this.autoClose, t.curves = [];
            for (var e = 0, n = this.curves.length; e < n; e++) {
                var r = this.curves[e];
                t.curves.push(r.toJSON())
            }
            return t
        },
        fromJSON: function(t) {
            fa.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
            for (var e = 0, n = t.curves.length; e < n; e++) {
                var r = t.curves[e];
                this.curves.push((new Ca[r.type]).fromJSON(r))
            }
            return this
        }
    }), Ia.prototype = Object.assign(Object.create(Ra.prototype), {
        constructor: Ia,
        setFromPoints: function(t) {
            this.moveTo(t[0].x, t[0].y);
            for (var e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y)
        },
        moveTo: function(t, e) {
            this.currentPoint.set(t, e)
        },
        lineTo: function(t, e) {
            var n = new Ta(this.currentPoint.clone(), new Ue(t, e));
            this.curves.push(n), this.currentPoint.set(t, e)
        },
        quadraticCurveTo: function(t, e, n, r) {
            var i = new La(this.currentPoint.clone(), new Ue(t, e), new Ue(n, r));
            this.curves.push(i), this.currentPoint.set(n, r)
        },
        bezierCurveTo: function(t, e, n, r, i, o) {
            var a = new Sa(this.currentPoint.clone(), new Ue(t, e), new Ue(n, r), new Ue(i, o));
            this.curves.push(a), this.currentPoint.set(i, o)
        },
        splineThru: function(t) {
            var e = new za([this.currentPoint.clone()].concat(t));
            this.curves.push(e), this.currentPoint.copy(t[t.length - 1])
        },
        arc: function(t, e, n, r, i, o) {
            var a = this.currentPoint.x,
                s = this.currentPoint.y;
            this.absarc(t + a, e + s, n, r, i, o)
        },
        absarc: function(t, e, n, r, i, o) {
            this.absellipse(t, e, n, n, r, i, o)
        },
        ellipse: function(t, e, n, r, i, o, a, s) {
            var c = this.currentPoint.x,
                u = this.currentPoint.y;
            this.absellipse(t + c, e + u, n, r, i, o, a, s)
        },
        absellipse: function(t, e, n, r, i, o, a, s) {
            var c = new da(t, e, n, r, i, o, a, s);
            if (this.curves.length > 0) {
                var u = c.getPoint(0);
                u.equals(this.currentPoint) || this.lineTo(u.x, u.y)
            }
            this.curves.push(c);
            var l = c.getPoint(1);
            this.currentPoint.copy(l)
        },
        copy: function(t) {
            return Ra.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
        },
        toJSON: function() {
            var t = Ra.prototype.toJSON.call(this);
            return t.currentPoint = this.currentPoint.toArray(), t
        },
        fromJSON: function(t) {
            return Ra.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this
        }
    }), Da.prototype = Object.assign(Object.create(Ia.prototype), {
        constructor: Da,
        getPointsHoles: function(t) {
            for (var e = [], n = 0, r = this.holes.length; n < r; n++) e[n] = this.holes[n].getPoints(t);
            return e
        },
        extractPoints: function(t) {
            return {
                shape: this.getPoints(t),
                holes: this.getPointsHoles(t)
            }
        },
        copy: function(t) {
            Ia.prototype.copy.call(this, t), this.holes = [];
            for (var e = 0, n = t.holes.length; e < n; e++) {
                var r = t.holes[e];
                this.holes.push(r.clone())
            }
            return this
        },
        toJSON: function() {
            var t = Ia.prototype.toJSON.call(this);
            t.uuid = this.uuid, t.holes = [];
            for (var e = 0, n = this.holes.length; e < n; e++) {
                var r = this.holes[e];
                t.holes.push(r.toJSON())
            }
            return t
        },
        fromJSON: function(t) {
            Ia.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
            for (var e = 0, n = t.holes.length; e < n; e++) {
                var r = t.holes[e];
                this.holes.push((new Ia).fromJSON(r))
            }
            return this
        }
    }), Oa.prototype = Object.assign(Object.create(vn.prototype), {
        constructor: Oa,
        isLight: !0,
        copy: function(t) {
            return vn.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
        },
        toJSON: function(t) {
            var e = vn.prototype.toJSON.call(this, t);
            return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
        }
    }), Fa.prototype = Object.assign(Object.create(Oa.prototype), {
        constructor: Fa,
        isHemisphereLight: !0,
        copy: function(t) {
            return Oa.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
        }
    }), Object.assign(ja.prototype, {
        copy: function(t) {
            return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var t = {};
            return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
        }
    }), ka.prototype = Object.assign(Object.create(ja.prototype), {
        constructor: ka,
        isSpotLightShadow: !0,
        update: function(t) {
            var e = this.camera,
                n = 2 * ke.RAD2DEG * t.angle,
                r = this.mapSize.width / this.mapSize.height,
                i = t.distance || e.far;
            n === e.fov && r === e.aspect && i === e.far || (e.fov = n, e.aspect = r, e.far = i, e.updateProjectionMatrix())
        }
    }), Ua.prototype = Object.assign(Object.create(Oa.prototype), {
        constructor: Ua,
        isSpotLight: !0,
        copy: function(t) {
            return Oa.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
        }
    }), Ba.prototype = Object.assign(Object.create(Oa.prototype), {
        constructor: Ba,
        isPointLight: !0,
        copy: function(t) {
            return Oa.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
        }
    }), Na.prototype = Object.assign(Object.create(oi.prototype), {
        constructor: Na,
        isOrthographicCamera: !0,
        copy: function(t, e) {
            return oi.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
        },
        setViewOffset: function(t, e, n, r, i, o) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var t = (this.right - this.left) / (2 * this.zoom),
                e = (this.top - this.bottom) / (2 * this.zoom),
                n = (this.right + this.left) / 2,
                r = (this.top + this.bottom) / 2,
                i = n - t,
                o = n + t,
                a = r + e,
                s = r - e;
            if (null !== this.view && this.view.enabled) {
                var c = this.zoom / (this.view.width / this.view.fullWidth),
                    u = this.zoom / (this.view.height / this.view.fullHeight),
                    l = (this.right - this.left) / this.view.width,
                    h = (this.top - this.bottom) / this.view.height;
                o = (i += l * (this.view.offsetX / c)) + l * (this.view.width / c), s = (a -= h * (this.view.offsetY / u)) - h * (this.view.height / u)
            }
            this.projectionMatrix.makeOrthographic(i, o, a, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(t) {
            var e = vn.prototype.toJSON.call(this, t);
            return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
        }
    }), Ga.prototype = Object.assign(Object.create(ja.prototype), {
        constructor: Ga
    }), Ha.prototype = Object.assign(Object.create(Oa.prototype), {
        constructor: Ha,
        isDirectionalLight: !0,
        copy: function(t) {
            return Oa.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
        }
    }), Va.prototype = Object.assign(Object.create(Oa.prototype), {
        constructor: Va,
        isAmbientLight: !0
    }), Wa.prototype = Object.assign(Object.create(Oa.prototype), {
        constructor: Wa,
        isRectAreaLight: !0,
        copy: function(t) {
            return Oa.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
        },
        toJSON: function(t) {
            var e = Oa.prototype.toJSON.call(this, t);
            return e.object.width = this.width, e.object.height = this.height, e
        }
    });
    var Ya = {
        arraySlice: function(t, e, n) {
            return Ya.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
        },
        convertArray: function(t, e, n) {
            return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
        },
        isTypedArray: function(t) {
            return ArrayBuffer.isView(t) && !(t instanceof DataView)
        },
        getKeyframeOrder: function(t) {
            for (var e = t.length, n = new Array(e), r = 0; r !== e; ++r) n[r] = r;
            return n.sort(function(e, n) {
                return t[e] - t[n]
            }), n
        },
        sortedArray: function(t, e, n) {
            for (var r = t.length, i = new t.constructor(r), o = 0, a = 0; a !== r; ++o)
                for (var s = n[o] * e, c = 0; c !== e; ++c) i[a++] = t[s + c];
            return i
        },
        flattenJSON: function(t, e, n, r) {
            for (var i = 1, o = t[0]; void 0 !== o && void 0 === o[r];) o = t[i++];
            if (void 0 !== o) {
                var a = o[r];
                if (void 0 !== a)
                    if (Array.isArray(a))
                        do {
                            void 0 !== (a = o[r]) && (e.push(o.time), n.push.apply(n, a)), o = t[i++]
                        } while (void 0 !== o);
                    else if (void 0 !== a.toArray)
                    do {
                        void 0 !== (a = o[r]) && (e.push(o.time), a.toArray(n, n.length)), o = t[i++]
                    } while (void 0 !== o);
                else
                    do {
                        void 0 !== (a = o[r]) && (e.push(o.time), n.push(a)), o = t[i++]
                    } while (void 0 !== o)
            }
        }
    };

    function Xa(t, e, n, r) {
        this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new e.constructor(n), this.sampleValues = e, this.valueSize = n
    }

    function qa(t, e, n, r) {
        Xa.call(this, t, e, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
    }

    function Ka(t, e, n, r) {
        Xa.call(this, t, e, n, r)
    }

    function Za(t, e, n, r) {
        Xa.call(this, t, e, n, r)
    }

    function Ja(t, e, n, r) {
        if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
        this.name = t, this.times = Ya.convertArray(e, this.TimeBufferType), this.values = Ya.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
    }

    function Qa(t, e, n) {
        Ja.call(this, t, e, n)
    }

    function $a(t, e, n, r) {
        Ja.call(this, t, e, n, r)
    }

    function ts(t, e, n, r) {
        Ja.call(this, t, e, n, r)
    }

    function es(t, e, n, r) {
        Xa.call(this, t, e, n, r)
    }

    function ns(t, e, n, r) {
        Ja.call(this, t, e, n, r)
    }

    function rs(t, e, n, r) {
        Ja.call(this, t, e, n, r)
    }

    function is(t, e, n, r) {
        Ja.call(this, t, e, n, r)
    }

    function os(t, e, n) {
        this.name = t, this.tracks = n, this.duration = void 0 !== e ? e : -1, this.uuid = ke.generateUUID(), this.duration < 0 && this.resetDuration()
    }

    function as(t) {
        if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        var e = function(t) {
            switch (t.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return ts;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return is;
                case "color":
                    return $a;
                case "quaternion":
                    return ns;
                case "bool":
                case "boolean":
                    return Qa;
                case "string":
                    return rs
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
        }(t.type);
        if (void 0 === t.times) {
            var n = [],
                r = [];
            Ya.flattenJSON(t.keys, n, r, "value"), t.times = n, t.values = r
        }
        return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
    }

    function ss(t) {
        this.manager = void 0 !== t ? t : ia, this.textures = {}
    }

    function cs(t) {
        this.manager = void 0 !== t ? t : ia
    }
    Object.assign(Xa.prototype, {
            evaluate: function(t) {
                var e = this.parameterPositions,
                    n = this._cachedIndex,
                    r = e[n],
                    i = e[n - 1];
                t: {
                    e: {
                        var o;
                        n: {
                            r: if (!(t < r)) {
                                for (var a = n + 2;;) {
                                    if (void 0 === r) {
                                        if (t < i) break r;
                                        return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, i)
                                    }
                                    if (n === a) break;
                                    if (i = r, t < (r = e[++n])) break e
                                }
                                o = e.length;
                                break n
                            }if (t >= i) break t;
                            var s = e[1];t < s && (n = 2, i = s);
                            for (a = n - 2;;) {
                                if (void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
                                if (n === a) break;
                                if (r = i, t >= (i = e[--n - 1])) break e
                            }
                            o = n,
                            n = 0
                        }
                        for (; n < o;) {
                            var c = n + o >>> 1;
                            t < e[c] ? o = c : n = c + 1
                        }
                        if (r = e[n], void 0 === (i = e[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
                        if (void 0 === r) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, i, t)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, i, r)
                }
                return this.interpolate_(n, i, t, r)
            },
            settings: null,
            DefaultSettings_: {},
            getSettings_: function() {
                return this.settings || this.DefaultSettings_
            },
            copySampleValue_: function(t) {
                for (var e = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = t * r, o = 0; o !== r; ++o) e[o] = n[i + o];
                return e
            },
            interpolate_: function() {
                throw new Error("call to abstract method")
            },
            intervalChanged_: function() {}
        }),
        //!\ DECLARE ALIAS AFTER assign prototype !
        Object.assign(Xa.prototype, {
            beforeStart_: Xa.prototype.copySampleValue_,
            afterEnd_: Xa.prototype.copySampleValue_
        }), qa.prototype = Object.assign(Object.create(Xa.prototype), {
            constructor: qa,
            DefaultSettings_: {
                endingStart: be,
                endingEnd: be
            },
            intervalChanged_: function(t, e, n) {
                var r = this.parameterPositions,
                    i = t - 2,
                    o = t + 1,
                    a = r[i],
                    s = r[o];
                if (void 0 === a) switch (this.getSettings_().endingStart) {
                    case we:
                        i = t, a = 2 * e - n;
                        break;
                    case _e:
                        a = e + r[i = r.length - 2] - r[i + 1];
                        break;
                    default:
                        i = t, a = n
                }
                if (void 0 === s) switch (this.getSettings_().endingEnd) {
                    case we:
                        o = t, s = 2 * n - e;
                        break;
                    case _e:
                        o = 1, s = n + r[1] - r[0];
                        break;
                    default:
                        o = t - 1, s = e
                }
                var c = .5 * (n - e),
                    u = this.valueSize;
                this._weightPrev = c / (e - a), this._weightNext = c / (s - n), this._offsetPrev = i * u, this._offsetNext = o * u
            },
            interpolate_: function(t, e, n, r) {
                for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = s - a, u = this._offsetPrev, l = this._offsetNext, h = this._weightPrev, f = this._weightNext, d = (n - e) / (r - e), v = d * d, p = v * d, m = -h * p + 2 * h * v - h * d, g = (1 + h) * p + (-1.5 - 2 * h) * v + (-.5 + h) * d + 1, y = (-1 - f) * p + (1.5 + f) * v + .5 * d, x = f * p - f * v, b = 0; b !== a; ++b) i[b] = m * o[u + b] + g * o[c + b] + y * o[s + b] + x * o[l + b];
                return i
            }
        }), Ka.prototype = Object.assign(Object.create(Xa.prototype), {
            constructor: Ka,
            interpolate_: function(t, e, n, r) {
                for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = s - a, u = (n - e) / (r - e), l = 1 - u, h = 0; h !== a; ++h) i[h] = o[c + h] * l + o[s + h] * u;
                return i
            }
        }), Za.prototype = Object.assign(Object.create(Xa.prototype), {
            constructor: Za,
            interpolate_: function(t) {
                return this.copySampleValue_(t - 1)
            }
        }), Object.assign(Ja, {
            toJSON: function(t) {
                var e, n = t.constructor;
                if (void 0 !== n.toJSON) e = n.toJSON(t);
                else {
                    e = {
                        name: t.name,
                        times: Ya.convertArray(t.times, Array),
                        values: Ya.convertArray(t.values, Array)
                    };
                    var r = t.getInterpolation();
                    r !== t.DefaultInterpolation && (e.interpolation = r)
                }
                return e.type = t.ValueTypeName, e
            }
        }), Object.assign(Ja.prototype, {
            constructor: Ja,
            TimeBufferType: Float32Array,
            ValueBufferType: Float32Array,
            DefaultInterpolation: ye,
            InterpolantFactoryMethodDiscrete: function(t) {
                return new Za(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodLinear: function(t) {
                return new Ka(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodSmooth: function(t) {
                return new qa(this.times, this.values, this.getValueSize(), t)
            },
            setInterpolation: function(t) {
                var e;
                switch (t) {
                    case ge:
                        e = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case ye:
                        e = this.InterpolantFactoryMethodLinear;
                        break;
                    case xe:
                        e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === e) {
                    var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation) throw new Error(n);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", n), this
                }
                return this.createInterpolant = e, this
            },
            getInterpolation: function() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return ge;
                    case this.InterpolantFactoryMethodLinear:
                        return ye;
                    case this.InterpolantFactoryMethodSmooth:
                        return xe
                }
            },
            getValueSize: function() {
                return this.values.length / this.times.length
            },
            shift: function(t) {
                if (0 !== t)
                    for (var e = this.times, n = 0, r = e.length; n !== r; ++n) e[n] += t;
                return this
            },
            scale: function(t) {
                if (1 !== t)
                    for (var e = this.times, n = 0, r = e.length; n !== r; ++n) e[n] *= t;
                return this
            },
            trim: function(t, e) {
                for (var n = this.times, r = n.length, i = 0, o = r - 1; i !== r && n[i] < t;) ++i;
                for (; - 1 !== o && n[o] > e;) --o;
                if (++o, 0 !== i || o !== r) {
                    i >= o && (i = (o = Math.max(o, 1)) - 1);
                    var a = this.getValueSize();
                    this.times = Ya.arraySlice(n, i, o), this.values = Ya.arraySlice(this.values, i * a, o * a)
                }
                return this
            },
            validate: function() {
                var t = !0,
                    e = this.getValueSize();
                e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                var n = this.times,
                    r = this.values,
                    i = n.length;
                0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                for (var o = null, a = 0; a !== i; a++) {
                    var s = n[a];
                    if ("number" == typeof s && isNaN(s)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, s), t = !1;
                        break
                    }
                    if (null !== o && o > s) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, s, o), t = !1;
                        break
                    }
                    o = s
                }
                if (void 0 !== r && Ya.isTypedArray(r)) {
                    a = 0;
                    for (var c = r.length; a !== c; ++a) {
                        var u = r[a];
                        if (isNaN(u)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, u), t = !1;
                            break
                        }
                    }
                }
                return t
            },
            optimize: function() {
                for (var t = this.times, e = this.values, n = this.getValueSize(), r = this.getInterpolation() === xe, i = 1, o = t.length - 1, a = 1; a < o; ++a) {
                    var s = !1,
                        c = t[a];
                    if (c !== t[a + 1] && (1 !== a || c !== c[0]))
                        if (r) s = !0;
                        else
                            for (var u = a * n, l = u - n, h = u + n, f = 0; f !== n; ++f) {
                                var d = e[u + f];
                                if (d !== e[l + f] || d !== e[h + f]) {
                                    s = !0;
                                    break
                                }
                            }
                        if (s) {
                            if (a !== i) {
                                t[i] = t[a];
                                var v = a * n,
                                    p = i * n;
                                for (f = 0; f !== n; ++f) e[p + f] = e[v + f]
                            }++i
                        }
                }
                if (o > 0) {
                    t[i] = t[o];
                    for (v = o * n, p = i * n, f = 0; f !== n; ++f) e[p + f] = e[v + f];
                    ++i
                }
                return i !== t.length && (this.times = Ya.arraySlice(t, 0, i), this.values = Ya.arraySlice(e, 0, i * n)), this
            }
        }), Qa.prototype = Object.assign(Object.create(Ja.prototype), {
            constructor: Qa,
            ValueTypeName: "bool",
            ValueBufferType: Array,
            DefaultInterpolation: ge,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), $a.prototype = Object.assign(Object.create(Ja.prototype), {
            constructor: $a,
            ValueTypeName: "color"
        }), ts.prototype = Object.assign(Object.create(Ja.prototype), {
            constructor: ts,
            ValueTypeName: "number"
        }), es.prototype = Object.assign(Object.create(Xa.prototype), {
            constructor: es,
            interpolate_: function(t, e, n, r) {
                for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = (n - e) / (r - e), u = s + a; s !== u; s += 4) Ne.slerpFlat(i, 0, o, s - a, o, s, c);
                return i
            }
        }), ns.prototype = Object.assign(Object.create(Ja.prototype), {
            constructor: ns,
            ValueTypeName: "quaternion",
            DefaultInterpolation: ye,
            InterpolantFactoryMethodLinear: function(t) {
                return new es(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodSmooth: void 0
        }), rs.prototype = Object.assign(Object.create(Ja.prototype), {
            constructor: rs,
            ValueTypeName: "string",
            ValueBufferType: Array,
            DefaultInterpolation: ge,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), is.prototype = Object.assign(Object.create(Ja.prototype), {
            constructor: is,
            ValueTypeName: "vector"
        }), Object.assign(os, {
            parse: function(t) {
                for (var e = [], n = t.tracks, r = 1 / (t.fps || 1), i = 0, o = n.length; i !== o; ++i) e.push(as(n[i]).scale(r));
                return new os(t.name, t.duration, e)
            },
            toJSON: function(t) {
                for (var e = [], n = t.tracks, r = {
                        name: t.name,
                        duration: t.duration,
                        tracks: e,
                        uuid: t.uuid
                    }, i = 0, o = n.length; i !== o; ++i) e.push(Ja.toJSON(n[i]));
                return r
            },
            CreateFromMorphTargetSequence: function(t, e, n, r) {
                for (var i = e.length, o = [], a = 0; a < i; a++) {
                    var s = [],
                        c = [];
                    s.push((a + i - 1) % i, a, (a + 1) % i), c.push(0, 1, 0);
                    var u = Ya.getKeyframeOrder(s);
                    s = Ya.sortedArray(s, 1, u), c = Ya.sortedArray(c, 1, u), r || 0 !== s[0] || (s.push(i), c.push(c[0])), o.push(new ts(".morphTargetInfluences[" + e[a].name + "]", s, c).scale(1 / n))
                }
                return new os(t, -1, o)
            },
            findByName: function(t, e) {
                var n = t;
                if (!Array.isArray(t)) {
                    var r = t;
                    n = r.geometry && r.geometry.animations || r.animations
                }
                for (var i = 0; i < n.length; i++)
                    if (n[i].name === e) return n[i];
                return null
            },
            CreateClipsFromMorphTargetSequences: function(t, e, n) {
                for (var r = {}, i = /^([\w-]*?)([\d]+)$/, o = 0, a = t.length; o < a; o++) {
                    var s = t[o],
                        c = s.name.match(i);
                    if (c && c.length > 1) {
                        var u = r[h = c[1]];
                        u || (r[h] = u = []), u.push(s)
                    }
                }
                var l = [];
                for (var h in r) l.push(os.CreateFromMorphTargetSequence(h, r[h], e, n));
                return l
            },
            parseAnimation: function(t, e) {
                if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                for (var n = function(t, e, n, r, i) {
                        if (0 !== n.length) {
                            var o = [],
                                a = [];
                            Ya.flattenJSON(n, o, a, r), 0 !== o.length && i.push(new t(e, o, a))
                        }
                    }, r = [], i = t.name || "default", o = t.length || -1, a = t.fps || 30, s = t.hierarchy || [], c = 0; c < s.length; c++) {
                    var u = s[c].keys;
                    if (u && 0 !== u.length)
                        if (u[0].morphTargets) {
                            for (var l = {}, h = 0; h < u.length; h++)
                                if (u[h].morphTargets)
                                    for (var f = 0; f < u[h].morphTargets.length; f++) l[u[h].morphTargets[f]] = -1;
                            for (var d in l) {
                                var v = [],
                                    p = [];
                                for (f = 0; f !== u[h].morphTargets.length; ++f) {
                                    var m = u[h];
                                    v.push(m.time), p.push(m.morphTarget === d ? 1 : 0)
                                }
                                r.push(new ts(".morphTargetInfluence[" + d + "]", v, p))
                            }
                            o = l.length * (a || 1)
                        } else {
                            var g = ".bones[" + e[c].name + "]";
                            n(is, g + ".position", u, "pos", r), n(ns, g + ".quaternion", u, "rot", r), n(is, g + ".scale", u, "scl", r)
                        }
                }
                return 0 === r.length ? null : new os(i, o, r)
            }
        }), Object.assign(os.prototype, {
            resetDuration: function() {
                for (var t = 0, e = 0, n = this.tracks.length; e !== n; ++e) {
                    var r = this.tracks[e];
                    t = Math.max(t, r.times[r.times.length - 1])
                }
                return this.duration = t, this
            },
            trim: function() {
                for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                return this
            },
            validate: function() {
                for (var t = !0, e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                return t
            },
            optimize: function() {
                for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                return this
            }
        }), Object.assign(ss.prototype, {
            load: function(t, e, n, r) {
                var i = this;
                new aa(i.manager).load(t, function(t) {
                    e(i.parse(JSON.parse(t)))
                }, n, r)
            },
            setTextures: function(t) {
                this.textures = t
            },
            parse: function(t) {
                var e = this.textures;

                function n(t) {
                    return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
                }
                var r = new ea[t.type];
                if (void 0 !== t.uuid && (r.uuid = t.uuid), void 0 !== t.name && (r.name = t.name), void 0 !== t.color && r.color.setHex(t.color), void 0 !== t.roughness && (r.roughness = t.roughness), void 0 !== t.metalness && (r.metalness = t.metalness), void 0 !== t.emissive && r.emissive.setHex(t.emissive), void 0 !== t.specular && r.specular.setHex(t.specular), void 0 !== t.shininess && (r.shininess = t.shininess), void 0 !== t.clearCoat && (r.clearCoat = t.clearCoat), void 0 !== t.clearCoatRoughness && (r.clearCoatRoughness = t.clearCoatRoughness), void 0 !== t.vertexColors && (r.vertexColors = t.vertexColors), void 0 !== t.fog && (r.fog = t.fog), void 0 !== t.flatShading && (r.flatShading = t.flatShading), void 0 !== t.blending && (r.blending = t.blending), void 0 !== t.combine && (r.combine = t.combine), void 0 !== t.side && (r.side = t.side), void 0 !== t.opacity && (r.opacity = t.opacity), void 0 !== t.transparent && (r.transparent = t.transparent), void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest), void 0 !== t.depthTest && (r.depthTest = t.depthTest), void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite), void 0 !== t.wireframe && (r.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (r.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (r.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (r.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (r.rotation = t.rotation), 1 !== t.linewidth && (r.linewidth = t.linewidth), void 0 !== t.dashSize && (r.dashSize = t.dashSize), void 0 !== t.gapSize && (r.gapSize = t.gapSize), void 0 !== t.scale && (r.scale = t.scale), void 0 !== t.polygonOffset && (r.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (r.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (r.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (r.skinning = t.skinning), void 0 !== t.morphTargets && (r.morphTargets = t.morphTargets), void 0 !== t.dithering && (r.dithering = t.dithering), void 0 !== t.visible && (r.visible = t.visible), void 0 !== t.userData && (r.userData = t.userData), void 0 !== t.uniforms)
                    for (var i in t.uniforms) {
                        var o = t.uniforms[i];
                        switch (r.uniforms[i] = {}, o.type) {
                            case "t":
                                r.uniforms[i].value = n(o.value);
                                break;
                            case "c":
                                r.uniforms[i].value = (new on).setHex(o.value);
                                break;
                            case "v2":
                                r.uniforms[i].value = (new Ue).fromArray(o.value);
                                break;
                            case "v3":
                                r.uniforms[i].value = (new Ge).fromArray(o.value);
                                break;
                            case "v4":
                                r.uniforms[i].value = (new Xe).fromArray(o.value);
                                break;
                            case "m4":
                                r.uniforms[i].value = (new Be).fromArray(o.value);
                                break;
                            default:
                                r.uniforms[i].value = o.value
                        }
                    }
                if (void 0 !== t.defines && (r.defines = t.defines), void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (r.fragmentShader = t.fragmentShader), void 0 !== t.shading && (r.flatShading = 1 === t.shading), void 0 !== t.size && (r.size = t.size), void 0 !== t.sizeAttenuation && (r.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (r.map = n(t.map)), void 0 !== t.alphaMap && (r.alphaMap = n(t.alphaMap), r.transparent = !0), void 0 !== t.bumpMap && (r.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale), void 0 !== t.normalMap && (r.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (r.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
                    var a = t.normalScale;
                    !1 === Array.isArray(a) && (a = [a, a]), r.normalScale = (new Ue).fromArray(a)
                }
                return void 0 !== t.displacementMap && (r.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (r.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (r.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (r.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (r.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (r.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (r.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (r.specularMap = n(t.specularMap)), void 0 !== t.envMap && (r.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (r.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity), void 0 !== t.lightMap && (r.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (r.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (r.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (r.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (r.gradientMap = n(t.gradientMap)), r
            }
        }), Object.assign(cs.prototype, {
            load: function(t, e, n, r) {
                var i = this;
                new aa(i.manager).load(t, function(t) {
                    e(i.parse(JSON.parse(t)))
                }, n, r)
            },
            parse: function(t) {
                var e = new zn,
                    n = t.data.index;
                if (void 0 !== n) {
                    var r = new us[n.type](n.array);
                    e.setIndex(new gn(r, 1))
                }
                var i = t.data.attributes;
                for (var o in i) {
                    var a = i[o];
                    r = new us[a.type](a.array);
                    e.addAttribute(o, new gn(r, a.itemSize, a.normalized))
                }
                var s = t.data.groups || t.data.drawcalls || t.data.offsets;
                if (void 0 !== s)
                    for (var c = 0, u = s.length; c !== u; ++c) {
                        var l = s[c];
                        e.addGroup(l.start, l.count, l.materialIndex)
                    }
                var h = t.data.boundingSphere;
                if (void 0 !== h) {
                    var f = new Ge;
                    void 0 !== h.center && f.fromArray(h.center), e.boundingSphere = new Qe(f, h.radius)
                }
                return e
            }
        });
    var us = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };

    function ls() {}
    ls.Handlers = {
        handlers: [],
        add: function(t, e) {
            this.handlers.push(t, e)
        },
        get: function(t) {
            for (var e = this.handlers, n = 0, r = e.length; n < r; n += 2) {
                var i = e[n],
                    o = e[n + 1];
                if (i.test(t)) return o
            }
            return null
        }
    }, Object.assign(ls.prototype, {
        crossOrigin: "anonymous",
        onLoadStart: function() {},
        onLoadProgress: function() {},
        onLoadComplete: function() {},
        initMaterials: function(t, e, n) {
            for (var r = [], i = 0; i < t.length; ++i) r[i] = this.createMaterial(t[i], e, n);
            return r
        },
        createMaterial: function() {
            var t = {
                    NoBlending: M,
                    NormalBlending: S,
                    AdditiveBlending: E,
                    SubtractiveBlending: T,
                    MultiplyBlending: P,
                    CustomBlending: L
                },
                e = new on,
                n = new ha,
                r = new ss;
            return function(i, o, a) {
                var s = {};

                function c(t, e, r, i, c) {
                    var u, l = o + t,
                        h = ls.Handlers.get(l);
                    null !== h ? u = h.load(l) : (n.setCrossOrigin(a), u = n.load(l)), void 0 !== e && (u.repeat.fromArray(e), 1 !== e[0] && (u.wrapS = pt), 1 !== e[1] && (u.wrapT = pt)), void 0 !== r && u.offset.fromArray(r), void 0 !== i && ("repeat" === i[0] && (u.wrapS = pt), "mirror" === i[0] && (u.wrapS = gt), "repeat" === i[1] && (u.wrapT = pt), "mirror" === i[1] && (u.wrapT = gt)), void 0 !== c && (u.anisotropy = c);
                    var f = ke.generateUUID();
                    return s[f] = u, f
                }
                var u = {
                    uuid: ke.generateUUID(),
                    type: "MeshLambertMaterial"
                };
                for (var l in i) {
                    var h = i[l];
                    switch (l) {
                        case "DbgColor":
                        case "DbgIndex":
                        case "opticalDensity":
                        case "illumination":
                            break;
                        case "DbgName":
                            u.name = h;
                            break;
                        case "blending":
                            u.blending = t[h];
                            break;
                        case "colorAmbient":
                        case "mapAmbient":
                            console.warn("THREE.Loader.createMaterial:", l, "is no longer supported.");
                            break;
                        case "colorDiffuse":
                            u.color = e.fromArray(h).getHex();
                            break;
                        case "colorSpecular":
                            u.specular = e.fromArray(h).getHex();
                            break;
                        case "colorEmissive":
                            u.emissive = e.fromArray(h).getHex();
                            break;
                        case "specularCoef":
                            u.shininess = h;
                            break;
                        case "shading":
                            "basic" === h.toLowerCase() && (u.type = "MeshBasicMaterial"), "phong" === h.toLowerCase() && (u.type = "MeshPhongMaterial"), "standard" === h.toLowerCase() && (u.type = "MeshStandardMaterial");
                            break;
                        case "mapDiffuse":
                            u.map = c(h, i.mapDiffuseRepeat, i.mapDiffuseOffset, i.mapDiffuseWrap, i.mapDiffuseAnisotropy);
                            break;
                        case "mapDiffuseRepeat":
                        case "mapDiffuseOffset":
                        case "mapDiffuseWrap":
                        case "mapDiffuseAnisotropy":
                            break;
                        case "mapEmissive":
                            u.emissiveMap = c(h, i.mapEmissiveRepeat, i.mapEmissiveOffset, i.mapEmissiveWrap, i.mapEmissiveAnisotropy);
                            break;
                        case "mapEmissiveRepeat":
                        case "mapEmissiveOffset":
                        case "mapEmissiveWrap":
                        case "mapEmissiveAnisotropy":
                            break;
                        case "mapLight":
                            u.lightMap = c(h, i.mapLightRepeat, i.mapLightOffset, i.mapLightWrap, i.mapLightAnisotropy);
                            break;
                        case "mapLightRepeat":
                        case "mapLightOffset":
                        case "mapLightWrap":
                        case "mapLightAnisotropy":
                            break;
                        case "mapAO":
                            u.aoMap = c(h, i.mapAORepeat, i.mapAOOffset, i.mapAOWrap, i.mapAOAnisotropy);
                            break;
                        case "mapAORepeat":
                        case "mapAOOffset":
                        case "mapAOWrap":
                        case "mapAOAnisotropy":
                            break;
                        case "mapBump":
                            u.bumpMap = c(h, i.mapBumpRepeat, i.mapBumpOffset, i.mapBumpWrap, i.mapBumpAnisotropy);
                            break;
                        case "mapBumpScale":
                            u.bumpScale = h;
                            break;
                        case "mapBumpRepeat":
                        case "mapBumpOffset":
                        case "mapBumpWrap":
                        case "mapBumpAnisotropy":
                            break;
                        case "mapNormal":
                            u.normalMap = c(h, i.mapNormalRepeat, i.mapNormalOffset, i.mapNormalWrap, i.mapNormalAnisotropy);
                            break;
                        case "mapNormalFactor":
                            u.normalScale = h;
                            break;
                        case "mapNormalRepeat":
                        case "mapNormalOffset":
                        case "mapNormalWrap":
                        case "mapNormalAnisotropy":
                            break;
                        case "mapSpecular":
                            u.specularMap = c(h, i.mapSpecularRepeat, i.mapSpecularOffset, i.mapSpecularWrap, i.mapSpecularAnisotropy);
                            break;
                        case "mapSpecularRepeat":
                        case "mapSpecularOffset":
                        case "mapSpecularWrap":
                        case "mapSpecularAnisotropy":
                            break;
                        case "mapMetalness":
                            u.metalnessMap = c(h, i.mapMetalnessRepeat, i.mapMetalnessOffset, i.mapMetalnessWrap, i.mapMetalnessAnisotropy);
                            break;
                        case "mapMetalnessRepeat":
                        case "mapMetalnessOffset":
                        case "mapMetalnessWrap":
                        case "mapMetalnessAnisotropy":
                            break;
                        case "mapRoughness":
                            u.roughnessMap = c(h, i.mapRoughnessRepeat, i.mapRoughnessOffset, i.mapRoughnessWrap, i.mapRoughnessAnisotropy);
                            break;
                        case "mapRoughnessRepeat":
                        case "mapRoughnessOffset":
                        case "mapRoughnessWrap":
                        case "mapRoughnessAnisotropy":
                            break;
                        case "mapAlpha":
                            u.alphaMap = c(h, i.mapAlphaRepeat, i.mapAlphaOffset, i.mapAlphaWrap, i.mapAlphaAnisotropy);
                            break;
                        case "mapAlphaRepeat":
                        case "mapAlphaOffset":
                        case "mapAlphaWrap":
                        case "mapAlphaAnisotropy":
                            break;
                        case "flipSided":
                            u.side = m;
                            break;
                        case "doubleSided":
                            u.side = g;
                            break;
                        case "transparency":
                            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), u.opacity = h;
                            break;
                        case "depthTest":
                        case "depthWrite":
                        case "colorWrite":
                        case "opacity":
                        case "reflectivity":
                        case "transparent":
                        case "visible":
                        case "wireframe":
                            u[l] = h;
                            break;
                        case "vertexColors":
                            !0 === h && (u.vertexColors = _), "face" === h && (u.vertexColors = w);
                            break;
                        default:
                            console.error("THREE.Loader.createMaterial: Unsupported", l, h)
                    }
                }
                return "MeshBasicMaterial" === u.type && delete u.emissive, "MeshPhongMaterial" !== u.type && delete u.specular, u.opacity < 1 && (u.transparent = !0), r.setTextures(s), r.parse(u)
            }
        }()
    });
    var hs = {
        decodeText: function(t) {
            if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
            for (var e = "", n = 0, r = t.length; n < r; n++) e += String.fromCharCode(t[n]);
            return decodeURIComponent(escape(e))
        },
        extractUrlBase: function(t) {
            var e = t.lastIndexOf("/");
            return -1 === e ? "./" : t.substr(0, e + 1)
        }
    };

    function fs(t) {
        "boolean" == typeof t && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), t = void 0), this.manager = void 0 !== t ? t : ia, this.withCredentials = !1
    }

    function ds(t) {
        this.manager = void 0 !== t ? t : ia, this.texturePath = ""
    }
    Object.assign(fs.prototype, {
        crossOrigin: "anonymous",
        load: function(t, e, n, r) {
            var i = this,
                o = void 0 === this.path ? hs.extractUrlBase(t) : this.path,
                a = new aa(this.manager);
            a.setPath(this.path), a.setWithCredentials(this.withCredentials), a.load(t, function(n) {
                var r = JSON.parse(n),
                    a = r.metadata;
                if (void 0 !== a) {
                    var s = a.type;
                    if (void 0 !== s && "object" === s.toLowerCase()) return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead.")
                }
                var c = i.parse(r, o);
                e(c.geometry, c.materials)
            }, n, r)
        },
        setPath: function(t) {
            return this.path = t, this
        },
        setResourcePath: function(t) {
            return this.resourcePath = t, this
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t, this
        },
        parse: function() {
            return function(t, e) {
                void 0 !== t.data && (t = t.data), void 0 !== t.scale ? t.scale = 1 / t.scale : t.scale = 1;
                var n = new mn;
                return function(t, e) {
                        function n(t, e) {
                            return t & 1 << e
                        }
                        var r, i, o, a, s, c, u, l, h, f, d, v, p, m, g, y, x, b, w, _, M, S, E, T, P, L = t.faces,
                            A = t.vertices,
                            z = t.normals,
                            C = t.colors,
                            R = t.scale,
                            I = 0;
                        if (void 0 !== t.uvs) {
                            for (r = 0; r < t.uvs.length; r++) t.uvs[r].length && I++;
                            for (r = 0; r < I; r++) e.faceVertexUvs[r] = []
                        }
                        for (a = 0, s = A.length; a < s;)(b = new Ge).x = A[a++] * R, b.y = A[a++] * R, b.z = A[a++] * R, e.vertices.push(b);
                        for (a = 0, s = L.length; a < s;)
                            if (d = n(f = L[a++], 0), v = n(f, 1), p = n(f, 3), m = n(f, 4), g = n(f, 5), y = n(f, 6), x = n(f, 7), d) {
                                if ((_ = new ln).a = L[a], _.b = L[a + 1], _.c = L[a + 3], (M = new ln).a = L[a + 1], M.b = L[a + 2], M.c = L[a + 3], a += 4, v && (h = L[a++], _.materialIndex = h, M.materialIndex = h), o = e.faces.length, p)
                                    for (r = 0; r < I; r++)
                                        for (T = t.uvs[r], e.faceVertexUvs[r][o] = [], e.faceVertexUvs[r][o + 1] = [], i = 0; i < 4; i++) P = new Ue(T[2 * (l = L[a++])], T[2 * l + 1]), 2 !== i && e.faceVertexUvs[r][o].push(P), 0 !== i && e.faceVertexUvs[r][o + 1].push(P);
                                if (m && (u = 3 * L[a++], _.normal.set(z[u++], z[u++], z[u]), M.normal.copy(_.normal)), g)
                                    for (r = 0; r < 4; r++) u = 3 * L[a++], E = new Ge(z[u++], z[u++], z[u]), 2 !== r && _.vertexNormals.push(E), 0 !== r && M.vertexNormals.push(E);
                                if (y && (S = C[c = L[a++]], _.color.setHex(S), M.color.setHex(S)), x)
                                    for (r = 0; r < 4; r++) S = C[c = L[a++]], 2 !== r && _.vertexColors.push(new on(S)), 0 !== r && M.vertexColors.push(new on(S));
                                e.faces.push(_), e.faces.push(M)
                            } else {
                                if ((w = new ln).a = L[a++], w.b = L[a++], w.c = L[a++], v && (h = L[a++], w.materialIndex = h), o = e.faces.length, p)
                                    for (r = 0; r < I; r++)
                                        for (T = t.uvs[r], e.faceVertexUvs[r][o] = [], i = 0; i < 3; i++) P = new Ue(T[2 * (l = L[a++])], T[2 * l + 1]), e.faceVertexUvs[r][o].push(P);
                                if (m && (u = 3 * L[a++], w.normal.set(z[u++], z[u++], z[u])), g)
                                    for (r = 0; r < 3; r++) u = 3 * L[a++], E = new Ge(z[u++], z[u++], z[u]), w.vertexNormals.push(E);
                                if (y && (c = L[a++], w.color.setHex(C[c])), x)
                                    for (r = 0; r < 3; r++) c = L[a++], w.vertexColors.push(new on(C[c]));
                                e.faces.push(w)
                            }
                    }(t, n),
                    function(t, e) {
                        var n = void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2;
                        if (t.skinWeights)
                            for (var r = 0, i = t.skinWeights.length; r < i; r += n) {
                                var o = t.skinWeights[r],
                                    a = n > 1 ? t.skinWeights[r + 1] : 0,
                                    s = n > 2 ? t.skinWeights[r + 2] : 0,
                                    c = n > 3 ? t.skinWeights[r + 3] : 0;
                                e.skinWeights.push(new Xe(o, a, s, c))
                            }
                        if (t.skinIndices)
                            for (r = 0, i = t.skinIndices.length; r < i; r += n) {
                                var u = t.skinIndices[r],
                                    l = n > 1 ? t.skinIndices[r + 1] : 0,
                                    h = n > 2 ? t.skinIndices[r + 2] : 0,
                                    f = n > 3 ? t.skinIndices[r + 3] : 0;
                                e.skinIndices.push(new Xe(u, l, h, f))
                            }
                        e.bones = t.bones, e.bones && e.bones.length > 0 && (e.skinWeights.length !== e.skinIndices.length || e.skinIndices.length !== e.vertices.length) && console.warn("When skinning, number of vertices (" + e.vertices.length + "), skinIndices (" + e.skinIndices.length + "), and skinWeights (" + e.skinWeights.length + ") should match.")
                    }(t, n),
                    function(t, e) {
                        var n = t.scale;
                        if (void 0 !== t.morphTargets)
                            for (var r = 0, i = t.morphTargets.length; r < i; r++) {
                                e.morphTargets[r] = {}, e.morphTargets[r].name = t.morphTargets[r].name, e.morphTargets[r].vertices = [];
                                for (var o = e.morphTargets[r].vertices, a = t.morphTargets[r].vertices, s = 0, c = a.length; s < c; s += 3) {
                                    var u = new Ge;
                                    u.x = a[s] * n, u.y = a[s + 1] * n, u.z = a[s + 2] * n, o.push(u)
                                }
                            }
                        if (void 0 !== t.morphColors && t.morphColors.length > 0) {
                            console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                            var l = e.faces,
                                h = t.morphColors[0].colors;
                            for (r = 0, i = l.length; r < i; r++) l[r].color.fromArray(h, 3 * r)
                        }
                    }(t, n),
                    function(t, e) {
                        var n = [],
                            r = [];
                        void 0 !== t.animation && r.push(t.animation), void 0 !== t.animations && (t.animations.length ? r = r.concat(t.animations) : r.push(t.animations));
                        for (var i = 0; i < r.length; i++) {
                            var o = os.parseAnimation(r[i], e.bones);
                            o && n.push(o)
                        }
                        if (e.morphTargets) {
                            var a = os.CreateClipsFromMorphTargetSequences(e.morphTargets, 10);
                            n = n.concat(a)
                        }
                        n.length > 0 && (e.animations = n)
                    }(t, n), n.computeFaceNormals(), n.computeBoundingSphere(), void 0 === t.materials || 0 === t.materials.length ? {
                        geometry: n
                    } : {
                        geometry: n,
                        materials: ls.prototype.initMaterials(t.materials, this.resourcePath || e, this.crossOrigin)
                    }
            }
        }()
    }), Object.assign(ds.prototype, {
        crossOrigin: "anonymous",
        load: function(t, e, n, r) {
            "" === this.texturePath && (this.texturePath = t.substring(0, t.lastIndexOf("/") + 1));
            var i = this;
            new aa(i.manager).load(t, function(n) {
                var o = null;
                try {
                    o = JSON.parse(n)
                } catch (e) {
                    return void 0 !== r && r(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                }
                var a = o.metadata;
                void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? i.parse(o, e) : console.error("THREE.ObjectLoader: Can't load " + t + ". Use THREE.JSONLoader instead.")
            }, n, r)
        },
        setTexturePath: function(t) {
            return this.texturePath = t, this
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t, this
        },
        parse: function(t, e) {
            var n = this.parseShape(t.shapes),
                r = this.parseGeometries(t.geometries, n),
                i = this.parseImages(t.images, function() {
                    void 0 !== e && e(s)
                }),
                o = this.parseTextures(t.textures, i),
                a = this.parseMaterials(t.materials, o),
                s = this.parseObject(t.object, r, a);
            return t.animations && (s.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(s), s
        },
        parseShape: function(t) {
            var e = {};
            if (void 0 !== t)
                for (var n = 0, r = t.length; n < r; n++) {
                    var i = (new Da).fromJSON(t[n]);
                    e[i.uuid] = i
                }
            return e
        },
        parseGeometries: function(t, e) {
            var n = {};
            if (void 0 !== t)
                for (var r = new fs, i = new cs, o = 0, a = t.length; o < a; o++) {
                    var s, c = t[o];
                    switch (c.type) {
                        case "PlaneGeometry":
                        case "PlaneBufferGeometry":
                            s = new Vo[c.type](c.width, c.height, c.widthSegments, c.heightSegments);
                            break;
                        case "BoxGeometry":
                        case "BoxBufferGeometry":
                        case "CubeGeometry":
                            s = new Vo[c.type](c.width, c.height, c.depth, c.widthSegments, c.heightSegments, c.depthSegments);
                            break;
                        case "CircleGeometry":
                        case "CircleBufferGeometry":
                            s = new Vo[c.type](c.radius, c.segments, c.thetaStart, c.thetaLength);
                            break;
                        case "CylinderGeometry":
                        case "CylinderBufferGeometry":
                            s = new Vo[c.type](c.radiusTop, c.radiusBottom, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);
                            break;
                        case "ConeGeometry":
                        case "ConeBufferGeometry":
                            s = new Vo[c.type](c.radius, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);
                            break;
                        case "SphereGeometry":
                        case "SphereBufferGeometry":
                            s = new Vo[c.type](c.radius, c.widthSegments, c.heightSegments, c.phiStart, c.phiLength, c.thetaStart, c.thetaLength);
                            break;
                        case "DodecahedronGeometry":
                        case "DodecahedronBufferGeometry":
                        case "IcosahedronGeometry":
                        case "IcosahedronBufferGeometry":
                        case "OctahedronGeometry":
                        case "OctahedronBufferGeometry":
                        case "TetrahedronGeometry":
                        case "TetrahedronBufferGeometry":
                            s = new Vo[c.type](c.radius, c.detail);
                            break;
                        case "RingGeometry":
                        case "RingBufferGeometry":
                            s = new Vo[c.type](c.innerRadius, c.outerRadius, c.thetaSegments, c.phiSegments, c.thetaStart, c.thetaLength);
                            break;
                        case "TorusGeometry":
                        case "TorusBufferGeometry":
                            s = new Vo[c.type](c.radius, c.tube, c.radialSegments, c.tubularSegments, c.arc);
                            break;
                        case "TorusKnotGeometry":
                        case "TorusKnotBufferGeometry":
                            s = new Vo[c.type](c.radius, c.tube, c.tubularSegments, c.radialSegments, c.p, c.q);
                            break;
                        case "LatheGeometry":
                        case "LatheBufferGeometry":
                            s = new Vo[c.type](c.points, c.segments, c.phiStart, c.phiLength);
                            break;
                        case "PolyhedronGeometry":
                        case "PolyhedronBufferGeometry":
                            s = new Vo[c.type](c.vertices, c.indices, c.radius, c.details);
                            break;
                        case "ShapeGeometry":
                        case "ShapeBufferGeometry":
                            for (var u = [], l = 0, h = c.shapes.length; l < h; l++) {
                                var f = e[c.shapes[l]];
                                u.push(f)
                            }
                            s = new Vo[c.type](u, c.curveSegments);
                            break;
                        case "ExtrudeGeometry":
                        case "ExtrudeBufferGeometry":
                            for (u = [], l = 0, h = c.shapes.length; l < h; l++) {
                                f = e[c.shapes[l]];
                                u.push(f)
                            }
                            var d = c.options.extrudePath;
                            void 0 !== d && (c.options.extrudePath = (new Ca[d.type]).fromJSON(d)), s = new Vo[c.type](u, c.options);
                            break;
                        case "BufferGeometry":
                            s = i.parse(c);
                            break;
                        case "Geometry":
                            s = r.parse(c, this.texturePath).geometry;
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + c.type + '"');
                            continue
                    }
                    s.uuid = c.uuid, void 0 !== c.name && (s.name = c.name), !0 === s.isBufferGeometry && void 0 !== c.userData && (s.userData = c.userData), n[c.uuid] = s
                }
            return n
        },
        parseMaterials: function(t, e) {
            var n = {};
            if (void 0 !== t) {
                var r = new ss;
                r.setTextures(e);
                for (var i = 0, o = t.length; i < o; i++) {
                    var a = t[i];
                    if ("MultiMaterial" === a.type) {
                        for (var s = [], c = 0; c < a.materials.length; c++) s.push(r.parse(a.materials[c]));
                        n[a.uuid] = s
                    } else n[a.uuid] = r.parse(a)
                }
            }
            return n
        },
        parseAnimations: function(t) {
            for (var e = [], n = 0; n < t.length; n++) {
                var r = t[n],
                    i = os.parse(r);
                void 0 !== r.uuid && (i.uuid = r.uuid), e.push(i)
            }
            return e
        },
        parseImages: function(t, e) {
            var n = this,
                r = {};

            function i(t) {
                return n.manager.itemStart(t), o.load(t, function() {
                    n.manager.itemEnd(t)
                }, void 0, function() {
                    n.manager.itemEnd(t), n.manager.itemError(t)
                })
            }
            if (void 0 !== t && t.length > 0) {
                var o = new ua(new ra(e));
                o.setCrossOrigin(this.crossOrigin);
                for (var a = 0, s = t.length; a < s; a++) {
                    var c = t[a],
                        u = c.url;
                    if (Array.isArray(u)) {
                        r[c.uuid] = [];
                        for (var l = 0, h = u.length; l < h; l++) {
                            var f = u[l],
                                d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : n.texturePath + f;
                            r[c.uuid].push(i(d))
                        }
                    } else {
                        d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : n.texturePath + c.url;
                        r[c.uuid] = i(d)
                    }
                }
            }
            return r
        },
        parseTextures: function(t, e) {
            function n(t, e) {
                return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
            }
            var r = {};
            if (void 0 !== t)
                for (var i = 0, o = t.length; i < o; i++) {
                    var a, s = t[i];
                    void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image), (a = Array.isArray(e[s.image]) ? new Hn(e[s.image]) : new Ye(e[s.image])).needsUpdate = !0, a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), void 0 !== s.mapping && (a.mapping = n(s.mapping, ps)), void 0 !== s.offset && a.offset.fromArray(s.offset), void 0 !== s.repeat && a.repeat.fromArray(s.repeat), void 0 !== s.center && a.center.fromArray(s.center), void 0 !== s.rotation && (a.rotation = s.rotation), void 0 !== s.wrap && (a.wrapS = n(s.wrap[0], ms), a.wrapT = n(s.wrap[1], ms)), void 0 !== s.format && (a.format = s.format), void 0 !== s.minFilter && (a.minFilter = n(s.minFilter, gs)), void 0 !== s.magFilter && (a.magFilter = n(s.magFilter, gs)), void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy), void 0 !== s.flipY && (a.flipY = s.flipY), r[s.uuid] = a
                }
            return r
        },
        parseObject: function(t, e, n) {
            var r;

            function i(t) {
                return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t]
            }

            function o(t) {
                if (void 0 !== t) {
                    if (Array.isArray(t)) {
                        for (var e = [], r = 0, i = t.length; r < i; r++) {
                            var o = t[r];
                            void 0 === n[o] && console.warn("THREE.ObjectLoader: Undefined material", o), e.push(n[o])
                        }
                        return e
                    }
                    return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t), n[t]
                }
            }
            switch (t.type) {
                case "Scene":
                    r = new fi, void 0 !== t.background && Number.isInteger(t.background) && (r.background = new on(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? r.fog = new hi(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (r.fog = new li(t.fog.color, t.fog.density)));
                    break;
                case "PerspectiveCamera":
                    r = new ai(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (r.focus = t.focus), void 0 !== t.zoom && (r.zoom = t.zoom), void 0 !== t.filmGauge && (r.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (r.filmOffset = t.filmOffset), void 0 !== t.view && (r.view = Object.assign({}, t.view));
                    break;
                case "OrthographicCamera":
                    r = new Na(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (r.zoom = t.zoom), void 0 !== t.view && (r.view = Object.assign({}, t.view));
                    break;
                case "AmbientLight":
                    r = new Va(t.color, t.intensity);
                    break;
                case "DirectionalLight":
                    r = new Ha(t.color, t.intensity);
                    break;
                case "PointLight":
                    r = new Ba(t.color, t.intensity, t.distance, t.decay);
                    break;
                case "RectAreaLight":
                    r = new Wa(t.color, t.intensity, t.width, t.height);
                    break;
                case "SpotLight":
                    r = new Ua(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                    break;
                case "HemisphereLight":
                    r = new Fa(t.color, t.groundColor, t.intensity);
                    break;
                case "SkinnedMesh":
                    console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                case "Mesh":
                    var a = i(t.geometry),
                        s = o(t.material);
                    r = a.bones && a.bones.length > 0 ? new bi(a, s) : new Nn(a, s);
                    break;
                case "LOD":
                    r = new gi;
                    break;
                case "Line":
                    r = new _i(i(t.geometry), o(t.material), t.mode);
                    break;
                case "LineLoop":
                    r = new Si(i(t.geometry), o(t.material));
                    break;
                case "LineSegments":
                    r = new Mi(i(t.geometry), o(t.material));
                    break;
                case "PointCloud":
                case "Points":
                    r = new Ti(i(t.geometry), o(t.material));
                    break;
                case "Sprite":
                    r = new mi(o(t.material));
                    break;
                case "Group":
                    r = new ii;
                    break;
                default:
                    r = new vn
            }
            if (r.uuid = t.uuid, void 0 !== t.name && (r.name = t.name), void 0 !== t.matrix ? (r.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (r.matrixAutoUpdate = t.matrixAutoUpdate), r.matrixAutoUpdate && r.matrix.decompose(r.position, r.quaternion, r.scale)) : (void 0 !== t.position && r.position.fromArray(t.position), void 0 !== t.rotation && r.rotation.fromArray(t.rotation), void 0 !== t.quaternion && r.quaternion.fromArray(t.quaternion), void 0 !== t.scale && r.scale.fromArray(t.scale)), void 0 !== t.castShadow && (r.castShadow = t.castShadow), void 0 !== t.receiveShadow && (r.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (r.shadow.bias = t.shadow.bias), void 0 !== t.shadow.radius && (r.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && r.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (r.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (r.visible = t.visible), void 0 !== t.frustumCulled && (r.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (r.renderOrder = t.renderOrder), void 0 !== t.userData && (r.userData = t.userData), void 0 !== t.layers && (r.layers.mask = t.layers), void 0 !== t.children)
                for (var c = t.children, u = 0; u < c.length; u++) r.add(this.parseObject(c[u], e, n));
            if ("LOD" === t.type)
                for (var l = t.levels, h = 0; h < l.length; h++) {
                    var f = l[h],
                        d = r.getObjectByProperty("uuid", f.object);
                    void 0 !== d && r.addLevel(d, f.distance)
                }
            return r
        }
    });
    var vs, ps = {
            UVMapping: st,
            CubeReflectionMapping: ct,
            CubeRefractionMapping: ut,
            EquirectangularReflectionMapping: lt,
            EquirectangularRefractionMapping: ht,
            SphericalReflectionMapping: ft,
            CubeUVReflectionMapping: dt,
            CubeUVRefractionMapping: vt
        },
        ms = {
            RepeatWrapping: pt,
            ClampToEdgeWrapping: mt,
            MirroredRepeatWrapping: gt
        },
        gs = {
            NearestFilter: yt,
            NearestMipMapNearestFilter: xt,
            NearestMipMapLinearFilter: bt,
            LinearFilter: wt,
            LinearMipMapNearestFilter: _t,
            LinearMipMapLinearFilter: Mt
        };

    function ys(t) {
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== t ? t : ia, this.options = void 0
    }

    function xs() {
        this.type = "ShapePath", this.color = new on, this.subPaths = [], this.currentPath = null
    }

    function bs(t) {
        this.type = "Font", this.data = t
    }

    function ws(t, e, n, r, i) {
        var o = i.glyphs[t] || i.glyphs["?"];
        if (o) {
            var a, s, c, u, l, h, f, d, v = new xs;
            if (o.o)
                for (var p = o._cachedOutline || (o._cachedOutline = o.o.split(" ")), m = 0, g = p.length; m < g;) {
                    switch (p[m++]) {
                        case "m":
                            a = p[m++] * e + n, s = p[m++] * e + r, v.moveTo(a, s);
                            break;
                        case "l":
                            a = p[m++] * e + n, s = p[m++] * e + r, v.lineTo(a, s);
                            break;
                        case "q":
                            c = p[m++] * e + n, u = p[m++] * e + r, l = p[m++] * e + n, h = p[m++] * e + r, v.quadraticCurveTo(l, h, c, u);
                            break;
                        case "b":
                            c = p[m++] * e + n, u = p[m++] * e + r, l = p[m++] * e + n, h = p[m++] * e + r, f = p[m++] * e + n, d = p[m++] * e + r, v.bezierCurveTo(l, h, f, d, c, u)
                    }
                }
            return {
                offsetX: o.ha * e,
                path: v
            }
        }
    }

    function _s(t) {
        this.manager = void 0 !== t ? t : ia
    }
    ys.prototype = {
        constructor: ys,
        setOptions: function(t) {
            return this.options = t, this
        },
        load: function(t, e, n, r) {
            void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
            var i = this,
                o = na.get(t);
            if (void 0 !== o) return i.manager.itemStart(t), setTimeout(function() {
                e && e(o), i.manager.itemEnd(t)
            }, 0), o;
            fetch(t).then(function(t) {
                return t.blob()
            }).then(function(t) {
                return createImageBitmap(t, i.options)
            }).then(function(n) {
                na.add(t, n), e && e(n), i.manager.itemEnd(t)
            }).catch(function(e) {
                r && r(e), i.manager.itemEnd(t), i.manager.itemError(t)
            })
        },
        setCrossOrigin: function() {
            return this
        },
        setPath: function(t) {
            return this.path = t, this
        }
    }, Object.assign(xs.prototype, {
        moveTo: function(t, e) {
            this.currentPath = new Ia, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e)
        },
        lineTo: function(t, e) {
            this.currentPath.lineTo(t, e)
        },
        quadraticCurveTo: function(t, e, n, r) {
            this.currentPath.quadraticCurveTo(t, e, n, r)
        },
        bezierCurveTo: function(t, e, n, r, i, o) {
            this.currentPath.bezierCurveTo(t, e, n, r, i, o)
        },
        splineThru: function(t) {
            this.currentPath.splineThru(t)
        },
        toShapes: function(t, e) {
            function n(t) {
                for (var e = [], n = 0, r = t.length; n < r; n++) {
                    var i = t[n],
                        o = new Da;
                    o.curves = i.curves, e.push(o)
                }
                return e
            }

            function r(t, e) {
                for (var n = e.length, r = !1, i = n - 1, o = 0; o < n; i = o++) {
                    var a = e[i],
                        s = e[o],
                        c = s.x - a.x,
                        u = s.y - a.y;
                    if (Math.abs(u) > Number.EPSILON) {
                        if (u < 0 && (a = e[o], c = -c, s = e[i], u = -u), t.y < a.y || t.y > s.y) continue;
                        if (t.y === a.y) {
                            if (t.x === a.x) return !0
                        } else {
                            var l = u * (t.x - a.x) - c * (t.y - a.y);
                            if (0 === l) return !0;
                            if (l < 0) continue;
                            r = !r
                        }
                    } else {
                        if (t.y !== a.y) continue;
                        if (s.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= s.x) return !0
                    }
                }
                return r
            }
            var i = xo.isClockWise,
                o = this.subPaths;
            if (0 === o.length) return [];
            if (!0 === e) return n(o);
            var a, s, c, u = [];
            if (1 === o.length) return s = o[0], (c = new Da).curves = s.curves, u.push(c), u;
            var l = !i(o[0].getPoints());
            l = t ? !l : l;
            var h, f, d = [],
                v = [],
                p = [],
                m = 0;
            v[m] = void 0, p[m] = [];
            for (var g = 0, y = o.length; g < y; g++) a = i(h = (s = o[g]).getPoints()), (a = t ? !a : a) ? (!l && v[m] && m++, v[m] = {
                s: new Da,
                p: h
            }, v[m].s.curves = s.curves, l && m++, p[m] = []) : p[m].push({
                h: s,
                p: h[0]
            });
            if (!v[0]) return n(o);
            if (v.length > 1) {
                for (var x = !1, b = [], w = 0, _ = v.length; w < _; w++) d[w] = [];
                for (w = 0, _ = v.length; w < _; w++)
                    for (var M = p[w], S = 0; S < M.length; S++) {
                        for (var E = M[S], T = !0, P = 0; P < v.length; P++) r(E.p, v[P].p) && (w !== P && b.push({
                            froms: w,
                            tos: P,
                            hole: S
                        }), T ? (T = !1, d[P].push(E)) : x = !0);
                        T && d[w].push(E)
                    }
                b.length > 0 && (x || (p = d))
            }
            g = 0;
            for (var L = v.length; g < L; g++) {
                c = v[g].s, u.push(c);
                for (var A = 0, z = (f = p[g]).length; A < z; A++) c.holes.push(f[A].h)
            }
            return u
        }
    }), Object.assign(bs.prototype, {
        isFont: !0,
        generateShapes: function(t, e) {
            void 0 === e && (e = 100);
            for (var n = [], r = function(t, e, n) {
                    for (var r = Array.from ? Array.from(t) : String(t).split(""), i = e / n.resolution, o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * i, a = [], s = 0, c = 0, u = 0; u < r.length; u++) {
                        var l = r[u];
                        if ("\n" === l) s = 0, c -= o;
                        else {
                            var h = ws(l, i, s, c, n);
                            s += h.offsetX, a.push(h.path)
                        }
                    }
                    return a
                }(t, e, this.data), i = 0, o = r.length; i < o; i++) Array.prototype.push.apply(n, r[i].toShapes());
            return n
        }
    }), Object.assign(_s.prototype, {
        load: function(t, e, n, r) {
            var i = this,
                o = new aa(this.manager);
            o.setPath(this.path), o.load(t, function(t) {
                var n;
                try {
                    n = JSON.parse(t)
                } catch (e) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2))
                }
                var r = i.parse(n);
                e && e(r)
            }, n, r)
        },
        parse: function(t) {
            return new bs(t)
        },
        setPath: function(t) {
            return this.path = t, this
        }
    });
    var Ms = {
        getContext: function() {
            return void 0 === vs && (vs = new(window.AudioContext || window.webkitAudioContext)), vs
        },
        setContext: function(t) {
            vs = t
        }
    };

    function Ss(t) {
        this.manager = void 0 !== t ? t : ia
    }

    function Es() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new ai, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new ai, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
    }

    function Ts(t, e, n) {
        vn.call(this), this.type = "CubeCamera";
        var r = new ai(90, 1, t, e);
        r.up.set(0, -1, 0), r.lookAt(new Ge(1, 0, 0)), this.add(r);
        var i = new ai(90, 1, t, e);
        i.up.set(0, -1, 0), i.lookAt(new Ge(-1, 0, 0)), this.add(i);
        var o = new ai(90, 1, t, e);
        o.up.set(0, 0, 1), o.lookAt(new Ge(0, 1, 0)), this.add(o);
        var a = new ai(90, 1, t, e);
        a.up.set(0, 0, -1), a.lookAt(new Ge(0, -1, 0)), this.add(a);
        var s = new ai(90, 1, t, e);
        s.up.set(0, -1, 0), s.lookAt(new Ge(0, 0, 1)), this.add(s);
        var c = new ai(90, 1, t, e);
        c.up.set(0, -1, 0), c.lookAt(new Ge(0, 0, -1)), this.add(c);
        var u = {
            format: jt,
            magFilter: wt,
            minFilter: wt
        };
        this.renderTarget = new Ke(n, n, u), this.renderTarget.texture.name = "CubeCamera", this.update = function(t, e) {
            null === this.parent && this.updateMatrixWorld();
            var n = this.renderTarget,
                u = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1, n.activeCubeFace = 0, t.render(e, r, n), n.activeCubeFace = 1, t.render(e, i, n), n.activeCubeFace = 2, t.render(e, o, n), n.activeCubeFace = 3, t.render(e, a, n), n.activeCubeFace = 4, t.render(e, s, n), n.texture.generateMipmaps = u, n.activeCubeFace = 5, t.render(e, c, n), t.setRenderTarget(null)
        }, this.clear = function(t, e, n, r) {
            for (var i = this.renderTarget, o = 0; o < 6; o++) i.activeCubeFace = o, t.setRenderTarget(i), t.clear(e, n, r);
            t.setRenderTarget(null)
        }
    }

    function Ps() {
        vn.call(this), this.type = "AudioListener", this.context = Ms.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null
    }

    function Ls(t) {
        vn.call(this), this.type = "Audio", this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
    }

    function As(t) {
        Ls.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
    }

    function zs(t, e) {
        this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
    }

    function Cs(t, e, n) {
        this.binding = t, this.valueSize = n;
        var r, i = Float64Array;
        switch (e) {
            case "quaternion":
                r = this._slerp;
                break;
            case "string":
            case "bool":
                i = Array, r = this._select;
                break;
            default:
                r = this._lerp
        }
        this.buffer = new i(4 * n), this._mixBufferRegion = r, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
    }
    Object.assign(Ss.prototype, {
        load: function(t, e, n, r) {
            var i = new aa(this.manager);
            i.setResponseType("arraybuffer"), i.load(t, function(t) {
                var n = t.slice(0);
                Ms.getContext().decodeAudioData(n, function(t) {
                    e(t)
                })
            }, n, r)
        }
    }), Object.assign(Es.prototype, {
        update: function() {
            var t, e, n, r, i, o, a, s, c = new Be,
                u = new Be;
            return function(l) {
                if (t !== this || e !== l.focus || n !== l.fov || r !== l.aspect * this.aspect || i !== l.near || o !== l.far || a !== l.zoom || s !== this.eyeSep) {
                    t = this, e = l.focus, n = l.fov, r = l.aspect * this.aspect, i = l.near, o = l.far, a = l.zoom;
                    var h, f, d = l.projectionMatrix.clone(),
                        v = (s = this.eyeSep / 2) * i / e,
                        p = i * Math.tan(ke.DEG2RAD * n * .5) / a;
                    u.elements[12] = -s, c.elements[12] = s, h = -p * r + v, f = p * r + v, d.elements[0] = 2 * i / (f - h), d.elements[8] = (f + h) / (f - h), this.cameraL.projectionMatrix.copy(d), h = -p * r - v, f = p * r - v, d.elements[0] = 2 * i / (f - h), d.elements[8] = (f + h) / (f - h), this.cameraR.projectionMatrix.copy(d)
                }
                this.cameraL.matrixWorld.copy(l.matrixWorld).multiply(u), this.cameraR.matrixWorld.copy(l.matrixWorld).multiply(c)
            }
        }()
    }), Ts.prototype = Object.create(vn.prototype), Ts.prototype.constructor = Ts, Ps.prototype = Object.assign(Object.create(vn.prototype), {
        constructor: Ps,
        getInput: function() {
            return this.gain
        },
        removeFilter: function() {
            return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
        },
        getFilter: function() {
            return this.filter
        },
        setFilter: function(t) {
            return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
        },
        getMasterVolume: function() {
            return this.gain.gain.value
        },
        setMasterVolume: function(t) {
            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
        },
        updateMatrixWorld: function() {
            var t = new Ge,
                e = new Ne,
                n = new Ge,
                r = new Ge;
            return function(i) {
                vn.prototype.updateMatrixWorld.call(this, i);
                var o = this.context.listener,
                    a = this.up;
                this.matrixWorld.decompose(t, e, n), r.set(0, 0, -1).applyQuaternion(e), o.positionX ? (o.positionX.setValueAtTime(t.x, this.context.currentTime), o.positionY.setValueAtTime(t.y, this.context.currentTime), o.positionZ.setValueAtTime(t.z, this.context.currentTime), o.forwardX.setValueAtTime(r.x, this.context.currentTime), o.forwardY.setValueAtTime(r.y, this.context.currentTime), o.forwardZ.setValueAtTime(r.z, this.context.currentTime), o.upX.setValueAtTime(a.x, this.context.currentTime), o.upY.setValueAtTime(a.y, this.context.currentTime), o.upZ.setValueAtTime(a.z, this.context.currentTime)) : (o.setPosition(t.x, t.y, t.z), o.setOrientation(r.x, r.y, r.z, a.x, a.y, a.z))
            }
        }()
    }), Ls.prototype = Object.assign(Object.create(vn.prototype), {
        constructor: Ls,
        getOutput: function() {
            return this.gain
        },
        setNodeSource: function(t) {
            return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
        },
        setMediaElementSource: function(t) {
            return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
        },
        setBuffer: function(t) {
            return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
        },
        play: function() {
            if (!0 !== this.isPlaying) {
                if (!1 !== this.hasPlaybackControl) {
                    var t = this.context.createBufferSource();
                    return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), t.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime, t.start(this.startTime, this.offset), this.isPlaying = !0, this.source = t, this.connect()
                }
                console.warn("THREE.Audio: this Audio has no playback control.")
            } else console.warn("THREE.Audio: Audio is already playing.")
        },
        pause: function() {
            if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        stop: function() {
            if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        connect: function() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else this.source.connect(this.getOutput());
            return this
        },
        disconnect: function() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else this.source.disconnect(this.getOutput());
            return this
        },
        getFilters: function() {
            return this.filters
        },
        setFilters: function(t) {
            return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
        },
        getFilter: function() {
            return this.getFilters()[0]
        },
        setFilter: function(t) {
            return this.setFilters(t ? [t] : [])
        },
        setPlaybackRate: function(t) {
            if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getPlaybackRate: function() {
            return this.playbackRate
        },
        onEnded: function() {
            this.isPlaying = !1
        },
        getLoop: function() {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
        },
        setLoop: function(t) {
            if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getVolume: function() {
            return this.gain.gain.value
        },
        setVolume: function(t) {
            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
        }
    }), As.prototype = Object.assign(Object.create(Ls.prototype), {
        constructor: As,
        getOutput: function() {
            return this.panner
        },
        getRefDistance: function() {
            return this.panner.refDistance
        },
        setRefDistance: function(t) {
            return this.panner.refDistance = t, this
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor
        },
        setRolloffFactor: function(t) {
            return this.panner.rolloffFactor = t, this
        },
        getDistanceModel: function() {
            return this.panner.distanceModel
        },
        setDistanceModel: function(t) {
            return this.panner.distanceModel = t, this
        },
        getMaxDistance: function() {
            return this.panner.maxDistance
        },
        setMaxDistance: function(t) {
            return this.panner.maxDistance = t, this
        },
        setDirectionalCone: function(t, e, n) {
            return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this
        },
        updateMatrixWorld: function() {
            var t = new Ge,
                e = new Ne,
                n = new Ge,
                r = new Ge;
            return function(i) {
                vn.prototype.updateMatrixWorld.call(this, i);
                var o = this.panner;
                this.matrixWorld.decompose(t, e, n), r.set(0, 0, 1).applyQuaternion(e), o.setPosition(t.x, t.y, t.z), o.setOrientation(r.x, r.y, r.z)
            }
        }()
    }), Object.assign(zs.prototype, {
        getFrequencyData: function() {
            return this.analyser.getByteFrequencyData(this.data), this.data
        },
        getAverageFrequency: function() {
            for (var t = 0, e = this.getFrequencyData(), n = 0; n < e.length; n++) t += e[n];
            return t / e.length
        }
    }), Object.assign(Cs.prototype, {
        accumulate: function(t, e) {
            var n = this.buffer,
                r = this.valueSize,
                i = t * r + r,
                o = this.cumulativeWeight;
            if (0 === o) {
                for (var a = 0; a !== r; ++a) n[i + a] = n[a];
                o = e
            } else {
                var s = e / (o += e);
                this._mixBufferRegion(n, i, 0, s, r)
            }
            this.cumulativeWeight = o
        },
        apply: function(t) {
            var e = this.valueSize,
                n = this.buffer,
                r = t * e + e,
                i = this.cumulativeWeight,
                o = this.binding;
            if (this.cumulativeWeight = 0, i < 1) {
                var a = 3 * e;
                this._mixBufferRegion(n, r, a, 1 - i, e)
            }
            for (var s = e, c = e + e; s !== c; ++s)
                if (n[s] !== n[s + e]) {
                    o.setValue(n, r);
                    break
                }
        },
        saveOriginalState: function() {
            var t = this.binding,
                e = this.buffer,
                n = this.valueSize,
                r = 3 * n;
            t.getValue(e, r);
            for (var i = n, o = r; i !== o; ++i) e[i] = e[r + i % n];
            this.cumulativeWeight = 0
        },
        restoreOriginalState: function() {
            var t = 3 * this.valueSize;
            this.binding.setValue(this.buffer, t)
        },
        _select: function(t, e, n, r, i) {
            if (r >= .5)
                for (var o = 0; o !== i; ++o) t[e + o] = t[n + o]
        },
        _slerp: function(t, e, n, r) {
            Ne.slerpFlat(t, e, t, e, t, n, r)
        },
        _lerp: function(t, e, n, r, i) {
            for (var o = 1 - r, a = 0; a !== i; ++a) {
                var s = e + a;
                t[s] = t[s] * o + t[n + a] * r
            }
        }
    });
    var Rs, Is;

    function Ds(t, e, n) {
        var r = n || Os.parseTrackName(e);
        this._targetGroup = t, this._bindings = t.subscribe_(e, r)
    }

    function Os(t, e, n) {
        this.path = e, this.parsedPath = n || Os.parseTrackName(e), this.node = Os.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
    }

    function Fs() {
        this.uuid = ke.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        var t = {};
        this._indicesByUUID = t;
        for (var e = 0, n = arguments.length; e !== n; ++e) t[arguments[e].uuid] = e;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        var r = this;
        this.stats = {
            objects: {get total() {
                    return r._objects.length
                },
                get inUse() {
                    return this.total - r.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return r._bindings.length
            }
        }
    }

    function js(t, e, n) {
        this._mixer = t, this._clip = e, this._localRoot = n || null;
        for (var r = e.tracks, i = r.length, o = new Array(i), a = {
                endingStart: be,
                endingEnd: be
            }, s = 0; s !== i; ++s) {
            var c = r[s].createInterpolant(null);
            o[s] = c, c.settings = a
        }
        this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(i), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = pe, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
    }

    function ks(t) {
        this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
    }

    function Us(t) {
        "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
    }

    function Bs() {
        zn.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
    }

    function Ns(t, e, n) {
        di.call(this, t, e), this.meshPerAttribute = n || 1
    }

    function Gs(t, e, n, r) {
        "number" == typeof n && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), gn.call(this, t, e, n), this.meshPerAttribute = r || 1
    }

    function Hs(t, e, n, r) {
        this.ray = new kn(t, e), this.near = n || 0, this.far = r || 1 / 0, this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }, Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                }
            }
        })
    }

    function Vs(t, e) {
        return t.distance - e.distance
    }

    function Ws(t, e, n, r) {
        if (!1 !== t.visible && (t.raycast(e, n), !0 === r))
            for (var i = t.children, o = 0, a = i.length; o < a; o++) Ws(i[o], e, n, !0)
    }

    function Ys(t) {
        this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
    }

    function Xs(t, e, n) {
        return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== n ? n : 0, this
    }

    function qs(t, e, n) {
        return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== n ? n : 0, this
    }

    function Ks(t, e) {
        this.min = void 0 !== t ? t : new Ue(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Ue(-1 / 0, -1 / 0)
    }

    function Zs(t, e) {
        this.start = void 0 !== t ? t : new Ge, this.end = void 0 !== e ? e : new Ge
    }

    function Js(t) {
        vn.call(this), this.material = t, this.render = function() {}
    }

    function Qs(t, e, n, r) {
        this.object = t, this.size = void 0 !== e ? e : 1;
        var i = void 0 !== n ? n : 16711680,
            o = void 0 !== r ? r : 1,
            a = 0,
            s = this.object.geometry;
        s && s.isGeometry ? a = 3 * s.faces.length : s && s.isBufferGeometry && (a = s.attributes.normal.count);
        var c = new zn,
            u = new En(2 * a * 3, 3);
        c.addAttribute("position", u), Mi.call(this, c, new wi({
            color: i,
            linewidth: o
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function $s(t, e) {
        vn.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
        for (var n = new zn, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], i = 0, o = 1; i < 32; i++, o++) {
            var a = i / 32 * Math.PI * 2,
                s = o / 32 * Math.PI * 2;
            r.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1)
        }
        n.addAttribute("position", new En(r, 3));
        var c = new wi({
            fog: !1
        });
        this.cone = new Mi(n, c), this.add(this.cone), this.update()
    }

    function tc(t) {
        for (var e = function t(e) {
                var n = [];
                e && e.isBone && n.push(e);
                for (var r = 0; r < e.children.length; r++) n.push.apply(n, t(e.children[r]));
                return n
            }(t), n = new zn, r = [], i = [], o = new on(0, 0, 1), a = new on(0, 1, 0), s = 0; s < e.length; s++) {
            var c = e[s];
            c.parent && c.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(o.r, o.g, o.b), i.push(a.r, a.g, a.b))
        }
        n.addAttribute("position", new En(r, 3)), n.addAttribute("color", new En(i, 3));
        var u = new wi({
            vertexColors: _,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        });
        Mi.call(this, n, u), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
    }

    function ec(t, e, n) {
        this.light = t, this.light.updateMatrixWorld(), this.color = n;
        var r = new Ao(e, 4, 2),
            i = new Bn({
                wireframe: !0,
                fog: !1
            });
        Nn.call(this, r, i), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
    }

    function nc(t, e) {
        vn.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
        var n = new wi({
                fog: !1
            }),
            r = new zn;
        r.addAttribute("position", new gn(new Float32Array(15), 3)), this.line = new _i(r, n), this.add(this.line), this.update()
    }

    function rc(t, e, n) {
        vn.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
        var r = new Ui(e);
        r.rotateY(.5 * Math.PI), this.material = new Bn({
            wireframe: !0,
            fog: !1
        }), void 0 === this.color && (this.material.vertexColors = _);
        var i = r.getAttribute("position"),
            o = new Float32Array(3 * i.count);
        r.addAttribute("color", new gn(o, 3)), this.add(new Nn(r, this.material)), this.update()
    }

    function ic(t, e, n, r) {
        t = t || 10, e = e || 10, n = new on(void 0 !== n ? n : 4473924), r = new on(void 0 !== r ? r : 8947848);
        for (var i = e / 2, o = t / e, a = t / 2, s = [], c = [], u = 0, l = 0, h = -a; u <= e; u++, h += o) {
            s.push(-a, 0, h, a, 0, h), s.push(h, 0, -a, h, 0, a);
            var f = u === i ? n : r;
            f.toArray(c, l), l += 3, f.toArray(c, l), l += 3, f.toArray(c, l), l += 3, f.toArray(c, l), l += 3
        }
        var d = new zn;
        d.addAttribute("position", new En(s, 3)), d.addAttribute("color", new En(c, 3));
        var v = new wi({
            vertexColors: _
        });
        Mi.call(this, d, v)
    }

    function oc(t, e, n, r, i, o) {
        t = t || 10, e = e || 16, n = n || 8, r = r || 64, i = new on(void 0 !== i ? i : 4473924), o = new on(void 0 !== o ? o : 8947848);
        var a, s, c, u, l, h, f, d = [],
            v = [];
        for (u = 0; u <= e; u++) c = u / e * (2 * Math.PI), a = Math.sin(c) * t, s = Math.cos(c) * t, d.push(0, 0, 0), d.push(a, 0, s), f = 1 & u ? i : o, v.push(f.r, f.g, f.b), v.push(f.r, f.g, f.b);
        for (u = 0; u <= n; u++)
            for (f = 1 & u ? i : o, h = t - t / n * u, l = 0; l < r; l++) c = l / r * (2 * Math.PI), a = Math.sin(c) * h, s = Math.cos(c) * h, d.push(a, 0, s), v.push(f.r, f.g, f.b), c = (l + 1) / r * (2 * Math.PI), a = Math.sin(c) * h, s = Math.cos(c) * h, d.push(a, 0, s), v.push(f.r, f.g, f.b);
        var p = new zn;
        p.addAttribute("position", new En(d, 3)), p.addAttribute("color", new En(v, 3));
        var m = new wi({
            vertexColors: _
        });
        Mi.call(this, p, m)
    }

    function ac(t, e, n, r) {
        this.object = t, this.size = void 0 !== e ? e : 1;
        var i = void 0 !== n ? n : 16776960,
            o = void 0 !== r ? r : 1,
            a = 0,
            s = this.object.geometry;
        s && s.isGeometry ? a = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
        var c = new zn,
            u = new En(2 * a * 3, 3);
        c.addAttribute("position", u), Mi.call(this, c, new wi({
            color: i,
            linewidth: o
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function sc(t, e, n) {
        vn.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === e && (e = 1);
        var r = new zn;
        r.addAttribute("position", new En([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
        var i = new wi({
            fog: !1
        });
        this.lightPlane = new _i(r, i), this.add(this.lightPlane), (r = new zn).addAttribute("position", new En([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new _i(r, i), this.add(this.targetLine), this.update()
    }

    function cc(t) {
        var e = new zn,
            n = new wi({
                color: 16777215,
                vertexColors: w
            }),
            r = [],
            i = [],
            o = {},
            a = new on(16755200),
            s = new on(16711680),
            c = new on(43775),
            u = new on(16777215),
            l = new on(3355443);

        function h(t, e, n) {
            f(t, n), f(e, n)
        }

        function f(t, e) {
            r.push(0, 0, 0), i.push(e.r, e.g, e.b), void 0 === o[t] && (o[t] = []), o[t].push(r.length / 3 - 1)
        }
        h("n1", "n2", a), h("n2", "n4", a), h("n4", "n3", a), h("n3", "n1", a), h("f1", "f2", a), h("f2", "f4", a), h("f4", "f3", a), h("f3", "f1", a), h("n1", "f1", a), h("n2", "f2", a), h("n3", "f3", a), h("n4", "f4", a), h("p", "n1", s), h("p", "n2", s), h("p", "n3", s), h("p", "n4", s), h("u1", "u2", c), h("u2", "u3", c), h("u3", "u1", c), h("c", "t", u), h("p", "c", l), h("cn1", "cn2", l), h("cn3", "cn4", l), h("cf1", "cf2", l), h("cf3", "cf4", l), e.addAttribute("position", new En(r, 3)), e.addAttribute("color", new En(i, 3)), Mi.call(this, e, n), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
    }

    function uc(t, e) {
        this.object = t, void 0 === e && (e = 16776960);
        var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            r = new Float32Array(24),
            i = new zn;
        i.setIndex(new gn(n, 1)), i.addAttribute("position", new gn(r, 3)), Mi.call(this, i, new wi({
            color: e
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function lc(t, e) {
        this.type = "Box3Helper", this.box = t;
        var n = void 0 !== e ? e : 16776960,
            r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            i = new zn;
        i.setIndex(new gn(r, 1)), i.addAttribute("position", new En([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Mi.call(this, i, new wi({
            color: n
        })), this.geometry.computeBoundingSphere()
    }

    function hc(t, e, n) {
        this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e;
        var r = void 0 !== n ? n : 16776960,
            i = new zn;
        i.addAttribute("position", new En([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), i.computeBoundingSphere(), _i.call(this, i, new wi({
            color: r
        }));
        var o = new zn;
        o.addAttribute("position", new En([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), o.computeBoundingSphere(), this.add(new Nn(o, new Bn({
            color: r,
            opacity: .2,
            transparent: !0,
            depthWrite: !1
        })))
    }

    function fc(t, e, n, r, i, o) {
        vn.call(this), void 0 === r && (r = 16776960), void 0 === n && (n = 1), void 0 === i && (i = .2 * n), void 0 === o && (o = .2 * i), void 0 === Rs && ((Rs = new zn).addAttribute("position", new En([0, 0, 0, 0, 1, 0], 3)), (Is = new Uo(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(e), this.line = new _i(Rs, new wi({
            color: r
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Nn(Is, new Bn({
            color: r
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, i, o)
    }

    function dc(t) {
        var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
            n = new zn;
        n.addAttribute("position", new En(e, 3)), n.addAttribute("color", new En([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
        var r = new wi({
            vertexColors: _
        });
        Mi.call(this, n, r)
    }

    function vc(t, e, n, r, i, o, a) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new ln(t, e, n, i, o, a)
    }
    Object.assign(Ds.prototype, {
            getValue: function(t, e) {
                this.bind();
                var n = this._targetGroup.nCachedObjects_,
                    r = this._bindings[n];
                void 0 !== r && r.getValue(t, e)
            },
            setValue: function(t, e) {
                for (var n = this._bindings, r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(t, e)
            },
            bind: function() {
                for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
            },
            unbind: function() {
                for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
            }
        }), Object.assign(Os, {
            Composite: Ds,
            create: function(t, e, n) {
                return t && t.isAnimationObjectGroup ? new Os.Composite(t, e, n) : new Os(t, e, n)
            },
            sanitizeNodeName: function() {
                var t = new RegExp("[\\[\\]\\.:\\/]", "g");
                return function(e) {
                    return e.replace(/\s/g, "_").replace(t, "")
                }
            }(),
            parseTrackName: function() {
                var t = "[^\\[\\]\\.:\\/]",
                    e = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
                    n = /((?:WC+[\/:])*)/.source.replace("WC", t),
                    r = /(WCOD+)?/.source.replace("WCOD", e),
                    i = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", t),
                    o = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", t),
                    a = new RegExp("^" + n + r + i + o + "$"),
                    s = ["material", "materials", "bones"];
                return function(t) {
                    var e = a.exec(t);
                    if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                    var n = {
                            nodeName: e[2],
                            objectName: e[3],
                            objectIndex: e[4],
                            propertyName: e[5],
                            propertyIndex: e[6]
                        },
                        r = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== r && -1 !== r) {
                        var i = n.nodeName.substring(r + 1); - 1 !== s.indexOf(i) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = i)
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                    return n
                }
            }(),
            findNode: function(t, e) {
                if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                if (t.skeleton) {
                    var n = t.skeleton.getBoneByName(e);
                    if (void 0 !== n) return n
                }
                if (t.children) {
                    var r = function(t) {
                            for (var n = 0; n < t.length; n++) {
                                var i = t[n];
                                if (i.name === e || i.uuid === e) return i;
                                var o = r(i.children);
                                if (o) return o
                            }
                            return null
                        },
                        i = r(t.children);
                    if (i) return i
                }
                return null
            }
        }), Object.assign(Os.prototype, {
            _getValue_unavailable: function() {},
            _setValue_unavailable: function() {},
            BindingType: {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            },
            Versioning: {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            },
            GetterByBindingType: [function(t, e) {
                t[e] = this.node[this.propertyName]
            }, function(t, e) {
                for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) t[e++] = n[r]
            }, function(t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }, function(t, e) {
                this.resolvedProperty.toArray(t, e)
            }],
            SetterByBindingTypeAndVersioning: [
                [function(t, e) {
                    this.targetObject[this.propertyName] = t[e]
                }, function(t, e) {
                    this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(t, e) {
                    for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = t[e++]
                }, function(t, e) {
                    for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
                    this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e]
                }, function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(t, e) {
                    this.resolvedProperty.fromArray(t, e)
                }, function(t, e) {
                    this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                }]
            ],
            getValue: function(t, e) {
                this.bind(), this.getValue(t, e)
            },
            setValue: function(t, e) {
                this.bind(), this.setValue(t, e)
            },
            bind: function() {
                var t = this.node,
                    e = this.parsedPath,
                    n = e.objectName,
                    r = e.propertyName,
                    i = e.propertyIndex;
                if (t || (t = Os.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
                    if (n) {
                        var o = e.objectIndex;
                        switch (n) {
                            case "materials":
                                if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                t = t.material.materials;
                                break;
                            case "bones":
                                if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                t = t.skeleton.bones;
                                for (var a = 0; a < t.length; a++)
                                    if (t[a].name === o) {
                                        o = a;
                                        break
                                    }
                                break;
                            default:
                                if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                t = t[n]
                        }
                        if (void 0 !== o) {
                            if (void 0 === t[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                            t = t[o]
                        }
                    }
                    var s = t[r];
                    if (void 0 !== s) {
                        var c = this.Versioning.None;
                        this.targetObject = t, void 0 !== t.needsUpdate ? c = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate);
                        var u = this.BindingType.Direct;
                        if (void 0 !== i) {
                            if ("morphTargetInfluences" === r) {
                                if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                if (t.geometry.isBufferGeometry) {
                                    if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                    for (a = 0; a < this.node.geometry.morphAttributes.position.length; a++)
                                        if (t.geometry.morphAttributes.position[a].name === i) {
                                            i = a;
                                            break
                                        }
                                } else {
                                    if (!t.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                    for (a = 0; a < this.node.geometry.morphTargets.length; a++)
                                        if (t.geometry.morphTargets[a].name === i) {
                                            i = a;
                                            break
                                        }
                                }
                            }
                            u = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = i
                        } else void 0 !== s.fromArray && void 0 !== s.toArray ? (u = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (u = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r;
                        this.getValue = this.GetterByBindingType[u], this.setValue = this.SetterByBindingTypeAndVersioning[u][c]
                    } else {
                        var l = e.nodeName;
                        console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + r + " but it wasn't found.", t)
                    }
                } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
            },
            unbind: function() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }),
        //!\ DECLARE ALIAS AFTER assign prototype !
        Object.assign(Os.prototype, {
            _getValue_unbound: Os.prototype.getValue,
            _setValue_unbound: Os.prototype.setValue
        }), Object.assign(Fs.prototype, {
            isAnimationObjectGroup: !0,
            add: function() {
                for (var t = this._objects, e = t.length, n = this.nCachedObjects_, r = this._indicesByUUID, i = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, c = void 0, u = 0, l = arguments.length; u !== l; ++u) {
                    var h = arguments[u],
                        f = h.uuid,
                        d = r[f];
                    if (void 0 === d) {
                        d = e++, r[f] = d, t.push(h);
                        for (var v = 0, p = s; v !== p; ++v) a[v].push(new Os(h, i[v], o[v]))
                    } else if (d < n) {
                        c = t[d];
                        var m = --n,
                            g = t[m];
                        r[g.uuid] = d, t[d] = g, r[f] = m, t[m] = h;
                        for (v = 0, p = s; v !== p; ++v) {
                            var y = a[v],
                                x = y[m],
                                b = y[d];
                            y[d] = x, void 0 === b && (b = new Os(h, i[v], o[v])), y[m] = b
                        }
                    } else t[d] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                }
                this.nCachedObjects_ = n
            },
            remove: function() {
                for (var t = this._objects, e = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, i = r.length, o = 0, a = arguments.length; o !== a; ++o) {
                    var s = arguments[o],
                        c = s.uuid,
                        u = n[c];
                    if (void 0 !== u && u >= e) {
                        var l = e++,
                            h = t[l];
                        n[h.uuid] = u, t[u] = h, n[c] = l, t[l] = s;
                        for (var f = 0, d = i; f !== d; ++f) {
                            var v = r[f],
                                p = v[l],
                                m = v[u];
                            v[u] = p, v[l] = m
                        }
                    }
                }
                this.nCachedObjects_ = e
            },
            uncache: function() {
                for (var t = this._objects, e = t.length, n = this.nCachedObjects_, r = this._indicesByUUID, i = this._bindings, o = i.length, a = 0, s = arguments.length; a !== s; ++a) {
                    var c = arguments[a].uuid,
                        u = r[c];
                    if (void 0 !== u)
                        if (delete r[c], u < n) {
                            var l = --n,
                                h = t[l],
                                f = t[g = --e];
                            r[h.uuid] = u, t[u] = h, r[f.uuid] = l, t[l] = f, t.pop();
                            for (var d = 0, v = o; d !== v; ++d) {
                                var p = (y = i[d])[l],
                                    m = y[g];
                                y[u] = p, y[l] = m, y.pop()
                            }
                        } else {
                            var g;
                            r[(f = t[g = --e]).uuid] = u, t[u] = f, t.pop();
                            for (d = 0, v = o; d !== v; ++d) {
                                var y;
                                (y = i[d])[u] = y[g], y.pop()
                            }
                        }
                }
                this.nCachedObjects_ = n
            },
            subscribe_: function(t, e) {
                var n = this._bindingsIndicesByPath,
                    r = n[t],
                    i = this._bindings;
                if (void 0 !== r) return i[r];
                var o = this._paths,
                    a = this._parsedPaths,
                    s = this._objects,
                    c = s.length,
                    u = this.nCachedObjects_,
                    l = new Array(c);
                r = i.length, n[t] = r, o.push(t), a.push(e), i.push(l);
                for (var h = u, f = s.length; h !== f; ++h) {
                    var d = s[h];
                    l[h] = new Os(d, t, e)
                }
                return l
            },
            unsubscribe_: function(t) {
                var e = this._bindingsIndicesByPath,
                    n = e[t];
                if (void 0 !== n) {
                    var r = this._paths,
                        i = this._parsedPaths,
                        o = this._bindings,
                        a = o.length - 1,
                        s = o[a];
                    e[t[a]] = n, o[n] = s, o.pop(), i[n] = i[a], i.pop(), r[n] = r[a], r.pop()
                }
            }
        }), Object.assign(js.prototype, {
            play: function() {
                return this._mixer._activateAction(this), this
            },
            stop: function() {
                return this._mixer._deactivateAction(this), this.reset()
            },
            reset: function() {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            },
            isRunning: function() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            },
            isScheduled: function() {
                return this._mixer._isActiveAction(this)
            },
            startAt: function(t) {
                return this._startTime = t, this
            },
            setLoop: function(t, e) {
                return this.loop = t, this.repetitions = e, this
            },
            setEffectiveWeight: function(t) {
                return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
            },
            getEffectiveWeight: function() {
                return this._effectiveWeight
            },
            fadeIn: function(t) {
                return this._scheduleFading(t, 0, 1)
            },
            fadeOut: function(t) {
                return this._scheduleFading(t, 1, 0)
            },
            crossFadeFrom: function(t, e, n) {
                if (t.fadeOut(e), this.fadeIn(e), n) {
                    var r = this._clip.duration,
                        i = t._clip.duration,
                        o = i / r,
                        a = r / i;
                    t.warp(1, o, e), this.warp(a, 1, e)
                }
                return this
            },
            crossFadeTo: function(t, e, n) {
                return t.crossFadeFrom(this, e, n)
            },
            stopFading: function() {
                var t = this._weightInterpolant;
                return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            },
            setEffectiveTimeScale: function(t) {
                return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
            },
            getEffectiveTimeScale: function() {
                return this._effectiveTimeScale
            },
            setDuration: function(t) {
                return this.timeScale = this._clip.duration / t, this.stopWarping()
            },
            syncWith: function(t) {
                return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
            },
            halt: function(t) {
                return this.warp(this._effectiveTimeScale, 0, t)
            },
            warp: function(t, e, n) {
                var r = this._mixer,
                    i = r.time,
                    o = this._timeScaleInterpolant,
                    a = this.timeScale;
                null === o && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o);
                var s = o.parameterPositions,
                    c = o.sampleValues;
                return s[0] = i, s[1] = i + n, c[0] = t / a, c[1] = e / a, this
            },
            stopWarping: function() {
                var t = this._timeScaleInterpolant;
                return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            },
            getMixer: function() {
                return this._mixer
            },
            getClip: function() {
                return this._clip
            },
            getRoot: function() {
                return this._localRoot || this._mixer._root
            },
            _update: function(t, e, n, r) {
                if (this.enabled) {
                    var i = this._startTime;
                    if (null !== i) {
                        var o = (t - i) * n;
                        if (o < 0 || 0 === n) return;
                        this._startTime = null, e = n * o
                    }
                    e *= this._updateTimeScale(t);
                    var a = this._updateTime(e),
                        s = this._updateWeight(t);
                    if (s > 0)
                        for (var c = this._interpolants, u = this._propertyBindings, l = 0, h = c.length; l !== h; ++l) c[l].evaluate(a), u[l].accumulate(r, s)
                } else this._updateWeight(t)
            },
            _updateWeight: function(t) {
                var e = 0;
                if (this.enabled) {
                    e = this.weight;
                    var n = this._weightInterpolant;
                    if (null !== n) {
                        var r = n.evaluate(t)[0];
                        e *= r, t > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = e, e
            },
            _updateTimeScale: function(t) {
                var e = 0;
                if (!this.paused) {
                    e = this.timeScale;
                    var n = this._timeScaleInterpolant;
                    if (null !== n) e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                }
                return this._effectiveTimeScale = e, e
            },
            _updateTime: function(t) {
                var e = this.time + t,
                    n = this._clip.duration,
                    r = this.loop,
                    i = this._loopCount,
                    o = r === me;
                if (0 === t) return -1 === i ? e : o && 1 == (1 & i) ? n - e : e;
                if (r === ve) {
                    -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                    t: {
                        if (e >= n) e = n;
                        else {
                            if (!(e < 0)) break t;
                            e = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (-1 === i && (t >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), e >= n || e < 0) {
                        var a = Math.floor(e / n);
                        e -= n * a, i += Math.abs(a);
                        var s = this.repetitions - i;
                        if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = t > 0 ? n : 0, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t > 0 ? 1 : -1
                        });
                        else {
                            if (1 === s) {
                                var c = t < 0;
                                this._setEndings(c, !c, o)
                            } else this._setEndings(!1, !1, o);
                            this._loopCount = i, this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: a
                            })
                        }
                    }
                    if (o && 1 == (1 & i)) return this.time = e, n - e
                }
                return this.time = e, e
            },
            _setEndings: function(t, e, n) {
                var r = this._interpolantSettings;
                n ? (r.endingStart = we, r.endingEnd = we) : (r.endingStart = t ? this.zeroSlopeAtStart ? we : be : _e, r.endingEnd = e ? this.zeroSlopeAtEnd ? we : be : _e)
            },
            _scheduleFading: function(t, e, n) {
                var r = this._mixer,
                    i = r.time,
                    o = this._weightInterpolant;
                null === o && (o = r._lendControlInterpolant(), this._weightInterpolant = o);
                var a = o.parameterPositions,
                    s = o.sampleValues;
                return a[0] = i, s[0] = e, a[1] = i + t, s[1] = n, this
            }
        }), ks.prototype = Object.assign(Object.create(r.prototype), {
            constructor: ks,
            _bindAction: function(t, e) {
                var n = t._localRoot || this._root,
                    r = t._clip.tracks,
                    i = r.length,
                    o = t._propertyBindings,
                    a = t._interpolants,
                    s = n.uuid,
                    c = this._bindingsByRootAndName,
                    u = c[s];
                void 0 === u && (u = {}, c[s] = u);
                for (var l = 0; l !== i; ++l) {
                    var h = r[l],
                        f = h.name,
                        d = u[f];
                    if (void 0 !== d) o[l] = d;
                    else {
                        if (void 0 !== (d = o[l])) {
                            null === d._cacheIndex && (++d.referenceCount, this._addInactiveBinding(d, s, f));
                            continue
                        }
                        var v = e && e._propertyBindings[l].binding.parsedPath;
                        ++(d = new Cs(Os.create(n, f, v), h.ValueTypeName, h.getValueSize())).referenceCount, this._addInactiveBinding(d, s, f), o[l] = d
                    }
                    a[l].resultBuffer = d.buffer
                }
            },
            _activateAction: function(t) {
                if (!this._isActiveAction(t)) {
                    if (null === t._cacheIndex) {
                        var e = (t._localRoot || this._root).uuid,
                            n = t._clip.uuid,
                            r = this._actionsByClip[n];
                        this._bindAction(t, r && r.knownActions[0]), this._addInactiveAction(t, n, e)
                    }
                    for (var i = t._propertyBindings, o = 0, a = i.length; o !== a; ++o) {
                        var s = i[o];
                        0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                    }
                    this._lendAction(t)
                }
            },
            _deactivateAction: function(t) {
                if (this._isActiveAction(t)) {
                    for (var e = t._propertyBindings, n = 0, r = e.length; n !== r; ++n) {
                        var i = e[n];
                        0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i))
                    }
                    this._takeBackAction(t)
                }
            },
            _initMemoryManager: function() {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                var t = this;
                this.stats = {
                    actions: {get total() {
                            return t._actions.length
                        },
                        get inUse() {
                            return t._nActiveActions
                        }
                    },
                    bindings: {get total() {
                            return t._bindings.length
                        },
                        get inUse() {
                            return t._nActiveBindings
                        }
                    },
                    controlInterpolants: {get total() {
                            return t._controlInterpolants.length
                        },
                        get inUse() {
                            return t._nActiveControlInterpolants
                        }
                    }
                }
            },
            _isActiveAction: function(t) {
                var e = t._cacheIndex;
                return null !== e && e < this._nActiveActions
            },
            _addInactiveAction: function(t, e, n) {
                var r = this._actions,
                    i = this._actionsByClip,
                    o = i[e];
                if (void 0 === o) o = {
                    knownActions: [t],
                    actionByRoot: {}
                }, t._byClipCacheIndex = 0, i[e] = o;
                else {
                    var a = o.knownActions;
                    t._byClipCacheIndex = a.length, a.push(t)
                }
                t._cacheIndex = r.length, r.push(t), o.actionByRoot[n] = t
            },
            _removeInactiveAction: function(t) {
                var e = this._actions,
                    n = e[e.length - 1],
                    r = t._cacheIndex;
                n._cacheIndex = r, e[r] = n, e.pop(), t._cacheIndex = null;
                var i = t._clip.uuid,
                    o = this._actionsByClip,
                    a = o[i],
                    s = a.knownActions,
                    c = s[s.length - 1],
                    u = t._byClipCacheIndex;
                c._byClipCacheIndex = u, s[u] = c, s.pop(), t._byClipCacheIndex = null, delete a.actionByRoot[(t._localRoot || this._root).uuid], 0 === s.length && delete o[i], this._removeInactiveBindingsForAction(t)
            },
            _removeInactiveBindingsForAction: function(t) {
                for (var e = t._propertyBindings, n = 0, r = e.length; n !== r; ++n) {
                    var i = e[n];
                    0 == --i.referenceCount && this._removeInactiveBinding(i)
                }
            },
            _lendAction: function(t) {
                var e = this._actions,
                    n = t._cacheIndex,
                    r = this._nActiveActions++,
                    i = e[r];
                t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
            },
            _takeBackAction: function(t) {
                var e = this._actions,
                    n = t._cacheIndex,
                    r = --this._nActiveActions,
                    i = e[r];
                t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
            },
            _addInactiveBinding: function(t, e, n) {
                var r = this._bindingsByRootAndName,
                    i = r[e],
                    o = this._bindings;
                void 0 === i && (i = {}, r[e] = i), i[n] = t, t._cacheIndex = o.length, o.push(t)
            },
            _removeInactiveBinding: function(t) {
                var e = this._bindings,
                    n = t.binding,
                    r = n.rootNode.uuid,
                    i = n.path,
                    o = this._bindingsByRootAndName,
                    a = o[r],
                    s = e[e.length - 1],
                    c = t._cacheIndex;
                s._cacheIndex = c, e[c] = s, e.pop(), delete a[i];
                t: {
                    for (var u in a) break t;
                    delete o[r]
                }
            },
            _lendBinding: function(t) {
                var e = this._bindings,
                    n = t._cacheIndex,
                    r = this._nActiveBindings++,
                    i = e[r];
                t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
            },
            _takeBackBinding: function(t) {
                var e = this._bindings,
                    n = t._cacheIndex,
                    r = --this._nActiveBindings,
                    i = e[r];
                t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
            },
            _lendControlInterpolant: function() {
                var t = this._controlInterpolants,
                    e = this._nActiveControlInterpolants++,
                    n = t[e];
                return void 0 === n && ((n = new Ka(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e, t[e] = n), n
            },
            _takeBackControlInterpolant: function(t) {
                var e = this._controlInterpolants,
                    n = t.__cacheIndex,
                    r = --this._nActiveControlInterpolants,
                    i = e[r];
                t.__cacheIndex = r, e[r] = t, i.__cacheIndex = n, e[n] = i
            },
            _controlInterpolantsResultBuffer: new Float32Array(1),
            clipAction: function(t, e) {
                var n = e || this._root,
                    r = n.uuid,
                    i = "string" == typeof t ? os.findByName(n, t) : t,
                    o = null !== i ? i.uuid : t,
                    a = this._actionsByClip[o],
                    s = null;
                if (void 0 !== a) {
                    var c = a.actionByRoot[r];
                    if (void 0 !== c) return c;
                    s = a.knownActions[0], null === i && (i = s._clip)
                }
                if (null === i) return null;
                var u = new js(this, i, e);
                return this._bindAction(u, s), this._addInactiveAction(u, o, r), u
            },
            existingAction: function(t, e) {
                var n = e || this._root,
                    r = n.uuid,
                    i = "string" == typeof t ? os.findByName(n, t) : t,
                    o = i ? i.uuid : t,
                    a = this._actionsByClip[o];
                return void 0 !== a && a.actionByRoot[r] || null
            },
            stopAllAction: function() {
                var t = this._actions,
                    e = this._nActiveActions,
                    n = this._bindings,
                    r = this._nActiveBindings;
                this._nActiveActions = 0, this._nActiveBindings = 0;
                for (var i = 0; i !== e; ++i) t[i].reset();
                for (i = 0; i !== r; ++i) n[i].useCount = 0;
                return this
            },
            update: function(t) {
                t *= this.timeScale;
                for (var e = this._actions, n = this._nActiveActions, r = this.time += t, i = Math.sign(t), o = this._accuIndex ^= 1, a = 0; a !== n; ++a) {
                    e[a]._update(r, t, i, o)
                }
                var s = this._bindings,
                    c = this._nActiveBindings;
                for (a = 0; a !== c; ++a) s[a].apply(o);
                return this
            },
            getRoot: function() {
                return this._root
            },
            uncacheClip: function(t) {
                var e = this._actions,
                    n = t.uuid,
                    r = this._actionsByClip,
                    i = r[n];
                if (void 0 !== i) {
                    for (var o = i.knownActions, a = 0, s = o.length; a !== s; ++a) {
                        var c = o[a];
                        this._deactivateAction(c);
                        var u = c._cacheIndex,
                            l = e[e.length - 1];
                        c._cacheIndex = null, c._byClipCacheIndex = null, l._cacheIndex = u, e[u] = l, e.pop(), this._removeInactiveBindingsForAction(c)
                    }
                    delete r[n]
                }
            },
            uncacheRoot: function(t) {
                var e = t.uuid,
                    n = this._actionsByClip;
                for (var r in n) {
                    var i = n[r].actionByRoot[e];
                    void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                }
                var o = this._bindingsByRootAndName[e];
                if (void 0 !== o)
                    for (var a in o) {
                        var s = o[a];
                        s.restoreOriginalState(), this._removeInactiveBinding(s)
                    }
            },
            uncacheAction: function(t, e) {
                var n = this.existingAction(t, e);
                null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
            }
        }), Us.prototype.clone = function() {
            return new Us(void 0 === this.value.clone ? this.value : this.value.clone())
        }, Bs.prototype = Object.assign(Object.create(zn.prototype), {
            constructor: Bs,
            isInstancedBufferGeometry: !0,
            copy: function(t) {
                return zn.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            }
        }), Ns.prototype = Object.assign(Object.create(di.prototype), {
            constructor: Ns,
            isInstancedInterleavedBuffer: !0,
            copy: function(t) {
                return di.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
            }
        }), Gs.prototype = Object.assign(Object.create(gn.prototype), {
            constructor: Gs,
            isInstancedBufferAttribute: !0,
            copy: function(t) {
                return gn.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
            }
        }), Object.assign(Hs.prototype, {
            linePrecision: 1,
            set: function(t, e) {
                this.ray.set(t, e)
            },
            setFromCamera: function(t, e) {
                e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
            },
            intersectObject: function(t, e, n) {
                var r = n || [];
                return Ws(t, this, r, e), r.sort(Vs), r
            },
            intersectObjects: function(t, e, n) {
                var r = n || [];
                if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), r;
                for (var i = 0, o = t.length; i < o; i++) Ws(t[i], this, r, e);
                return r.sort(Vs), r
            }
        }), Object.assign(Ys.prototype, {
            start: function() {
                this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
            },
            stop: function() {
                this.getElapsedTime(), this.running = !1, this.autoStart = !1
            },
            getElapsedTime: function() {
                return this.getDelta(), this.elapsedTime
            },
            getDelta: function() {
                var t = 0;
                if (this.autoStart && !this.running) return this.start(), 0;
                if (this.running) {
                    var e = ("undefined" == typeof performance ? Date : performance).now();
                    t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                }
                return t
            }
        }), Object.assign(Xs.prototype, {
            set: function(t, e, n) {
                return this.radius = t, this.phi = e, this.theta = n, this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
            },
            makeSafe: function() {
                return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
            },
            setFromVector3: function(t) {
                return this.setFromCartesianCoords(t.x, t.y, t.z)
            },
            setFromCartesianCoords: function(t, e, n) {
                return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(ke.clamp(e / this.radius, -1, 1))), this
            }
        }), Object.assign(qs.prototype, {
            set: function(t, e, n) {
                return this.radius = t, this.theta = e, this.y = n, this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
            },
            setFromVector3: function(t) {
                return this.setFromCartesianCoords(t.x, t.y, t.z)
            },
            setFromCartesianCoords: function(t, e, n) {
                return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this
            }
        }), Object.assign(Ks.prototype, {
            set: function(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            },
            setFromPoints: function(t) {
                this.makeEmpty();
                for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                return this
            },
            setFromCenterAndSize: function() {
                var t = new Ue;
                return function(e, n) {
                    var r = t.copy(n).multiplyScalar(.5);
                    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this
                }
            }(),
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            },
            makeEmpty: function() {
                return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
            },
            isEmpty: function() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            },
            getCenter: function(t) {
                return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new Ue), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            },
            getSize: function(t) {
                return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new Ue), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
            },
            expandByPoint: function(t) {
                return this.min.min(t), this.max.max(t), this
            },
            expandByVector: function(t) {
                return this.min.sub(t), this.max.add(t), this
            },
            expandByScalar: function(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            },
            containsPoint: function(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
            },
            containsBox: function(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
            },
            getParameter: function(t, e) {
                return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new Ue), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
            },
            intersectsBox: function(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
            },
            clampPoint: function(t, e) {
                return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new Ue), e.copy(t).clamp(this.min, this.max)
            },
            distanceToPoint: function() {
                var t = new Ue;
                return function(e) {
                    return t.copy(e).clamp(this.min, this.max).sub(e).length()
                }
            }(),
            intersect: function(t) {
                return this.min.max(t.min), this.max.min(t.max), this
            },
            union: function(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            },
            translate: function(t) {
                return this.min.add(t), this.max.add(t), this
            },
            equals: function(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }), Object.assign(Zs.prototype, {
            set: function(t, e) {
                return this.start.copy(t), this.end.copy(e), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.start.copy(t.start), this.end.copy(t.end), this
            },
            getCenter: function(t) {
                return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new Ge), t.addVectors(this.start, this.end).multiplyScalar(.5)
            },
            delta: function(t) {
                return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new Ge), t.subVectors(this.end, this.start)
            },
            distanceSq: function() {
                return this.start.distanceToSquared(this.end)
            },
            distance: function() {
                return this.start.distanceTo(this.end)
            },
            at: function(t, e) {
                return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new Ge), this.delta(e).multiplyScalar(t).add(this.start)
            },
            closestPointToPointParameter: function() {
                var t = new Ge,
                    e = new Ge;
                return function(n, r) {
                    t.subVectors(n, this.start), e.subVectors(this.end, this.start);
                    var i = e.dot(e),
                        o = e.dot(t) / i;
                    return r && (o = ke.clamp(o, 0, 1)), o
                }
            }(),
            closestPointToPoint: function(t, e, n) {
                var r = this.closestPointToPointParameter(t, e);
                return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new Ge), this.delta(n).multiplyScalar(r).add(this.start)
            },
            applyMatrix4: function(t) {
                return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
            },
            equals: function(t) {
                return t.start.equals(this.start) && t.end.equals(this.end)
            }
        }), Js.prototype = Object.create(vn.prototype), Js.prototype.constructor = Js, Js.prototype.isImmediateRenderObject = !0, Qs.prototype = Object.create(Mi.prototype), Qs.prototype.constructor = Qs, Qs.prototype.update = function() {
            var t = new Ge,
                e = new Ge,
                n = new He;
            return function() {
                var r = ["a", "b", "c"];
                this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld);
                var i = this.object.matrixWorld,
                    o = this.geometry.attributes.position,
                    a = this.object.geometry;
                if (a && a.isGeometry)
                    for (var s = a.vertices, c = a.faces, u = 0, l = 0, h = c.length; l < h; l++)
                        for (var f = c[l], d = 0, v = f.vertexNormals.length; d < v; d++) {
                            var p = s[f[r[d]]],
                                m = f.vertexNormals[d];
                            t.copy(p).applyMatrix4(i), e.copy(m).applyMatrix3(n).normalize().multiplyScalar(this.size).add(t), o.setXYZ(u, t.x, t.y, t.z), u += 1, o.setXYZ(u, e.x, e.y, e.z), u += 1
                        } else if (a && a.isBufferGeometry) {
                            var g = a.attributes.position,
                                y = a.attributes.normal;
                            for (u = 0, d = 0, v = g.count; d < v; d++) t.set(g.getX(d), g.getY(d), g.getZ(d)).applyMatrix4(i), e.set(y.getX(d), y.getY(d), y.getZ(d)), e.applyMatrix3(n).normalize().multiplyScalar(this.size).add(t), o.setXYZ(u, t.x, t.y, t.z), u += 1, o.setXYZ(u, e.x, e.y, e.z), u += 1
                        }
                o.needsUpdate = !0
            }
        }(), $s.prototype = Object.create(vn.prototype), $s.prototype.constructor = $s, $s.prototype.dispose = function() {
            this.cone.geometry.dispose(), this.cone.material.dispose()
        }, $s.prototype.update = function() {
            var t = new Ge,
                e = new Ge;
            return function() {
                this.light.updateMatrixWorld();
                var n = this.light.distance ? this.light.distance : 1e3,
                    r = n * Math.tan(this.light.angle);
                this.cone.scale.set(r, r, n), t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e.sub(t)), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
            }
        }(), tc.prototype = Object.create(Mi.prototype), tc.prototype.constructor = tc, tc.prototype.updateMatrixWorld = function() {
            var t = new Ge,
                e = new Be,
                n = new Be;
            return function(r) {
                var i = this.bones,
                    o = this.geometry,
                    a = o.getAttribute("position");
                n.getInverse(this.root.matrixWorld);
                for (var s = 0, c = 0; s < i.length; s++) {
                    var u = i[s];
                    u.parent && u.parent.isBone && (e.multiplyMatrices(n, u.matrixWorld), t.setFromMatrixPosition(e), a.setXYZ(c, t.x, t.y, t.z), e.multiplyMatrices(n, u.parent.matrixWorld), t.setFromMatrixPosition(e), a.setXYZ(c + 1, t.x, t.y, t.z), c += 2)
                }
                o.getAttribute("position").needsUpdate = !0, vn.prototype.updateMatrixWorld.call(this, r)
            }
        }(), ec.prototype = Object.create(Nn.prototype), ec.prototype.constructor = ec, ec.prototype.dispose = function() {
            this.geometry.dispose(), this.material.dispose()
        }, ec.prototype.update = function() {
            void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
        }, nc.prototype = Object.create(vn.prototype), nc.prototype.constructor = nc, nc.prototype.dispose = function() {
            this.children[0].geometry.dispose(), this.children[0].material.dispose()
        }, nc.prototype.update = function() {
            var t = .5 * this.light.width,
                e = .5 * this.light.height,
                n = this.line.geometry.attributes.position,
                r = n.array;
            r[0] = t, r[1] = -e, r[2] = 0, r[3] = t, r[4] = e, r[5] = 0, r[6] = -t, r[7] = e, r[8] = 0, r[9] = -t, r[10] = -e, r[11] = 0, r[12] = t, r[13] = -e, r[14] = 0, n.needsUpdate = !0, void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color)
        }, rc.prototype = Object.create(vn.prototype), rc.prototype.constructor = rc, rc.prototype.dispose = function() {
            this.children[0].geometry.dispose(), this.children[0].material.dispose()
        }, rc.prototype.update = function() {
            var t = new Ge,
                e = new on,
                n = new on;
            return function() {
                var r = this.children[0];
                if (void 0 !== this.color) this.material.color.set(this.color);
                else {
                    var i = r.geometry.getAttribute("color");
                    e.copy(this.light.color), n.copy(this.light.groundColor);
                    for (var o = 0, a = i.count; o < a; o++) {
                        var s = o < a / 2 ? e : n;
                        i.setXYZ(o, s.r, s.g, s.b)
                    }
                    i.needsUpdate = !0
                }
                r.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate())
            }
        }(), ic.prototype = Object.create(Mi.prototype), ic.prototype.constructor = ic, oc.prototype = Object.create(Mi.prototype), oc.prototype.constructor = oc, ac.prototype = Object.create(Mi.prototype), ac.prototype.constructor = ac, ac.prototype.update = function() {
            var t = new Ge,
                e = new Ge,
                n = new He;
            return function() {
                this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld);
                for (var r = this.object.matrixWorld, i = this.geometry.attributes.position, o = this.object.geometry, a = o.vertices, s = o.faces, c = 0, u = 0, l = s.length; u < l; u++) {
                    var h = s[u],
                        f = h.normal;
                    t.copy(a[h.a]).add(a[h.b]).add(a[h.c]).divideScalar(3).applyMatrix4(r), e.copy(f).applyMatrix3(n).normalize().multiplyScalar(this.size).add(t), i.setXYZ(c, t.x, t.y, t.z), c += 1, i.setXYZ(c, e.x, e.y, e.z), c += 1
                }
                i.needsUpdate = !0
            }
        }(), sc.prototype = Object.create(vn.prototype), sc.prototype.constructor = sc, sc.prototype.dispose = function() {
            this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
        }, sc.prototype.update = function() {
            var t = new Ge,
                e = new Ge,
                n = new Ge;
            return function() {
                t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), n.subVectors(e, t), this.lightPlane.lookAt(n), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(n), this.targetLine.scale.z = n.length()
            }
        }(), cc.prototype = Object.create(Mi.prototype), cc.prototype.constructor = cc, cc.prototype.update = function() {
            var t, e, n = new Ge,
                r = new oi;

            function i(i, o, a, s) {
                n.set(o, a, s).unproject(r);
                var c = e[i];
                if (void 0 !== c)
                    for (var u = t.getAttribute("position"), l = 0, h = c.length; l < h; l++) u.setXYZ(c[l], n.x, n.y, n.z)
            }
            return function() {
                t = this.geometry, e = this.pointMap;
                r.projectionMatrix.copy(this.camera.projectionMatrix), i("c", 0, 0, -1), i("t", 0, 0, 1), i("n1", -1, -1, -1), i("n2", 1, -1, -1), i("n3", -1, 1, -1), i("n4", 1, 1, -1), i("f1", -1, -1, 1), i("f2", 1, -1, 1), i("f3", -1, 1, 1), i("f4", 1, 1, 1), i("u1", .7, 1.1, -1), i("u2", -.7, 1.1, -1), i("u3", 0, 2, -1), i("cf1", -1, 0, 1), i("cf2", 1, 0, 1), i("cf3", 0, -1, 1), i("cf4", 0, 1, 1), i("cn1", -1, 0, -1), i("cn2", 1, 0, -1), i("cn3", 0, -1, -1), i("cn4", 0, 1, -1), t.getAttribute("position").needsUpdate = !0
            }
        }(), uc.prototype = Object.create(Mi.prototype), uc.prototype.constructor = uc, uc.prototype.update = function() {
            var t = new Je;
            return function(e) {
                if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && t.setFromObject(this.object), !t.isEmpty()) {
                    var n = t.min,
                        r = t.max,
                        i = this.geometry.attributes.position,
                        o = i.array;
                    o[0] = r.x, o[1] = r.y, o[2] = r.z, o[3] = n.x, o[4] = r.y, o[5] = r.z, o[6] = n.x, o[7] = n.y, o[8] = r.z, o[9] = r.x, o[10] = n.y, o[11] = r.z, o[12] = r.x, o[13] = r.y, o[14] = n.z, o[15] = n.x, o[16] = r.y, o[17] = n.z, o[18] = n.x, o[19] = n.y, o[20] = n.z, o[21] = r.x, o[22] = n.y, o[23] = n.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere()
                }
            }
        }(), uc.prototype.setFromObject = function(t) {
            return this.object = t, this.update(), this
        }, lc.prototype = Object.create(Mi.prototype), lc.prototype.constructor = lc, lc.prototype.updateMatrixWorld = function(t) {
            var e = this.box;
            e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), vn.prototype.updateMatrixWorld.call(this, t))
        }, hc.prototype = Object.create(_i.prototype), hc.prototype.constructor = hc, hc.prototype.updateMatrixWorld = function(t) {
            var e = -this.plane.constant;
            Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? m : p, this.lookAt(this.plane.normal), vn.prototype.updateMatrixWorld.call(this, t)
        }, fc.prototype = Object.create(vn.prototype), fc.prototype.constructor = fc, fc.prototype.setDirection = function() {
            var t, e = new Ge;
            return function(n) {
                n.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : n.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (e.set(n.z, 0, -n.x).normalize(), t = Math.acos(n.y), this.quaternion.setFromAxisAngle(e, t))
            }
        }(), fc.prototype.setLength = function(t, e, n) {
            void 0 === e && (e = .2 * t), void 0 === n && (n = .2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix()
        }, fc.prototype.setColor = function(t) {
            this.line.material.color.copy(t), this.cone.material.color.copy(t)
        }, dc.prototype = Object.create(Mi.prototype), dc.prototype.constructor = dc;
    var pc = 0,
        mc = 1;

    function gc(t) {
        return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
    }

    function yc(t) {
        return void 0 === t && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function() {
            return t.slice()
        }, t
    }

    function xc(t, e) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Ti(t, e)
    }

    function bc(t) {
        return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new mi(t)
    }

    function wc(t, e) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Ti(t, e)
    }

    function _c(t) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Ei(t)
    }

    function Mc(t) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Ei(t)
    }

    function Sc(t) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Ei(t)
    }

    function Ec(t, e, n) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Ge(t, e, n)
    }

    function Tc(t, e) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new gn(t, e).setDynamic(!0)
    }

    function Pc(t, e) {
        return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new yn(t, e)
    }

    function Lc(t, e) {
        return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new xn(t, e)
    }

    function Ac(t, e) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new bn(t, e)
    }

    function zc(t, e) {
        return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new wn(t, e)
    }

    function Cc(t, e) {
        return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new _n(t, e)
    }

    function Rc(t, e) {
        return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Mn(t, e)
    }

    function Ic(t, e) {
        return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Sn(t, e)
    }

    function Dc(t, e) {
        return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new En(t, e)
    }

    function Oc(t, e) {
        return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Tn(t, e)
    }

    function Fc(t) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), ba.call(this, t), this.type = "catmullrom", this.closed = !0
    }

    function jc(t) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), ba.call(this, t), this.type = "catmullrom"
    }

    function kc(t) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), ba.call(this, t), this.type = "catmullrom"
    }

    function Uc(t) {
        return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new dc(t)
    }

    function Bc(t, e) {
        return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new uc(t, e)
    }

    function Nc(t, e) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Mi(new jo(t.geometry), new wi({
            color: void 0 !== e ? e : 16777215
        }))
    }

    function Gc(t, e) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Mi(new Ci(t.geometry), new wi({
            color: void 0 !== e ? e : 16777215
        }))
    }

    function Hc(t) {
        return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new aa(t)
    }

    function Vc(t) {
        return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new ca(t)
    }
    fa.create = function(t, e) {
        return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(fa.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
    }, Object.assign(Ra.prototype, {
        createPointsGeometry: function(t) {
            console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            var e = this.getPoints(t);
            return this.createGeometry(e)
        },
        createSpacedPointsGeometry: function(t) {
            console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            var e = this.getSpacedPoints(t);
            return this.createGeometry(e)
        },
        createGeometry: function(t) {
            console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            for (var e = new mn, n = 0, r = t.length; n < r; n++) {
                var i = t[n];
                e.vertices.push(new Ge(i.x, i.y, i.z || 0))
            }
            return e
        }
    }), Object.assign(Ia.prototype, {
        fromPoints: function(t) {
            console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
        }
    }), Fc.prototype = Object.create(ba.prototype), jc.prototype = Object.create(ba.prototype), kc.prototype = Object.create(ba.prototype), Object.assign(kc.prototype, {
        initFromArray: function() {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        },
        getControlPointsArray: function() {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        },
        reparametrizeByArcLength: function() {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }), ic.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }, tc.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }, Object.assign(ls.prototype, {
        extractUrlBase: function(t) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), hs.extractUrlBase(t)
        }
    }), Object.assign(fs.prototype, {
        setTexturePath: function(t) {
            return console.warn("THREE.JSONLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t)
        }
    }), Object.assign(Ks.prototype, {
        center: function(t) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
        },
        empty: function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function(t) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        },
        size: function(t) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
        }
    }), Object.assign(Je.prototype, {
        center: function(t) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
        },
        empty: function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function(t) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        },
        isIntersectionSphere: function(t) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
        },
        size: function(t) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
        }
    }), Zs.prototype.center = function(t) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
    }, Object.assign(ke, {
        random16: function() {
            return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
        },
        nearestPowerOfTwo: function(t) {
            return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), ke.floorPowerOfTwo(t)
        },
        nextPowerOfTwo: function(t) {
            return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), ke.ceilPowerOfTwo(t)
        }
    }), Object.assign(He.prototype, {
        flattenToArrayOffset: function(t, e) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
        },
        multiplyVector3: function(t) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        },
        applyToBuffer: function(t) {
            return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
    }), Object.assign(Be.prototype, {
        extractPosition: function(t) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
        },
        flattenToArrayOffset: function(t, e) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
        },
        getPosition: function() {
            var t;
            return function() {
                return void 0 === t && (t = new Ge), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), t.setFromMatrixColumn(this, 3)
            }
        }(),
        setRotationFromQuaternion: function(t) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
        },
        multiplyToArray: function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        },
        multiplyVector3: function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        },
        multiplyVector4: function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        },
        rotateAxis: function(t) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
        },
        crossVector: function(t) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        },
        translate: function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        applyToBuffer: function(t) {
            return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function(t, e, n, r, i, o) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, r, n, i, o)
        }
    }), $e.prototype.isIntersectionLine = function(t) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
    }, Ne.prototype.multiplyVector3 = function(t) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
    }, Object.assign(kn.prototype, {
        isIntersectionBox: function(t) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        },
        isIntersectionPlane: function(t) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
        },
        isIntersectionSphere: function(t) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
        }
    }), Object.assign(Un.prototype, {
        area: function() {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
        },
        barycoordFromPoint: function(t, e) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
        },
        midpoint: function(t) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
        },
        normal: function(t) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
        },
        plane: function(t) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
        }
    }), Object.assign(Un, {
        barycoordFromPoint: function(t, e, n, r, i) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Un.getBarycoord(t, e, n, r, i)
        },
        normal: function(t, e, n, r) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Un.getNormal(t, e, n, r)
        }
    }), Object.assign(Da.prototype, {
        extractAllPoints: function(t) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
        },
        extrude: function(t) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new _o(this, t)
        },
        makeGeometry: function(t) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Do(this, t)
        }
    }), Object.assign(Ue.prototype, {
        fromAttribute: function(t, e, n) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
        },
        distanceToManhattan: function(t) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(Ge.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function(t) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
        },
        getScaleFromMatrix: function(t) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
        },
        getColumnFromMatrix: function(t, e) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
        },
        applyProjection: function(t) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
        },
        fromAttribute: function(t, e, n) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
        },
        distanceToManhattan: function(t) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(Xe.prototype, {
        fromAttribute: function(t, e, n) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(mn.prototype, {
        computeTangents: function() {
            console.error("THREE.Geometry: .computeTangents() has been removed.")
        },
        computeLineDistances: function() {
            console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
        }
    }), Object.assign(vn.prototype, {
        getChildByName: function(t) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
        },
        renderDepth: function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function(t, e) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
        },
        getWorldRotation: function() {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        }
    }), Object.defineProperties(vn.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
            },
            set: function(t) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }), Object.defineProperties(gi.prototype, {
        objects: {
            get: function() {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
            }
        }
    }), Object.defineProperty(yi.prototype, "useVertexTexture", {
        get: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        },
        set: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }
    }), Object.defineProperty(fa.prototype, "__arcLengthDivisions", {
        get: function() {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
        },
        set: function(t) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t
        }
    }), ai.prototype.setLens = function(t, e) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
    }, Object.defineProperties(Oa.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
            }
        },
        shadowCameraLeft: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
            }
        },
        shadowCameraRight: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
            }
        },
        shadowCameraTop: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
            }
        },
        shadowCameraBottom: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
            }
        },
        shadowCameraNear: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
            }
        },
        shadowCameraFar: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function(t) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function(t) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
            }
        },
        shadowMapHeight: {
            set: function(t) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
            }
        }
    }), Object.defineProperties(gn.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
            }
        },
        copyIndicesArray: function() {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        }
    }), Object.assign(zn.prototype, {
        addIndex: function(t) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
        },
        addDrawCall: function(t, e, n) {
            void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
        },
        clearDrawCalls: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
        },
        computeTangents: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }
    }), Object.defineProperties(zn.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
            }
        }
    }), Object.assign(Mo.prototype, {
        getArrays: function() {
            console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
        },
        addShapeList: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
        },
        addShape: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
        }
    }), Object.defineProperties(Us.prototype, {
        dynamic: {
            set: function() {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        },
        onUpdate: {
            value: function() {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
            }
        }
    }), Object.defineProperties(Fn.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE.Material: .wrapRGB has been removed."), new on
            }
        },
        shading: {
            get: function() {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function(t) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = t === y
            }
        }
    }), Object.defineProperties(Ko.prototype, {
        metal: {
            get: function() {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
            },
            set: function() {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    }), Object.defineProperties(jn.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
            },
            set: function(t) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
            }
        }
    }), Object.assign(ui.prototype, {
        clearTarget: function(t, e, n, r) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, r)
        },
        animate: function(t) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
        },
        getCurrentRenderTarget: function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
        },
        getMaxAnisotropy: function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
        },
        resetGLState: function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
        },
        supportsFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function(t) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
        },
        initMaterial: function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        },
        addPrePlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        },
        updateShadowMap: function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        },
        setFaceCulling: function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        }
    }), Object.defineProperties(ui.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
            }
        },
        shadowMapCullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        }
    }), Object.defineProperties(ei.prototype, {
        cullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        renderReverseSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        },
        renderSingleSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }), Object.defineProperties(qe.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
            }
        }
    }), Object.defineProperties(ci.prototype, {
        standing: {
            set: function() {
                console.warn("THREE.WebVRManager: .standing has been removed.")
            }
        },
        userHeight: {
            set: function() {
                console.warn("THREE.WebVRManager: .userHeight has been removed.")
            }
        }
    }), Ls.prototype.load = function(t) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        var e = this;
        return (new Ss).load(t, function(t) {
            e.setBuffer(t)
        }), this
    }, zs.prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
    }, Ts.prototype.updateCubeMap = function(t, e) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
    };
    var Wc = {
        merge: function(t, e, n) {
            var r;
            console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), r = e.matrix, e = e.geometry), t.merge(e, r, n)
        },
        center: function(t) {
            return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center()
        }
    };

    function Yc() {
        console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(t, e) {
            console.warn("THREE.Projector: .projectVector() is now vector.project()."), t.project(e)
        }, this.unprojectVector = function(t, e) {
            console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), t.unproject(e)
        }, this.pickingRay = function() {
            console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
        }
    }

    function Xc() {
        console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {}, this.setSize = function() {}
    }
    Ve.crossOrigin = void 0, Ve.loadTexture = function(t, e, n, r) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        var i = new ha;
        i.setCrossOrigin(this.crossOrigin);
        var o = i.load(t, n, void 0, r);
        return e && (o.mapping = e), o
    }, Ve.loadTextureCube = function(t, e, n, r) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        var i = new la;
        i.setCrossOrigin(this.crossOrigin);
        var o = i.load(t, n, void 0, r);
        return e && (o.mapping = e), o
    }, Ve.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
    }, Ve.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
    };
    var qc = {
        createMultiMaterialObject: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        detach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        attach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        }
    };

    function Kc() {
        console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
    }
}, function(t, e, n) {
    var r = n(5),
        i = n(11),
        o = n(18),
        a = n(15),
        s = n(25),
        c = function(t, e, n) {
            var u, l, h, f, d = t & c.F,
                v = t & c.G,
                p = t & c.S,
                m = t & c.P,
                g = t & c.B,
                y = v ? r : p ? r[e] || (r[e] = {}) : (r[e] || {}).prototype,
                x = v ? i : i[e] || (i[e] = {}),
                b = x.prototype || (x.prototype = {});
            for (u in v && (n = e), n) h = ((l = !d && y && void 0 !== y[u]) ? y : n)[u], f = g && l ? s(h, r) : m && "function" == typeof h ? s(Function.call, h) : h, y && a(y, u, h, t & c.U), x[u] != h && o(x, u, f), m && b[u] != h && (b[u] = h)
        };
    r.core = i, c.F = 1, c.G = 2, c.S = 4, c.P = 8, c.B = 16, c.W = 32, c.U = 64, c.R = 128, t.exports = c
}, function(t, e) {
    t.exports = {
        degrees: function(t) {
            return t / Math.PI * 180
        },
        radians: function(t) {
            return t * Math.PI / 180
        },
        clamp: function(t, e, n) {
            return Math.min(Math.max(t, e), n)
        },
        mix: function(t, e, n) {
            return t * (1 - n) + e * n
        },
        step: function(t, e) {
            return e >= t ? 1 : 0
        },
        smoothstep: function(t, e, n) {
            if (!(t >= e)) {
                var r = Math.min(Math.max((n - t) / (e - t), 0), 1);
                return r * r * (3 - 2 * r)
            }
        },
        spherical: function(t, e, n) {
            return [Math.cos(t) * Math.cos(e) * n, Math.sin(t) * n, Math.cos(t) * Math.sin(e) * n]
        },
        randomArbitrary: function(t, e) {
            return Math.random() * (e - t) + t
        },
        randomInt: function(t, e) {
            return Math.floor(Math.random() * (e - t + 1)) + t
        }
    }
}, function(t, e) {
    t.exports = function(t, e) {
        var n;
        return function(r) {
            clearTimeout(n), n = setTimeout(function() {
                t(r)
            }, e)
        }
    }
}, function(t, e) {
    t.exports = function(t) {
        try {
            return !!t()
        } catch (t) {
            return !0
        }
    }
}, function(t, e) {
    var n = t.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
    "number" == typeof __g && (__g = n)
}, function(t, e) {
    t.exports = function(t) {
        return "object" == typeof t ? null !== t : "function" == typeof t
    }
}, function(t, e, n) {
    var r = n(6);
    t.exports = function(t) {
        if (!r(t)) throw TypeError(t + " is not an object!");
        return t
    }
}, function(t, e, n) {
    var r = n(70)("wks"),
        i = n(35),
        o = n(5).Symbol,
        a = "function" == typeof o;
    (t.exports = function(t) {
        return r[t] || (r[t] = a && o[t] || (a ? o : i)("Symbol." + t))
    }).store = r
}, function(t, e, n) {
    var r = n(7),
        i = n(102),
        o = n(32),
        a = Object.defineProperty;
    e.f = n(10) ? Object.defineProperty : function(t, e, n) {
        if (r(t), e = o(e, !0), r(n), i) try {
            return a(t, e, n)
        } catch (t) {}
        if ("get" in n || "set" in n) throw TypeError("Accessors not supported!");
        return "value" in n && (t[e] = n.value), t
    }
}, function(t, e, n) {
    t.exports = !n(4)(function() {
        return 7 != Object.defineProperty({}, "a", {
            get: function() {
                return 7
            }
        }).a
    })
}, function(t, e) {
    var n = t.exports = {
        version: "2.5.7"
    };
    "number" == typeof __e && (__e = n)
}, function(t, e, n) {
    var r = n(29),
        i = Math.min;
    t.exports = function(t) {
        return t > 0 ? i(r(t), 9007199254740991) : 0
    }
}, function(t, e, n) {
    "use strict";
    n.r(e), e.default = function(t) {
        t.x = t.x / document.body.clientWidth * 2 - 1, t.y = -t.y / window.innerHeight * 2 + 1
    }
}, function(t, e, n) {
    var r = n(0);
    t.exports = {
        getRandomInt: function(t, e) {
            return Math.floor(Math.random() * (e - t)) + t
        },
        getDegree: function(t) {
            return t / Math.PI * 180
        },
        getRadian: function(t) {
            return t * Math.PI / 180
        },
        getPolarCoord: function(t, e, n) {
            var i = Math.cos(t) * Math.cos(e) * n,
                o = Math.cos(t) * Math.sin(e) * n,
                a = Math.sin(t) * n;
            return new r.Vector3(i, a, o)
        }
    }
}, function(t, e, n) {
    var r = n(5),
        i = n(18),
        o = n(17),
        a = n(35)("src"),
        s = Function.toString,
        c = ("" + s).split("toString");
    n(11).inspectSource = function(t) {
        return s.call(t)
    }, (t.exports = function(t, e, n, s) {
        var u = "function" == typeof n;
        u && (o(n, "name") || i(n, "name", e)), t[e] !== n && (u && (o(n, a) || i(n, a, t[e] ? "" + t[e] : c.join(String(e)))), t === r ? t[e] = n : s ? t[e] ? t[e] = n : i(t, e, n) : (delete t[e], i(t, e, n)))
    })(Function.prototype, "toString", function() {
        return "function" == typeof this && this[a] || s.call(this)
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(4),
        o = n(28),
        a = /"/g,
        s = function(t, e, n, r) {
            var i = String(o(t)),
                s = "<" + e;
            return "" !== n && (s += " " + n + '="' + String(r).replace(a, "&quot;") + '"'), s + ">" + i + "</" + e + ">"
        };
    t.exports = function(t, e) {
        var n = {};
        n[t] = e(s), r(r.P + r.F * i(function() {
            var e = "" [t]('"');
            return e !== e.toLowerCase() || e.split('"').length > 3
        }), "String", n)
    }
}, function(t, e) {
    var n = {}.hasOwnProperty;
    t.exports = function(t, e) {
        return n.call(t, e)
    }
}, function(t, e, n) {
    var r = n(9),
        i = n(34);
    t.exports = n(10) ? function(t, e, n) {
        return r.f(t, e, i(1, n))
    } : function(t, e, n) {
        return t[e] = n, t
    }
}, function(t, e, n) {
    var r = n(50),
        i = n(28);
    t.exports = function(t) {
        return r(i(t))
    }
}, function(t, e, n) {
    var r = n(28);
    t.exports = function(t) {
        return Object(r(t))
    }
}, function(t, e, n) {
    "use strict";
    var r = n(4);
    t.exports = function(t, e) {
        return !!t && r(function() {
            e ? t.call(null, function() {}, 1) : t.call(null)
        })
    }
}, function(t, e, n) {
    var r = n(51),
        i = n(34),
        o = n(19),
        a = n(32),
        s = n(17),
        c = n(102),
        u = Object.getOwnPropertyDescriptor;
    e.f = n(10) ? u : function(t, e) {
        if (t = o(t), e = a(e, !0), c) try {
            return u(t, e)
        } catch (t) {}
        if (s(t, e)) return i(!r.f.call(t, e), t[e])
    }
}, function(t, e, n) {
    var r = n(1),
        i = n(11),
        o = n(4);
    t.exports = function(t, e) {
        var n = (i.Object || {})[t] || Object[t],
            a = {};
        a[t] = e(n), r(r.S + r.F * o(function() {
            n(1)
        }), "Object", a)
    }
}, function(t, e, n) {
    var r = n(25),
        i = n(50),
        o = n(20),
        a = n(12),
        s = n(235);
    t.exports = function(t, e) {
        var n = 1 == t,
            c = 2 == t,
            u = 3 == t,
            l = 4 == t,
            h = 6 == t,
            f = 5 == t || h,
            d = e || s;
        return function(e, s, v) {
            for (var p, m, g = o(e), y = i(g), x = r(s, v, 3), b = a(y.length), w = 0, _ = n ? d(e, b) : c ? d(e, 0) : void 0; b > w; w++)
                if ((f || w in y) && (m = x(p = y[w], w, g), t))
                    if (n) _[w] = m;
                    else if (m) switch (t) {
                case 3:
                    return !0;
                case 5:
                    return p;
                case 6:
                    return w;
                case 2:
                    _.push(p)
            } else if (l) return !1;
            return h ? -1 : u || l ? l : _
        }
    }
}, function(t, e, n) {
    var r = n(26);
    t.exports = function(t, e, n) {
        if (r(t), void 0 === e) return t;
        switch (n) {
            case 1:
                return function(n) {
                    return t.call(e, n)
                };
            case 2:
                return function(n, r) {
                    return t.call(e, n, r)
                };
            case 3:
                return function(n, r, i) {
                    return t.call(e, n, r, i)
                }
        }
        return function() {
            return t.apply(e, arguments)
        }
    }
}, function(t, e) {
    t.exports = function(t) {
        if ("function" != typeof t) throw TypeError(t + " is not a function!");
        return t
    }
}, function(t, e) {
    var n = {}.toString;
    t.exports = function(t) {
        return n.call(t).slice(8, -1)
    }
}, function(t, e) {
    t.exports = function(t) {
        if (void 0 == t) throw TypeError("Can't call method on  " + t);
        return t
    }
}, function(t, e) {
    var n = Math.ceil,
        r = Math.floor;
    t.exports = function(t) {
        return isNaN(t = +t) ? 0 : (t > 0 ? r : n)(t)
    }
}, function(t, e, n) {
    "use strict";
    if (n(10)) {
        var r = n(36),
            i = n(5),
            o = n(4),
            a = n(1),
            s = n(62),
            c = n(93),
            u = n(25),
            l = n(47),
            h = n(34),
            f = n(18),
            d = n(48),
            v = n(29),
            p = n(12),
            m = n(127),
            g = n(38),
            y = n(32),
            x = n(17),
            b = n(54),
            w = n(6),
            _ = n(20),
            M = n(86),
            S = n(39),
            E = n(41),
            T = n(40).f,
            P = n(88),
            L = n(35),
            A = n(8),
            z = n(24),
            C = n(52),
            R = n(59),
            I = n(90),
            D = n(44),
            O = n(56),
            F = n(46),
            j = n(89),
            k = n(119),
            U = n(9),
            B = n(22),
            N = U.f,
            G = B.f,
            H = i.RangeError,
            V = i.TypeError,
            W = i.Uint8Array,
            Y = Array.prototype,
            X = c.ArrayBuffer,
            q = c.DataView,
            K = z(0),
            Z = z(2),
            J = z(3),
            Q = z(4),
            $ = z(5),
            tt = z(6),
            et = C(!0),
            nt = C(!1),
            rt = I.values,
            it = I.keys,
            ot = I.entries,
            at = Y.lastIndexOf,
            st = Y.reduce,
            ct = Y.reduceRight,
            ut = Y.join,
            lt = Y.sort,
            ht = Y.slice,
            ft = Y.toString,
            dt = Y.toLocaleString,
            vt = A("iterator"),
            pt = A("toStringTag"),
            mt = L("typed_constructor"),
            gt = L("def_constructor"),
            yt = s.CONSTR,
            xt = s.TYPED,
            bt = s.VIEW,
            wt = z(1, function(t, e) {
                return Tt(R(t, t[gt]), e)
            }),
            _t = o(function() {
                return 1 === new W(new Uint16Array([1]).buffer)[0]
            }),
            Mt = !!W && !!W.prototype.set && o(function() {
                new W(1).set({})
            }),
            St = function(t, e) {
                var n = v(t);
                if (n < 0 || n % e) throw H("Wrong offset!");
                return n
            },
            Et = function(t) {
                if (w(t) && xt in t) return t;
                throw V(t + " is not a typed array!")
            },
            Tt = function(t, e) {
                if (!(w(t) && mt in t)) throw V("It is not a typed array constructor!");
                return new t(e)
            },
            Pt = function(t, e) {
                return Lt(R(t, t[gt]), e)
            },
            Lt = function(t, e) {
                for (var n = 0, r = e.length, i = Tt(t, r); r > n;) i[n] = e[n++];
                return i
            },
            At = function(t, e, n) {
                N(t, e, {
                    get: function() {
                        return this._d[n]
                    }
                })
            },
            zt = function(t) {
                var e, n, r, i, o, a, s = _(t),
                    c = arguments.length,
                    l = c > 1 ? arguments[1] : void 0,
                    h = void 0 !== l,
                    f = P(s);
                if (void 0 != f && !M(f)) {
                    for (a = f.call(s), r = [], e = 0; !(o = a.next()).done; e++) r.push(o.value);
                    s = r
                }
                for (h && c > 2 && (l = u(l, arguments[2], 2)), e = 0, n = p(s.length), i = Tt(this, n); n > e; e++) i[e] = h ? l(s[e], e) : s[e];
                return i
            },
            Ct = function() {
                for (var t = 0, e = arguments.length, n = Tt(this, e); e > t;) n[t] = arguments[t++];
                return n
            },
            Rt = !!W && o(function() {
                dt.call(new W(1))
            }),
            It = function() {
                return dt.apply(Rt ? ht.call(Et(this)) : Et(this), arguments)
            },
            Dt = {
                copyWithin: function(t, e) {
                    return k.call(Et(this), t, e, arguments.length > 2 ? arguments[2] : void 0)
                },
                every: function(t) {
                    return Q(Et(this), t, arguments.length > 1 ? arguments[1] : void 0)
                },
                fill: function(t) {
                    return j.apply(Et(this), arguments)
                },
                filter: function(t) {
                    return Pt(this, Z(Et(this), t, arguments.length > 1 ? arguments[1] : void 0))
                },
                find: function(t) {
                    return $(Et(this), t, arguments.length > 1 ? arguments[1] : void 0)
                },
                findIndex: function(t) {
                    return tt(Et(this), t, arguments.length > 1 ? arguments[1] : void 0)
                },
                forEach: function(t) {
                    K(Et(this), t, arguments.length > 1 ? arguments[1] : void 0)
                },
                indexOf: function(t) {
                    return nt(Et(this), t, arguments.length > 1 ? arguments[1] : void 0)
                },
                includes: function(t) {
                    return et(Et(this), t, arguments.length > 1 ? arguments[1] : void 0)
                },
                join: function(t) {
                    return ut.apply(Et(this), arguments)
                },
                lastIndexOf: function(t) {
                    return at.apply(Et(this), arguments)
                },
                map: function(t) {
                    return wt(Et(this), t, arguments.length > 1 ? arguments[1] : void 0)
                },
                reduce: function(t) {
                    return st.apply(Et(this), arguments)
                },
                reduceRight: function(t) {
                    return ct.apply(Et(this), arguments)
                },
                reverse: function() {
                    for (var t, e = Et(this).length, n = Math.floor(e / 2), r = 0; r < n;) t = this[r], this[r++] = this[--e], this[e] = t;
                    return this
                },
                some: function(t) {
                    return J(Et(this), t, arguments.length > 1 ? arguments[1] : void 0)
                },
                sort: function(t) {
                    return lt.call(Et(this), t)
                },
                subarray: function(t, e) {
                    var n = Et(this),
                        r = n.length,
                        i = g(t, r);
                    return new(R(n, n[gt]))(n.buffer, n.byteOffset + i * n.BYTES_PER_ELEMENT, p((void 0 === e ? r : g(e, r)) - i))
                }
            },
            Ot = function(t, e) {
                return Pt(this, ht.call(Et(this), t, e))
            },
            Ft = function(t) {
                Et(this);
                var e = St(arguments[1], 1),
                    n = this.length,
                    r = _(t),
                    i = p(r.length),
                    o = 0;
                if (i + e > n) throw H("Wrong length!");
                for (; o < i;) this[e + o] = r[o++]
            },
            jt = {
                entries: function() {
                    return ot.call(Et(this))
                },
                keys: function() {
                    return it.call(Et(this))
                },
                values: function() {
                    return rt.call(Et(this))
                }
            },
            kt = function(t, e) {
                return w(t) && t[xt] && "symbol" != typeof e && e in t && String(+e) == String(e)
            },
            Ut = function(t, e) {
                return kt(t, e = y(e, !0)) ? h(2, t[e]) : G(t, e)
            },
            Bt = function(t, e, n) {
                return !(kt(t, e = y(e, !0)) && w(n) && x(n, "value")) || x(n, "get") || x(n, "set") || n.configurable || x(n, "writable") && !n.writable || x(n, "enumerable") && !n.enumerable ? N(t, e, n) : (t[e] = n.value, t)
            };
        yt || (B.f = Ut, U.f = Bt), a(a.S + a.F * !yt, "Object", {
            getOwnPropertyDescriptor: Ut,
            defineProperty: Bt
        }), o(function() {
            ft.call({})
        }) && (ft = dt = function() {
            return ut.call(this)
        });
        var Nt = d({}, Dt);
        d(Nt, jt), f(Nt, vt, jt.values), d(Nt, {
            slice: Ot,
            set: Ft,
            constructor: function() {},
            toString: ft,
            toLocaleString: It
        }), At(Nt, "buffer", "b"), At(Nt, "byteOffset", "o"), At(Nt, "byteLength", "l"), At(Nt, "length", "e"), N(Nt, pt, {
            get: function() {
                return this[xt]
            }
        }), t.exports = function(t, e, n, c) {
            var u = t + ((c = !!c) ? "Clamped" : "") + "Array",
                h = "get" + t,
                d = "set" + t,
                v = i[u],
                g = v || {},
                y = v && E(v),
                x = !v || !s.ABV,
                _ = {},
                M = v && v.prototype,
                P = function(t, n) {
                    N(t, n, {
                        get: function() {
                            return function(t, n) {
                                var r = t._d;
                                return r.v[h](n * e + r.o, _t)
                            }(this, n)
                        },
                        set: function(t) {
                            return function(t, n, r) {
                                var i = t._d;
                                c && (r = (r = Math.round(r)) < 0 ? 0 : r > 255 ? 255 : 255 & r), i.v[d](n * e + i.o, r, _t)
                            }(this, n, t)
                        },
                        enumerable: !0
                    })
                };
            x ? (v = n(function(t, n, r, i) {
                l(t, v, u, "_d");
                var o, a, s, c, h = 0,
                    d = 0;
                if (w(n)) {
                    if (!(n instanceof X || "ArrayBuffer" == (c = b(n)) || "SharedArrayBuffer" == c)) return xt in n ? Lt(v, n) : zt.call(v, n);
                    o = n, d = St(r, e);
                    var g = n.byteLength;
                    if (void 0 === i) {
                        if (g % e) throw H("Wrong length!");
                        if ((a = g - d) < 0) throw H("Wrong length!")
                    } else if ((a = p(i) * e) + d > g) throw H("Wrong length!");
                    s = a / e
                } else s = m(n), o = new X(a = s * e);
                for (f(t, "_d", {
                        b: o,
                        o: d,
                        l: a,
                        e: s,
                        v: new q(o)
                    }); h < s;) P(t, h++)
            }), M = v.prototype = S(Nt), f(M, "constructor", v)) : o(function() {
                v(1)
            }) && o(function() {
                new v(-1)
            }) && O(function(t) {
                new v, new v(null), new v(1.5), new v(t)
            }, !0) || (v = n(function(t, n, r, i) {
                var o;
                return l(t, v, u), w(n) ? n instanceof X || "ArrayBuffer" == (o = b(n)) || "SharedArrayBuffer" == o ? void 0 !== i ? new g(n, St(r, e), i) : void 0 !== r ? new g(n, St(r, e)) : new g(n) : xt in n ? Lt(v, n) : zt.call(v, n) : new g(m(n))
            }), K(y !== Function.prototype ? T(g).concat(T(y)) : T(g), function(t) {
                t in v || f(v, t, g[t])
            }), v.prototype = M, r || (M.constructor = v));
            var L = M[vt],
                A = !!L && ("values" == L.name || void 0 == L.name),
                z = jt.values;
            f(v, mt, !0), f(M, xt, u), f(M, bt, !0), f(M, gt, v), (c ? new v(1)[pt] == u : pt in M) || N(M, pt, {
                get: function() {
                    return u
                }
            }), _[u] = v, a(a.G + a.W + a.F * (v != g), _), a(a.S, u, {
                BYTES_PER_ELEMENT: e
            }), a(a.S + a.F * o(function() {
                g.of.call(v, 1)
            }), u, {
                from: zt,
                of: Ct
            }), "BYTES_PER_ELEMENT" in M || f(M, "BYTES_PER_ELEMENT", e), a(a.P, u, Dt), F(u), a(a.P + a.F * Mt, u, {
                set: Ft
            }), a(a.P + a.F * !A, u, jt), r || M.toString == ft || (M.toString = ft), a(a.P + a.F * o(function() {
                new v(1).slice()
            }), u, {
                slice: Ot
            }), a(a.P + a.F * (o(function() {
                return [1, 2].toLocaleString() != new v([1, 2]).toLocaleString()
            }) || !o(function() {
                M.toLocaleString.call([1, 2])
            })), u, {
                toLocaleString: It
            }), D[u] = A ? L : z, r || A || f(M, vt, z)
        }
    } else t.exports = function() {}
}, function(t, e, n) {
    var r = n(0),
        i = n(14),
        o = n(42);
    t.exports = function() {
        var t = function(t, e, n, i) {
            r.PerspectiveCamera.call(this, t, e, n, i), this.force = {
                position: new o,
                look: new o
            }, this.up.set(0, 1, 0)
        };
        return (t.prototype = Object.create(r.PerspectiveCamera.prototype)).constructor = t, t.prototype.updatePosition = function() {
            this.position.copy(this.force.position.velocity)
        }, t.prototype.updateLook = function() {
            this.lookAt(this.force.look.velocity.x, this.force.look.velocity.y, this.force.look.velocity.z)
        }, t.prototype.reset = function() {
            this.setPolarCoord(), this.lookAtCenter()
        }, t.prototype.resize = function(t, e) {
            this.aspect = t / e, this.updateProjectionMatrix()
        }, t.prototype.setPolarCoord = function(t, e, n) {
            this.force.position.anchor.copy(i.getPolarCoord(t, e, n))
        }, t.prototype.lookAtCenter = function() {
            this.lookAt(0, 0, 0)
        }, t
    }()
}, function(t, e, n) {
    var r = n(6);
    t.exports = function(t, e) {
        if (!r(t)) return t;
        var n, i;
        if (e && "function" == typeof(n = t.toString) && !r(i = n.call(t))) return i;
        if ("function" == typeof(n = t.valueOf) && !r(i = n.call(t))) return i;
        if (!e && "function" == typeof(n = t.toString) && !r(i = n.call(t))) return i;
        throw TypeError("Can't convert object to primitive value")
    }
}, function(t, e, n) {
    var r = n(35)("meta"),
        i = n(6),
        o = n(17),
        a = n(9).f,
        s = 0,
        c = Object.isExtensible || function() {
            return !0
        },
        u = !n(4)(function() {
            return c(Object.preventExtensions({}))
        }),
        l = function(t) {
            a(t, r, {
                value: {
                    i: "O" + ++s,
                    w: {}
                }
            })
        },
        h = t.exports = {
            KEY: r,
            NEED: !1,
            fastKey: function(t, e) {
                if (!i(t)) return "symbol" == typeof t ? t : ("string" == typeof t ? "S" : "P") + t;
                if (!o(t, r)) {
                    if (!c(t)) return "F";
                    if (!e) return "E";
                    l(t)
                }
                return t[r].i
            },
            getWeak: function(t, e) {
                if (!o(t, r)) {
                    if (!c(t)) return !0;
                    if (!e) return !1;
                    l(t)
                }
                return t[r].w
            },
            onFreeze: function(t) {
                return u && h.NEED && c(t) && !o(t, r) && l(t), t
            }
        }
}, function(t, e) {
    t.exports = function(t, e) {
        return {
            enumerable: !(1 & t),
            configurable: !(2 & t),
            writable: !(4 & t),
            value: e
        }
    }
}, function(t, e) {
    var n = 0,
        r = Math.random();
    t.exports = function(t) {
        return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++n + r).toString(36))
    }
}, function(t, e) {
    t.exports = !1
}, function(t, e, n) {
    var r = n(104),
        i = n(73);
    t.exports = Object.keys || function(t) {
        return r(t, i)
    }
}, function(t, e, n) {
    var r = n(29),
        i = Math.max,
        o = Math.min;
    t.exports = function(t, e) {
        return (t = r(t)) < 0 ? i(t + e, 0) : o(t, e)
    }
}, function(t, e, n) {
    var r = n(7),
        i = n(105),
        o = n(73),
        a = n(72)("IE_PROTO"),
        s = function() {},
        c = function() {
            var t, e = n(69)("iframe"),
                r = o.length;
            for (e.style.display = "none", n(75).appendChild(e), e.src = "javascript:", (t = e.contentWindow.document).open(), t.write("<script>document.F=Object<\/script>"), t.close(), c = t.F; r--;) delete c.prototype[o[r]];
            return c()
        };
    t.exports = Object.create || function(t, e) {
        var n;
        return null !== t ? (s.prototype = r(t), n = new s, s.prototype = null, n[a] = t) : n = c(), void 0 === e ? n : i(n, e)
    }
}, function(t, e, n) {
    var r = n(104),
        i = n(73).concat("length", "prototype");
    e.f = Object.getOwnPropertyNames || function(t) {
        return r(t, i)
    }
}, function(t, e, n) {
    var r = n(17),
        i = n(20),
        o = n(72)("IE_PROTO"),
        a = Object.prototype;
    t.exports = Object.getPrototypeOf || function(t) {
        return t = i(t), r(t, o) ? t[o] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? a : null
    }
}, function(t, e, n) {
    var r = n(0);
    n(14);
    t.exports = function() {
        var t = function() {
            this.velocity = new r.Vector3, this.acceleration = new r.Vector3, this.anchor = new r.Vector3, this.mass = 1
        };
        return t.prototype.updateVelocity = function() {
            this.acceleration.divideScalar(this.mass), this.velocity.add(this.acceleration)
        }, t.prototype.applyForce = function(t) {
            this.acceleration.add(t)
        }, t.prototype.applyFriction = function(t, e) {
            var n = this.acceleration.clone();
            e || (e = 1), n.multiplyScalar(-1), n.normalize(), n.multiplyScalar(t), this.applyForce(n)
        }, t.prototype.applyDrag = function(t) {
            var e = this.acceleration.clone();
            e.multiplyScalar(-1), e.normalize(), e.multiplyScalar(this.acceleration.length() * t), this.applyForce(e)
        }, t.prototype.applyHook = function(t, e) {
            var n = this.velocity.clone().sub(this.anchor),
                r = n.length() - t;
            n.normalize(), n.multiplyScalar(-1 * e * r), this.applyForce(n)
        }, t
    }()
}, function(t, e, n) {
    var r = n(9).f,
        i = n(17),
        o = n(8)("toStringTag");
    t.exports = function(t, e, n) {
        t && !i(t = n ? t : t.prototype, o) && r(t, o, {
            configurable: !0,
            value: e
        })
    }
}, function(t, e) {
    t.exports = {}
}, function(t, e, n) {
    var r = n(8)("unscopables"),
        i = Array.prototype;
    void 0 == i[r] && n(18)(i, r, {}), t.exports = function(t) {
        i[r][t] = !0
    }
}, function(t, e, n) {
    "use strict";
    var r = n(5),
        i = n(9),
        o = n(10),
        a = n(8)("species");
    t.exports = function(t) {
        var e = r[t];
        o && e && !e[a] && i.f(e, a, {
            configurable: !0,
            get: function() {
                return this
            }
        })
    }
}, function(t, e) {
    t.exports = function(t, e, n, r) {
        if (!(t instanceof e) || void 0 !== r && r in t) throw TypeError(n + ": incorrect invocation!");
        return t
    }
}, function(t, e, n) {
    var r = n(15);
    t.exports = function(t, e, n) {
        for (var i in e) r(t, i, e[i], n);
        return t
    }
}, function(t, e, n) {
    var r = n(6);
    t.exports = function(t, e) {
        if (!r(t) || t._t !== e) throw TypeError("Incompatible receiver, " + e + " required!");
        return t
    }
}, function(t, e, n) {
    var r = n(27);
    t.exports = Object("z").propertyIsEnumerable(0) ? Object : function(t) {
        return "String" == r(t) ? t.split("") : Object(t)
    }
}, function(t, e) {
    e.f = {}.propertyIsEnumerable
}, function(t, e, n) {
    var r = n(19),
        i = n(12),
        o = n(38);
    t.exports = function(t) {
        return function(e, n, a) {
            var s, c = r(e),
                u = i(c.length),
                l = o(a, u);
            if (t && n != n) {
                for (; u > l;)
                    if ((s = c[l++]) != s) return !0
            } else
                for (; u > l; l++)
                    if ((t || l in c) && c[l] === n) return t || l || 0; return !t && -1
        }
    }
}, function(t, e) {
    e.f = Object.getOwnPropertySymbols
}, function(t, e, n) {
    var r = n(27),
        i = n(8)("toStringTag"),
        o = "Arguments" == r(function() {
            return arguments
        }());
    t.exports = function(t) {
        var e, n, a;
        return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof(n = function(t, e) {
            try {
                return t[e]
            } catch (t) {}
        }(e = Object(t), i)) ? n : o ? r(e) : "Object" == (a = r(e)) && "function" == typeof e.callee ? "Arguments" : a
    }
}, function(t, e, n) {
    var r = n(1),
        i = n(28),
        o = n(4),
        a = n(77),
        s = "[" + a + "]",
        c = RegExp("^" + s + s + "*"),
        u = RegExp(s + s + "*$"),
        l = function(t, e, n) {
            var i = {},
                s = o(function() {
                    return !!a[t]() || "​" != "​" [t]()
                }),
                c = i[t] = s ? e(h) : a[t];
            n && (i[n] = c), r(r.P + r.F * s, "String", i)
        },
        h = l.trim = function(t, e) {
            return t = String(i(t)), 1 & e && (t = t.replace(c, "")), 2 & e && (t = t.replace(u, "")), t
        };
    t.exports = l
}, function(t, e, n) {
    var r = n(8)("iterator"),
        i = !1;
    try {
        var o = [7][r]();
        o.return = function() {
            i = !0
        }, Array.from(o, function() {
            throw 2
        })
    } catch (t) {}
    t.exports = function(t, e) {
        if (!e && !i) return !1;
        var n = !1;
        try {
            var o = [7],
                a = o[r]();
            a.next = function() {
                return {
                    done: n = !0
                }
            }, o[r] = function() {
                return a
            }, t(o)
        } catch (t) {}
        return n
    }
}, function(t, e, n) {
    "use strict";
    var r = n(18),
        i = n(15),
        o = n(4),
        a = n(28),
        s = n(8);
    t.exports = function(t, e, n) {
        var c = s(t),
            u = n(a, c, "" [t]),
            l = u[0],
            h = u[1];
        o(function() {
            var e = {};
            return e[c] = function() {
                return 7
            }, 7 != "" [t](e)
        }) && (i(String.prototype, t, l), r(RegExp.prototype, c, 2 == e ? function(t, e) {
            return h.call(t, this, e)
        } : function(t) {
            return h.call(t, this)
        }))
    }
}, function(t, e, n) {
    var r = n(25),
        i = n(117),
        o = n(86),
        a = n(7),
        s = n(12),
        c = n(88),
        u = {},
        l = {};
    (e = t.exports = function(t, e, n, h, f) {
        var d, v, p, m, g = f ? function() {
                return t
            } : c(t),
            y = r(n, h, e ? 2 : 1),
            x = 0;
        if ("function" != typeof g) throw TypeError(t + " is not iterable!");
        if (o(g)) {
            for (d = s(t.length); d > x; x++)
                if ((m = e ? y(a(v = t[x])[0], v[1]) : y(t[x])) === u || m === l) return m
        } else
            for (p = g.call(t); !(v = p.next()).done;)
                if ((m = i(p, y, v.value, e)) === u || m === l) return m
    }).BREAK = u, e.RETURN = l
}, function(t, e, n) {
    var r = n(7),
        i = n(26),
        o = n(8)("species");
    t.exports = function(t, e) {
        var n, a = r(t).constructor;
        return void 0 === a || void 0 == (n = r(a)[o]) ? e : i(n)
    }
}, function(t, e, n) {
    var r = n(5).navigator;
    t.exports = r && r.userAgent || ""
}, function(t, e, n) {
    "use strict";
    var r = n(5),
        i = n(1),
        o = n(15),
        a = n(48),
        s = n(33),
        c = n(58),
        u = n(47),
        l = n(6),
        h = n(4),
        f = n(56),
        d = n(43),
        v = n(78);
    t.exports = function(t, e, n, p, m, g) {
        var y = r[t],
            x = y,
            b = m ? "set" : "add",
            w = x && x.prototype,
            _ = {},
            M = function(t) {
                var e = w[t];
                o(w, t, "delete" == t ? function(t) {
                    return !(g && !l(t)) && e.call(this, 0 === t ? 0 : t)
                } : "has" == t ? function(t) {
                    return !(g && !l(t)) && e.call(this, 0 === t ? 0 : t)
                } : "get" == t ? function(t) {
                    return g && !l(t) ? void 0 : e.call(this, 0 === t ? 0 : t)
                } : "add" == t ? function(t) {
                    return e.call(this, 0 === t ? 0 : t), this
                } : function(t, n) {
                    return e.call(this, 0 === t ? 0 : t, n), this
                })
            };
        if ("function" == typeof x && (g || w.forEach && !h(function() {
                (new x).entries().next()
            }))) {
            var S = new x,
                E = S[b](g ? {} : -0, 1) != S,
                T = h(function() {
                    S.has(1)
                }),
                P = f(function(t) {
                    new x(t)
                }),
                L = !g && h(function() {
                    for (var t = new x, e = 5; e--;) t[b](e, e);
                    return !t.has(-0)
                });
            P || ((x = e(function(e, n) {
                u(e, x, t);
                var r = v(new y, e, x);
                return void 0 != n && c(n, m, r[b], r), r
            })).prototype = w, w.constructor = x), (T || L) && (M("delete"), M("has"), m && M("get")), (L || E) && M(b), g && w.clear && delete w.clear
        } else x = p.getConstructor(e, t, m, b), a(x.prototype, n), s.NEED = !0;
        return d(x, t), _[t] = x, i(i.G + i.W + i.F * (x != y), _), g || p.setStrong(x, t, m), x
    }
}, function(t, e, n) {
    for (var r, i = n(5), o = n(18), a = n(35), s = a("typed_array"), c = a("view"), u = !(!i.ArrayBuffer || !i.DataView), l = u, h = 0, f = "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(","); h < 9;)(r = i[f[h++]]) ? (o(r.prototype, s, !0), o(r.prototype, c, !0)) : l = !1;
    t.exports = {
        ABV: u,
        CONSTR: l,
        TYPED: s,
        VIEW: c
    }
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(68);
    e.default = {
        updateVelocity: function(t, e, n) {
            r.vec3.scale(e, e, 1 / n), r.vec3.add(t, t, e)
        },
        applyFriction: function(t, e, n) {
            var i = [0, 0, 0];
            r.vec3.scale(i, t, -1);
            r.vec3.normalize(i, i), r.vec3.scale(i, i, e), r.vec3.add(t, t, i)
        },
        applyDrag: function(t, e) {
            var n = [0, 0, 0];
            r.vec3.scale(n, t, -1), r.vec3.normalize(n, n), r.vec3.scale(n, n, r.vec3.length(t) * e), r.vec3.add(t, t, n)
        },
        applyHook: function(t, e, n, i, o) {
            var a = [0, 0, 0];
            r.vec3.sub(a, t, n);
            var s = r.vec3.length(a) - i;
            r.vec3.normalize(a, a), r.vec3.scale(a, a, -1 * o * s), r.vec3.add(e, e, a)
        }
    }
}, function(t, e, n) {
    n(0), n(14);
    var r = n(42);
    t.exports = function() {
        var t = function() {
            this.size = 0, this.time = 0, this.is_active = !1, r.call(this)
        };
        return (t.prototype = Object.create(r.prototype)).constructor = t, t.prototype.init = function(t) {
            this.velocity = t.clone(), this.anchor = t.clone(), this.acceleration.set(0, 0, 0), this.time = 0
        }, t.prototype.activate = function() {
            this.is_active = !0
        }, t.prototype.inactivate = function() {
            this.is_active = !1
        }, t
    }()
}, function(t, e, n) {
    var r = n(0),
        i = (n(14), n(42));
    t.exports = function() {
        var t = function() {
            this.geometry = new r.BufferGeometry, this.material = null, this.obj, i.call(this)
        };
        return (t.prototype = Object.create(i.prototype)).constructor = t, t.prototype.init = function(t) {
            this.material = new r.ShaderMaterial({
                uniforms: {
                    color: {
                        type: "c",
                        value: new r.Color(16777215)
                    },
                    texture: {
                        type: "t",
                        value: t.texture
                    }
                },
                vertexShader: t.vs,
                fragmentShader: t.fs,
                transparent: !0,
                depthWrite: !1,
                blending: t.blending
            }), this.geometry.addAttribute("position", new r.BufferAttribute(t.positions, 3)), this.geometry.addAttribute("customColor", new r.BufferAttribute(t.colors, 3)), this.geometry.addAttribute("vertexOpacity", new r.BufferAttribute(t.opacities, 1)), this.geometry.addAttribute("size", new r.BufferAttribute(t.sizes, 1)), this.obj = new r.Points(this.geometry, this.material), t.scene.add(this.obj)
        }, t.prototype.updatePoints = function() {
            this.obj.position.copy(this.velocity), this.obj.geometry.attributes.position.needsUpdate = !0, this.obj.geometry.attributes.vertexOpacity.needsUpdate = !0, this.obj.geometry.attributes.size.needsUpdate = !0, this.obj.geometry.attributes.customColor.needsUpdate = !0
        }, t
    }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 customColor;\nattribute float vertexOpacity;\nattribute float size;\n\nvarying vec3 vColor;\nvarying float fOpacity;\n\nvoid main() {\n  vColor = customColor;\n  fOpacity = vertexOpacity;\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  gl_PointSize = size * (300.0 / length(mvPosition.xyz));\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nuniform vec3 color;\nuniform sampler2D texture;\n\nvarying vec3 vColor;\nvarying float fOpacity;\n\nvoid main() {\n  gl_FragColor = vec4(color * vColor, fOpacity);\n  gl_FragColor = gl_FragColor * texture2D(texture, gl_PointCoord);\n}\n"
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = {};
    n.r(r), n.d(r, "EPSILON", function() {
        return d
    }), n.d(r, "ARRAY_TYPE", function() {
        return v
    }), n.d(r, "RANDOM", function() {
        return p
    }), n.d(r, "setMatrixArrayType", function() {
        return m
    }), n.d(r, "toRadian", function() {
        return y
    }), n.d(r, "equals", function() {
        return x
    });
    var i = {};
    n.r(i), n.d(i, "create", function() {
        return b
    }), n.d(i, "clone", function() {
        return w
    }), n.d(i, "copy", function() {
        return _
    }), n.d(i, "identity", function() {
        return M
    }), n.d(i, "fromValues", function() {
        return S
    }), n.d(i, "set", function() {
        return E
    }), n.d(i, "transpose", function() {
        return T
    }), n.d(i, "invert", function() {
        return P
    }), n.d(i, "adjoint", function() {
        return L
    }), n.d(i, "determinant", function() {
        return A
    }), n.d(i, "multiply", function() {
        return z
    }), n.d(i, "rotate", function() {
        return C
    }), n.d(i, "scale", function() {
        return R
    }), n.d(i, "fromRotation", function() {
        return I
    }), n.d(i, "fromScaling", function() {
        return D
    }), n.d(i, "str", function() {
        return O
    }), n.d(i, "frob", function() {
        return F
    }), n.d(i, "LDU", function() {
        return j
    }), n.d(i, "add", function() {
        return k
    }), n.d(i, "subtract", function() {
        return U
    }), n.d(i, "exactEquals", function() {
        return B
    }), n.d(i, "equals", function() {
        return N
    }), n.d(i, "multiplyScalar", function() {
        return G
    }), n.d(i, "multiplyScalarAndAdd", function() {
        return H
    }), n.d(i, "mul", function() {
        return V
    }), n.d(i, "sub", function() {
        return W
    });
    var o = {};
    n.r(o), n.d(o, "create", function() {
        return Y
    }), n.d(o, "clone", function() {
        return X
    }), n.d(o, "copy", function() {
        return q
    }), n.d(o, "identity", function() {
        return K
    }), n.d(o, "fromValues", function() {
        return Z
    }), n.d(o, "set", function() {
        return J
    }), n.d(o, "invert", function() {
        return Q
    }), n.d(o, "determinant", function() {
        return $
    }), n.d(o, "multiply", function() {
        return tt
    }), n.d(o, "rotate", function() {
        return et
    }), n.d(o, "scale", function() {
        return nt
    }), n.d(o, "translate", function() {
        return rt
    }), n.d(o, "fromRotation", function() {
        return it
    }), n.d(o, "fromScaling", function() {
        return ot
    }), n.d(o, "fromTranslation", function() {
        return at
    }), n.d(o, "str", function() {
        return st
    }), n.d(o, "frob", function() {
        return ct
    }), n.d(o, "add", function() {
        return ut
    }), n.d(o, "subtract", function() {
        return lt
    }), n.d(o, "multiplyScalar", function() {
        return ht
    }), n.d(o, "multiplyScalarAndAdd", function() {
        return ft
    }), n.d(o, "exactEquals", function() {
        return dt
    }), n.d(o, "equals", function() {
        return vt
    }), n.d(o, "mul", function() {
        return pt
    }), n.d(o, "sub", function() {
        return mt
    });
    var a = {};
    n.r(a), n.d(a, "create", function() {
        return gt
    }), n.d(a, "fromMat4", function() {
        return yt
    }), n.d(a, "clone", function() {
        return xt
    }), n.d(a, "copy", function() {
        return bt
    }), n.d(a, "fromValues", function() {
        return wt
    }), n.d(a, "set", function() {
        return _t
    }), n.d(a, "identity", function() {
        return Mt
    }), n.d(a, "transpose", function() {
        return St
    }), n.d(a, "invert", function() {
        return Et
    }), n.d(a, "adjoint", function() {
        return Tt
    }), n.d(a, "determinant", function() {
        return Pt
    }), n.d(a, "multiply", function() {
        return Lt
    }), n.d(a, "translate", function() {
        return At
    }), n.d(a, "rotate", function() {
        return zt
    }), n.d(a, "scale", function() {
        return Ct
    }), n.d(a, "fromTranslation", function() {
        return Rt
    }), n.d(a, "fromRotation", function() {
        return It
    }), n.d(a, "fromScaling", function() {
        return Dt
    }), n.d(a, "fromMat2d", function() {
        return Ot
    }), n.d(a, "fromQuat", function() {
        return Ft
    }), n.d(a, "normalFromMat4", function() {
        return jt
    }), n.d(a, "projection", function() {
        return kt
    }), n.d(a, "str", function() {
        return Ut
    }), n.d(a, "frob", function() {
        return Bt
    }), n.d(a, "add", function() {
        return Nt
    }), n.d(a, "subtract", function() {
        return Gt
    }), n.d(a, "multiplyScalar", function() {
        return Ht
    }), n.d(a, "multiplyScalarAndAdd", function() {
        return Vt
    }), n.d(a, "exactEquals", function() {
        return Wt
    }), n.d(a, "equals", function() {
        return Yt
    }), n.d(a, "mul", function() {
        return Xt
    }), n.d(a, "sub", function() {
        return qt
    });
    var s = {};
    n.r(s), n.d(s, "create", function() {
        return Kt
    }), n.d(s, "clone", function() {
        return Zt
    }), n.d(s, "copy", function() {
        return Jt
    }), n.d(s, "fromValues", function() {
        return Qt
    }), n.d(s, "set", function() {
        return $t
    }), n.d(s, "identity", function() {
        return te
    }), n.d(s, "transpose", function() {
        return ee
    }), n.d(s, "invert", function() {
        return ne
    }), n.d(s, "adjoint", function() {
        return re
    }), n.d(s, "determinant", function() {
        return ie
    }), n.d(s, "multiply", function() {
        return oe
    }), n.d(s, "translate", function() {
        return ae
    }), n.d(s, "scale", function() {
        return se
    }), n.d(s, "rotate", function() {
        return ce
    }), n.d(s, "rotateX", function() {
        return ue
    }), n.d(s, "rotateY", function() {
        return le
    }), n.d(s, "rotateZ", function() {
        return he
    }), n.d(s, "fromTranslation", function() {
        return fe
    }), n.d(s, "fromScaling", function() {
        return de
    }), n.d(s, "fromRotation", function() {
        return ve
    }), n.d(s, "fromXRotation", function() {
        return pe
    }), n.d(s, "fromYRotation", function() {
        return me
    }), n.d(s, "fromZRotation", function() {
        return ge
    }), n.d(s, "fromRotationTranslation", function() {
        return ye
    }), n.d(s, "fromQuat2", function() {
        return xe
    }), n.d(s, "getTranslation", function() {
        return be
    }), n.d(s, "getScaling", function() {
        return we
    }), n.d(s, "getRotation", function() {
        return _e
    }), n.d(s, "fromRotationTranslationScale", function() {
        return Me
    }), n.d(s, "fromRotationTranslationScaleOrigin", function() {
        return Se
    }), n.d(s, "fromQuat", function() {
        return Ee
    }), n.d(s, "frustum", function() {
        return Te
    }), n.d(s, "perspective", function() {
        return Pe
    }), n.d(s, "perspectiveFromFieldOfView", function() {
        return Le
    }), n.d(s, "ortho", function() {
        return Ae
    }), n.d(s, "lookAt", function() {
        return ze
    }), n.d(s, "targetTo", function() {
        return Ce
    }), n.d(s, "str", function() {
        return Re
    }), n.d(s, "frob", function() {
        return Ie
    }), n.d(s, "add", function() {
        return De
    }), n.d(s, "subtract", function() {
        return Oe
    }), n.d(s, "multiplyScalar", function() {
        return Fe
    }), n.d(s, "multiplyScalarAndAdd", function() {
        return je
    }), n.d(s, "exactEquals", function() {
        return ke
    }), n.d(s, "equals", function() {
        return Ue
    }), n.d(s, "mul", function() {
        return Be
    }), n.d(s, "sub", function() {
        return Ne
    });
    var c = {};
    n.r(c), n.d(c, "create", function() {
        return Ge
    }), n.d(c, "clone", function() {
        return He
    }), n.d(c, "length", function() {
        return Ve
    }), n.d(c, "fromValues", function() {
        return We
    }), n.d(c, "copy", function() {
        return Ye
    }), n.d(c, "set", function() {
        return Xe
    }), n.d(c, "add", function() {
        return qe
    }), n.d(c, "subtract", function() {
        return Ke
    }), n.d(c, "multiply", function() {
        return Ze
    }), n.d(c, "divide", function() {
        return Je
    }), n.d(c, "ceil", function() {
        return Qe
    }), n.d(c, "floor", function() {
        return $e
    }), n.d(c, "min", function() {
        return tn
    }), n.d(c, "max", function() {
        return en
    }), n.d(c, "round", function() {
        return nn
    }), n.d(c, "scale", function() {
        return rn
    }), n.d(c, "scaleAndAdd", function() {
        return on
    }), n.d(c, "distance", function() {
        return an
    }), n.d(c, "squaredDistance", function() {
        return sn
    }), n.d(c, "squaredLength", function() {
        return cn
    }), n.d(c, "negate", function() {
        return un
    }), n.d(c, "inverse", function() {
        return ln
    }), n.d(c, "normalize", function() {
        return hn
    }), n.d(c, "dot", function() {
        return fn
    }), n.d(c, "cross", function() {
        return dn
    }), n.d(c, "lerp", function() {
        return vn
    }), n.d(c, "hermite", function() {
        return pn
    }), n.d(c, "bezier", function() {
        return mn
    }), n.d(c, "random", function() {
        return gn
    }), n.d(c, "transformMat4", function() {
        return yn
    }), n.d(c, "transformMat3", function() {
        return xn
    }), n.d(c, "transformQuat", function() {
        return bn
    }), n.d(c, "rotateX", function() {
        return wn
    }), n.d(c, "rotateY", function() {
        return _n
    }), n.d(c, "rotateZ", function() {
        return Mn
    }), n.d(c, "angle", function() {
        return Sn
    }), n.d(c, "str", function() {
        return En
    }), n.d(c, "exactEquals", function() {
        return Tn
    }), n.d(c, "equals", function() {
        return Pn
    }), n.d(c, "sub", function() {
        return Ln
    }), n.d(c, "mul", function() {
        return An
    }), n.d(c, "div", function() {
        return zn
    }), n.d(c, "dist", function() {
        return Cn
    }), n.d(c, "sqrDist", function() {
        return Rn
    }), n.d(c, "len", function() {
        return In
    }), n.d(c, "sqrLen", function() {
        return Dn
    }), n.d(c, "forEach", function() {
        return On
    });
    var u = {};
    n.r(u), n.d(u, "create", function() {
        return Fn
    }), n.d(u, "clone", function() {
        return jn
    }), n.d(u, "fromValues", function() {
        return kn
    }), n.d(u, "copy", function() {
        return Un
    }), n.d(u, "set", function() {
        return Bn
    }), n.d(u, "add", function() {
        return Nn
    }), n.d(u, "subtract", function() {
        return Gn
    }), n.d(u, "multiply", function() {
        return Hn
    }), n.d(u, "divide", function() {
        return Vn
    }), n.d(u, "ceil", function() {
        return Wn
    }), n.d(u, "floor", function() {
        return Yn
    }), n.d(u, "min", function() {
        return Xn
    }), n.d(u, "max", function() {
        return qn
    }), n.d(u, "round", function() {
        return Kn
    }), n.d(u, "scale", function() {
        return Zn
    }), n.d(u, "scaleAndAdd", function() {
        return Jn
    }), n.d(u, "distance", function() {
        return Qn
    }), n.d(u, "squaredDistance", function() {
        return $n
    }), n.d(u, "length", function() {
        return tr
    }), n.d(u, "squaredLength", function() {
        return er
    }), n.d(u, "negate", function() {
        return nr
    }), n.d(u, "inverse", function() {
        return rr
    }), n.d(u, "normalize", function() {
        return ir
    }), n.d(u, "dot", function() {
        return or
    }), n.d(u, "lerp", function() {
        return ar
    }), n.d(u, "random", function() {
        return sr
    }), n.d(u, "transformMat4", function() {
        return cr
    }), n.d(u, "transformQuat", function() {
        return ur
    }), n.d(u, "str", function() {
        return lr
    }), n.d(u, "exactEquals", function() {
        return hr
    }), n.d(u, "equals", function() {
        return fr
    }), n.d(u, "sub", function() {
        return dr
    }), n.d(u, "mul", function() {
        return vr
    }), n.d(u, "div", function() {
        return pr
    }), n.d(u, "dist", function() {
        return mr
    }), n.d(u, "sqrDist", function() {
        return gr
    }), n.d(u, "len", function() {
        return yr
    }), n.d(u, "sqrLen", function() {
        return xr
    }), n.d(u, "forEach", function() {
        return br
    });
    var l = {};
    n.r(l), n.d(l, "create", function() {
        return wr
    }), n.d(l, "identity", function() {
        return _r
    }), n.d(l, "setAxisAngle", function() {
        return Mr
    }), n.d(l, "getAxisAngle", function() {
        return Sr
    }), n.d(l, "multiply", function() {
        return Er
    }), n.d(l, "rotateX", function() {
        return Tr
    }), n.d(l, "rotateY", function() {
        return Pr
    }), n.d(l, "rotateZ", function() {
        return Lr
    }), n.d(l, "calculateW", function() {
        return Ar
    }), n.d(l, "slerp", function() {
        return zr
    }), n.d(l, "random", function() {
        return Cr
    }), n.d(l, "invert", function() {
        return Rr
    }), n.d(l, "conjugate", function() {
        return Ir
    }), n.d(l, "fromMat3", function() {
        return Dr
    }), n.d(l, "fromEuler", function() {
        return Or
    }), n.d(l, "str", function() {
        return Fr
    }), n.d(l, "clone", function() {
        return jr
    }), n.d(l, "fromValues", function() {
        return kr
    }), n.d(l, "copy", function() {
        return Ur
    }), n.d(l, "set", function() {
        return Br
    }), n.d(l, "add", function() {
        return Nr
    }), n.d(l, "mul", function() {
        return Gr
    }), n.d(l, "scale", function() {
        return Hr
    }), n.d(l, "dot", function() {
        return Vr
    }), n.d(l, "lerp", function() {
        return Wr
    }), n.d(l, "length", function() {
        return Yr
    }), n.d(l, "len", function() {
        return Xr
    }), n.d(l, "squaredLength", function() {
        return qr
    }), n.d(l, "sqrLen", function() {
        return Kr
    }), n.d(l, "normalize", function() {
        return Zr
    }), n.d(l, "exactEquals", function() {
        return Jr
    }), n.d(l, "equals", function() {
        return Qr
    }), n.d(l, "rotationTo", function() {
        return $r
    }), n.d(l, "sqlerp", function() {
        return ti
    }), n.d(l, "setAxes", function() {
        return ei
    });
    var h = {};
    n.r(h), n.d(h, "create", function() {
        return ni
    }), n.d(h, "clone", function() {
        return ri
    }), n.d(h, "fromValues", function() {
        return ii
    }), n.d(h, "fromRotationTranslationValues", function() {
        return oi
    }), n.d(h, "fromRotationTranslation", function() {
        return ai
    }), n.d(h, "fromTranslation", function() {
        return si
    }), n.d(h, "fromRotation", function() {
        return ci
    }), n.d(h, "fromMat4", function() {
        return ui
    }), n.d(h, "copy", function() {
        return li
    }), n.d(h, "identity", function() {
        return hi
    }), n.d(h, "set", function() {
        return fi
    }), n.d(h, "getReal", function() {
        return di
    }), n.d(h, "getDual", function() {
        return vi
    }), n.d(h, "setReal", function() {
        return pi
    }), n.d(h, "setDual", function() {
        return mi
    }), n.d(h, "getTranslation", function() {
        return gi
    }), n.d(h, "translate", function() {
        return yi
    }), n.d(h, "rotateX", function() {
        return xi
    }), n.d(h, "rotateY", function() {
        return bi
    }), n.d(h, "rotateZ", function() {
        return wi
    }), n.d(h, "rotateByQuatAppend", function() {
        return _i
    }), n.d(h, "rotateByQuatPrepend", function() {
        return Mi
    }), n.d(h, "rotateAroundAxis", function() {
        return Si
    }), n.d(h, "add", function() {
        return Ei
    }), n.d(h, "multiply", function() {
        return Ti
    }), n.d(h, "mul", function() {
        return Pi
    }), n.d(h, "scale", function() {
        return Li
    }), n.d(h, "dot", function() {
        return Ai
    }), n.d(h, "lerp", function() {
        return zi
    }), n.d(h, "invert", function() {
        return Ci
    }), n.d(h, "conjugate", function() {
        return Ri
    }), n.d(h, "length", function() {
        return Ii
    }), n.d(h, "len", function() {
        return Di
    }), n.d(h, "squaredLength", function() {
        return Oi
    }), n.d(h, "sqrLen", function() {
        return Fi
    }), n.d(h, "normalize", function() {
        return ji
    }), n.d(h, "str", function() {
        return ki
    }), n.d(h, "exactEquals", function() {
        return Ui
    }), n.d(h, "equals", function() {
        return Bi
    });
    var f = {};
    n.r(f), n.d(f, "create", function() {
        return Ni
    }), n.d(f, "clone", function() {
        return Gi
    }), n.d(f, "fromValues", function() {
        return Hi
    }), n.d(f, "copy", function() {
        return Vi
    }), n.d(f, "set", function() {
        return Wi
    }), n.d(f, "add", function() {
        return Yi
    }), n.d(f, "subtract", function() {
        return Xi
    }), n.d(f, "multiply", function() {
        return qi
    }), n.d(f, "divide", function() {
        return Ki
    }), n.d(f, "ceil", function() {
        return Zi
    }), n.d(f, "floor", function() {
        return Ji
    }), n.d(f, "min", function() {
        return Qi
    }), n.d(f, "max", function() {
        return $i
    }), n.d(f, "round", function() {
        return to
    }), n.d(f, "scale", function() {
        return eo
    }), n.d(f, "scaleAndAdd", function() {
        return no
    }), n.d(f, "distance", function() {
        return ro
    }), n.d(f, "squaredDistance", function() {
        return io
    }), n.d(f, "length", function() {
        return oo
    }), n.d(f, "squaredLength", function() {
        return ao
    }), n.d(f, "negate", function() {
        return so
    }), n.d(f, "inverse", function() {
        return co
    }), n.d(f, "normalize", function() {
        return uo
    }), n.d(f, "dot", function() {
        return lo
    }), n.d(f, "cross", function() {
        return ho
    }), n.d(f, "lerp", function() {
        return fo
    }), n.d(f, "random", function() {
        return vo
    }), n.d(f, "transformMat2", function() {
        return po
    }), n.d(f, "transformMat2d", function() {
        return mo
    }), n.d(f, "transformMat3", function() {
        return go
    }), n.d(f, "transformMat4", function() {
        return yo
    }), n.d(f, "rotate", function() {
        return xo
    }), n.d(f, "angle", function() {
        return bo
    }), n.d(f, "str", function() {
        return wo
    }), n.d(f, "exactEquals", function() {
        return _o
    }), n.d(f, "equals", function() {
        return Mo
    }), n.d(f, "len", function() {
        return So
    }), n.d(f, "sub", function() {
        return Eo
    }), n.d(f, "mul", function() {
        return To
    }), n.d(f, "div", function() {
        return Po
    }), n.d(f, "dist", function() {
        return Lo
    }), n.d(f, "sqrDist", function() {
        return Ao
    }), n.d(f, "sqrLen", function() {
        return zo
    }), n.d(f, "forEach", function() {
        return Co
    });
    var d = 1e-6,
        v = "undefined" != typeof Float32Array ? Float32Array : Array,
        p = Math.random;

    function m(t) {
        v = t
    }
    var g = Math.PI / 180;

    function y(t) {
        return t * g
    }

    function x(t, e) {
        return Math.abs(t - e) <= d * Math.max(1, Math.abs(t), Math.abs(e))
    }

    function b() {
        var t = new v(4);
        return v != Float32Array && (t[1] = 0, t[2] = 0), t[0] = 1, t[3] = 1, t
    }

    function w(t) {
        var e = new v(4);
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e
    }

    function _(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t
    }

    function M(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t
    }

    function S(t, e, n, r) {
        var i = new v(4);
        return i[0] = t, i[1] = e, i[2] = n, i[3] = r, i
    }

    function E(t, e, n, r, i) {
        return t[0] = e, t[1] = n, t[2] = r, t[3] = i, t
    }

    function T(t, e) {
        if (t === e) {
            var n = e[1];
            t[1] = e[2], t[2] = n
        } else t[0] = e[0], t[1] = e[2], t[2] = e[1], t[3] = e[3];
        return t
    }

    function P(t, e) {
        var n = e[0],
            r = e[1],
            i = e[2],
            o = e[3],
            a = n * o - i * r;
        return a ? (a = 1 / a, t[0] = o * a, t[1] = -r * a, t[2] = -i * a, t[3] = n * a, t) : null
    }

    function L(t, e) {
        var n = e[0];
        return t[0] = e[3], t[1] = -e[1], t[2] = -e[2], t[3] = n, t
    }

    function A(t) {
        return t[0] * t[3] - t[2] * t[1]
    }

    function z(t, e, n) {
        var r = e[0],
            i = e[1],
            o = e[2],
            a = e[3],
            s = n[0],
            c = n[1],
            u = n[2],
            l = n[3];
        return t[0] = r * s + o * c, t[1] = i * s + a * c, t[2] = r * u + o * l, t[3] = i * u + a * l, t
    }

    function C(t, e, n) {
        var r = e[0],
            i = e[1],
            o = e[2],
            a = e[3],
            s = Math.sin(n),
            c = Math.cos(n);
        return t[0] = r * c + o * s, t[1] = i * c + a * s, t[2] = r * -s + o * c, t[3] = i * -s + a * c, t
    }

    function R(t, e, n) {
        var r = e[0],
            i = e[1],
            o = e[2],
            a = e[3],
            s = n[0],
            c = n[1];
        return t[0] = r * s, t[1] = i * s, t[2] = o * c, t[3] = a * c, t
    }

    function I(t, e) {
        var n = Math.sin(e),
            r = Math.cos(e);
        return t[0] = r, t[1] = n, t[2] = -n, t[3] = r, t
    }

    function D(t, e) {
        return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = e[1], t
    }

    function O(t) {
        return "mat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
    }

    function F(t) {
        return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2))
    }

    function j(t, e, n, r) {
        return t[2] = r[2] / r[0], n[0] = r[0], n[1] = r[1], n[3] = r[3] - t[2] * n[1], [t, e, n]
    }

    function k(t, e, n) {
        return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t[3] = e[3] + n[3], t
    }

    function U(t, e, n) {
        return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t[3] = e[3] - n[3], t
    }

    function B(t, e) {
        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3]
    }

    function N(t, e) {
        var n = t[0],
            r = t[1],
            i = t[2],
            o = t[3],
            a = e[0],
            s = e[1],
            c = e[2],
            u = e[3];
        return Math.abs(n - a) <= d * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(r - s) <= d * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(i - c) <= d * Math.max(1, Math.abs(i), Math.abs(c)) && Math.abs(o - u) <= d * Math.max(1, Math.abs(o), Math.abs(u))
    }

    function G(t, e, n) {
        return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t
    }

    function H(t, e, n, r) {
        return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t[2] = e[2] + n[2] * r, t[3] = e[3] + n[3] * r, t
    }
    var V = z,
        W = U;

    function Y() {
        var t = new v(6);
        return v != Float32Array && (t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0), t[0] = 1, t[3] = 1, t
    }

    function X(t) {
        var e = new v(6);
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e
    }

    function q(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t
    }

    function K(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t
    }

    function Z(t, e, n, r, i, o) {
        var a = new v(6);
        return a[0] = t, a[1] = e, a[2] = n, a[3] = r, a[4] = i, a[5] = o, a
    }

    function J(t, e, n, r, i, o, a) {
        return t[0] = e, t[1] = n, t[2] = r, t[3] = i, t[4] = o, t[5] = a, t
    }

    function Q(t, e) {
        var n = e[0],
            r = e[1],
            i = e[2],
            o = e[3],
            a = e[4],
            s = e[5],
            c = n * o - r * i;
        return c ? (c = 1 / c, t[0] = o * c, t[1] = -r * c, t[2] = -i * c, t[3] = n * c, t[4] = (i * s - o * a) * c, t[5] = (r * a - n * s) * c, t) : null
    }

    function $(t) {
        return t[0] * t[3] - t[1] * t[2]
    }

    function tt(t, e, n) {
        var r = e[0],
            i = e[1],
            o = e[2],
            a = e[3],
            s = e[4],
            c = e[5],
            u = n[0],
            l = n[1],
            h = n[2],
            f = n[3],
            d = n[4],
            v = n[5];
        return t[0] = r * u + o * l, t[1] = i * u + a * l, t[2] = r * h + o * f, t[3] = i * h + a * f, t[4] = r * d + o * v + s, t[5] = i * d + a * v + c, t
    }

    function et(t, e, n) {
        var r = e[0],
            i = e[1],
            o = e[2],
            a = e[3],
            s = e[4],
            c = e[5],
            u = Math.sin(n),
            l = Math.cos(n);
        return t[0] = r * l + o * u, t[1] = i * l + a * u, t[2] = r * -u + o * l, t[3] = i * -u + a * l, t[4] = s, t[5] = c, t
    }

    function nt(t, e, n) {
        var r = e[0],
            i = e[1],
            o = e[2],
            a = e[3],
            s = e[4],
            c = e[5],
            u = n[0],
            l = n[1];
        return t[0] = r * u, t[1] = i * u, t[2] = o * l, t[3] = a * l, t[4] = s, t[5] = c, t
    }

    function rt(t, e, n) {
        var r = e[0],
            i = e[1],
            o = e[2],
            a = e[3],
            s = e[4],
            c = e[5],
            u = n[0],
            l = n[1];
        return t[0] = r, t[1] = i, t[2] = o, t[3] = a, t[4] = r * u + o * l + s, t[5] = i * u + a * l + c, t
    }

    function it(t, e) {
        var n = Math.sin(e),
            r = Math.cos(e);
        return t[0] = r, t[1] = n, t[2] = -n, t[3] = r, t[4] = 0, t[5] = 0, t
    }

    function ot(t, e) {
        return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = e[1], t[4] = 0, t[5] = 0, t
    }

    function at(t, e) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = e[0], t[5] = e[1], t
    }

    function st(t) {
        return "mat2d(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ")"
    }

    function ct(t) {
        return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2) + Math.pow(t[4], 2) + Math.pow(t[5], 2) + 1)
    }

    function ut(t, e, n) {
        return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t[3] = e[3] + n[3], t[4] = e[4] + n[4], t[5] = e[5] + n[5], t
    }

    function lt(t, e, n) {
        return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t[3] = e[3] - n[3], t[4] = e[4] - n[4], t[5] = e[5] - n[5], t
    }

    function ht(t, e, n) {
        return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * n, t[5] = e[5] * n, t
    }

    function ft(t, e, n, r) {
        return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t[2] = e[2] + n[2] * r, t[3] = e[3] + n[3] * r, t[4] = e[4] + n[4] * r, t[5] = e[5] + n[5] * r, t
    }

    function dt(t, e) {
        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5]
    }

    function vt(t, e) {
        var n = t[0],
            r = t[1],
            i = t[2],
            o = t[3],
            a = t[4],
            s = t[5],
            c = e[0],
            u = e[1],
            l = e[2],
            h = e[3],
            f = e[4],
            v = e[5];
        return Math.abs(n - c) <= d * Math.max(1, Math.abs(n), Math.abs(c)) && Math.abs(r - u) <= d * Math.max(1, Math.abs(r), Math.abs(u)) && Math.abs(i - l) <= d * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(o - h) <= d * Math.max(1, Math.abs(o), Math.abs(h)) && Math.abs(a - f) <= d * Math.max(1, Math.abs(a), Math.abs(f)) && Math.abs(s - v) <= d * Math.max(1, Math.abs(s), Math.abs(v))
    }
    var pt = tt,
        mt = lt;

    function gt() {
        var t = new v(9);
        return v != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t
    }

    function yt(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[4], t[4] = e[5], t[5] = e[6], t[6] = e[8], t[7] = e[9], t[8] = e[10], t
    }

    function xt(t) {
        var e = new v(9);
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e
    }

    function bt(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t
    }

    function wt(t, e, n, r, i, o, a, s, c) {
        var u = new v(9);
        return u[0] = t, u[1] = e, u[2] = n, u[3] = r, u[4] = i, u[5] = o, u[6] = a, u[7] = s, u[8] = c, u
    }

    function _t(t, e, n, r, i, o, a, s, c, u) {
        return t[0] = e, t[1] = n, t[2] = r, t[3] = i, t[4] = o, t[5] = a, t[6] = s, t[7] = c, t[8] = u, t
    }

    function Mt(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t
    }

    function St(t, e) {
        if (t === e) {
            var n = e[1],
                r = e[2],
                i = e[5];
            t[1] = e[3], t[2] = e[6], t[3] = n, t[5] = e[7], t[6] = r, t[7] = i
        } else t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8];
        return t
    }

    function Et(t, e) {
        var n = e[0],
            r = e[1],
            i = e[2],
            o = e[3],
            a = e[4],
            s = e[5],
            c = e[6],
            u = e[7],
            l = e[8],
            h = l * a - s * u,
            f = -l * o + s * c,
            d = u * o - a * c,
            v = n * h + r * f + i * d;
        return v ? (v = 1 / v, t[0] = h * v, t[1] = (-l * r + i * u) * v, t[2] = (s * r - i * a) * v, t[3] = f * v, t[4] = (l * n - i * c) * v, t[5] = (-s * n + i * o) * v, t[6] = d * v, t[7] = (-u * n + r * c) * v, t[8] = (a * n - r * o) * v, t) : null
    }

    function Tt(t, e) {
        var n = e[0],
            r = e[1],
            i = e[2],
            o = e[3],
            a = e[4],
            s = e[5],
            c = e[6],
            u = e[7],
            l = e[8];
        return t[0] = a * l - s * u, t[1] = i * u - r * l, t[2] = r * s - i * a, t[3] = s * c - o * l, t[4] = n * l - i * c, t[5] = i * o - n * s, t[6] = o * u - a * c, t[7] = r * c - n * u, t[8] = n * a - r * o, t
    }

    function Pt(t) {
        var e = t[0],
            n = t[1],
            r = t[2],
            i = t[3],
            o = t[4],
            a = t[5],
            s = t[6],
            c = t[7],
            u = t[8];
        return e * (u * o - a * c) + n * (-u * i + a * s) + r * (c * i - o * s)
    }

    function Lt(t, e, n) {
        var r = e[0],
            i = e[1],
            o = e[2],
            a = e[3],
            s = e[4],
            c = e[5],
            u = e[6],
            l = e[7],
            h = e[8],
            f = n[0],
            d = n[1],
            v = n[2],
            p = n[3],
            m = n[4],
            g = n[5],
            y = n[6],
            x = n[7],
            b = n[8];
        return t[0] = f * r + d * a + v * u, t[1] = f * i + d * s + v * l, t[2] = f * o + d * c + v * h, t[3] = p * r + m * a + g * u, t[4] = p * i + m * s + g * l, t[5] = p * o + m * c + g * h, t[6] = y * r + x * a + b * u, t[7] = y * i + x * s + b * l, t[8] = y * o + x * c + b * h, t
    }

    function At(t, e, n) {
        var r = e[0],
            i = e[1],
            o = e[2],
            a = e[3],
            s = e[4],
            c = e[5],
            u = e[6],
            l = e[7],
            h = e[8],
            f = n[0],
            d = n[1];
        return t[0] = r, t[1] = i, t[2] = o, t[3] = a, t[4] = s, t[5] = c, t[6] = f * r + d * a + u, t[7] = f * i + d * s + l, t[8] = f * o + d * c + h, t
    }

    function zt(t, e, n) {
        var r = e[0],
            i = e[1],
            o = e[2],
            a = e[3],
            s = e[4],
            c = e[5],
            u = e[6],
            l = e[7],
            h = e[8],
            f = Math.sin(n),
            d = Math.cos(n);
        return t[0] = d * r + f * a, t[1] = d * i + f * s, t[2] = d * o + f * c, t[3] = d * a - f * r, t[4] = d * s - f * i, t[5] = d * c - f * o, t[6] = u, t[7] = l, t[8] = h, t
    }

    function Ct(t, e, n) {
        var r = n[0],
            i = n[1];
        return t[0] = r * e[0], t[1] = r * e[1], t[2] = r * e[2], t[3] = i * e[3], t[4] = i * e[4], t[5] = i * e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t
    }

    function Rt(t, e) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = e[0], t[7] = e[1], t[8] = 1, t
    }

    function It(t, e) {
        var n = Math.sin(e),
            r = Math.cos(e);
        return t[0] = r, t[1] = n, t[2] = 0, t[3] = -n, t[4] = r, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t
    }

    function Dt(t, e) {
        return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = e[1], t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t
    }

    function Ot(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = 0, t[3] = e[2], t[4] = e[3], t[5] = 0, t[6] = e[4], t[7] = e[5], t[8] = 1, t
    }

    function Ft(t, e) {
        var n = e[0],
            r = e[1],
            i = e[2],
            o = e[3],
            a = n + n,
            s = r + r,
            c = i + i,
            u = n * a,
            l = r * a,
            h = r * s,
            f = i * a,
            d = i * s,
            v = i * c,
            p = o * a,
            m = o * s,
            g = o * c;
        return t[0] = 1 - h - v, t[3] = l - g, t[6] = f + m, t[1] = l + g, t[4] = 1 - u - v, t[7] = d - p, t[2] = f - m, t[5] = d + p, t[8] = 1 - u - h, t
    }

    function jt(t, e) {
        var n = e[0],
            r = e[1],
            i = e[2],
            o = e[3],
            a = e[4],
            s = e[5],
            c = e[6],
            u = e[7],
            l = e[8],
            h = e[9],
            f = e[10],
            d = e[11],
            v = e[12],
            p = e[13],
            m = e[14],
            g = e[15],
            y = n * s - r * a,
            x = n * c - i * a,
            b = n * u - o * a,
            w = r * c - i * s,
            _ = r * u - o * s,
            M = i * u - o * c,
            S = l * p - h * v,
            E = l * m - f * v,
            T = l * g - d * v,
            P = h * m - f * p,
            L = h * g - d * p,
            A = f * g - d * m,
            z = y * A - x * L + b * P + w * T - _ * E + M * S;
        return z ? (z = 1 / z, t[0] = (s * A - c * L + u * P) * z, t[1] = (c * T - a * A - u * E) * z, t[2] = (a * L - s * T + u * S) * z, t[3] = (i * L - r * A - o * P) * z, t[4] = (n * A - i * T + o * E) * z, t[5] = (r * T - n * L - o * S) * z, t[6] = (p * M - m * _ + g * w) * z, t[7] = (m * b - v * M - g * x) * z, t[8] = (v * _ - p * b + g * y) * z, t) : null
    }

    function kt(t, e, n) {
        return t[0] = 2 / e, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = -2 / n, t[5] = 0, t[6] = -1, t[7] = 1, t[8] = 1, t
    }

    function Ut(t) {
        return "mat3(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ")"
    }

    function Bt(t) {
        return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2) + Math.pow(t[4], 2) + Math.pow(t[5], 2) + Math.pow(t[6], 2) + Math.pow(t[7], 2) + Math.pow(t[8], 2))
    }

    function Nt(t, e, n) {
        return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t[3] = e[3] + n[3], t[4] = e[4] + n[4], t[5] = e[5] + n[5], t[6] = e[6] + n[6], t[7] = e[7] + n[7], t[8] = e[8] + n[8], t
    }

    function Gt(t, e, n) {
        return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t[3] = e[3] - n[3], t[4] = e[4] - n[4], t[5] = e[5] - n[5], t[6] = e[6] - n[6], t[7] = e[7] - n[7], t[8] = e[8] - n[8], t
    }

    function Ht(t, e, n) {
        return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * n, t[5] = e[5] * n, t[6] = e[6] * n, t[7] = e[7] * n, t[8] = e[8] * n, t
    }

    function Vt(t, e, n, r) {
        return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t[2] = e[2] + n[2] * r, t[3] = e[3] + n[3] * r, t[4] = e[4] + n[4] * r, t[5] = e[5] + n[5] * r, t[6] = e[6] + n[6] * r, t[7] = e[7] + n[7] * r, t[8] = e[8] + n[8] * r, t
    }

    function Wt(t, e) {
        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8]
    }

    function Yt(t, e) {
        var n = t[0],
            r = t[1],
            i = t[2],
            o = t[3],
            a = t[4],
            s = t[5],
            c = t[6],
            u = t[7],
            l = t[8],
            h = e[0],
            f = e[1],
            v = e[2],
            p = e[3],
            m = e[4],
            g = e[5],
            y = e[6],
            x = e[7],
            b = e[8];
        return Math.abs(n - h) <= d * Math.max(1, Math.abs(n), Math.abs(h)) && Math.abs(r - f) <= d * Math.max(1, Math.abs(r), Math.abs(f)) && Math.abs(i - v) <= d * Math.max(1, Math.abs(i), Math.abs(v)) && Math.abs(o - p) <= d * Math.max(1, Math.abs(o), Math.abs(p)) && Math.abs(a - m) <= d * Math.max(1, Math.abs(a), Math.abs(m)) && Math.abs(s - g) <= d * Math.max(1, Math.abs(s), Math.abs(g)) && Math.abs(c - y) <= d * Math.max(1, Math.abs(c), Math.abs(y)) && Math.abs(u - x) <= d * Math.max(1, Math.abs(u), Math.abs(x)) && Math.abs(l - b) <= d * Math.max(1, Math.abs(l), Math.abs(b))
    }
    var Xt = Lt,
        qt = Gt;

    function Kt() {
        var t = new v(16);
        return v != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t
    }

    function Zt(t) {
        var e = new v(16);
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e
    }

    function Jt(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t
    }

    function Qt(t, e, n, r, i, o, a, s, c, u, l, h, f, d, p, m) {
        var g = new v(16);
        return g[0] = t, g[1] = e, g[2] = n, g[3] = r, g[4] = i, g[5] = o, g[6] = a, g[7] = s, g[8] = c, g[9] = u, g[10] = l, g[11] = h, g[12] = f, g[13] = d, g[14] = p, g[15] = m, g
    }

    function $t(t, e, n, r, i, o, a, s, c, u, l, h, f, d, v, p, m) {
        return t[0] = e, t[1] = n, t[2] = r, t[3] = i, t[4] = o, t[5] = a, t[6] = s, t[7] = c, t[8] = u, t[9] = l, t[10] = h, t[11] = f, t[12] = d, t[13] = v, t[14] = p, t[15] = m, t
    }

    function te(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
    }

    function ee(t, e) {
        if (t === e) {
            var n = e[1],
                r = e[2],
                i = e[3],
                o = e[6],
                a = e[7],
                s = e[11];
            t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = n, t[6] = e[9], t[7] = e[13], t[8] = r, t[9] = o, t[11] = e[14], t[12] = i, t[13] = a, t[14] = s
        } else t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[10] = e[10], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11], t[15] = e[15];
        return t
    }

    function ne(t, e) {
        var n = e[0],
            r = e[1],
            i = e[2],
            o = e[3],
            a = e[4],
            s = e[5],
            c = e[6],
            u = e[7],
            l = e[8],
            h = e[9],
            f = e[10],
            d = e[11],
            v = e[12],
            p = e[13],
            m = e[14],
            g = e[15],
            y = n * s - r * a,
            x = n * c - i * a,
            b = n * u - o * a,
            w = r * c - i * s,
            _ = r * u - o * s,
            M = i * u - o * c,
            S = l * p - h * v,
            E = l * m - f * v,
            T = l * g - d * v,
            P = h * m - f * p,
            L = h * g - d * p,
            A = f * g - d * m,
            z = y * A - x * L + b * P + w * T - _ * E + M * S;
        return z ? (z = 1 / z, t[0] = (s * A - c * L + u * P) * z, t[1] = (i * L - r * A - o * P) * z, t[2] = (p * M - m * _ + g * w) * z, t[3] = (f * _ - h * M - d * w) * z, t[4] = (c * T - a * A - u * E) * z, t[5] = (n * A - i * T + o * E) * z, t[6] = (m * b - v * M - g * x) * z, t[7] = (l * M - f * b + d * x) * z, t[8] = (a * L - s * T + u * S) * z, t[9] = (r * T - n * L - o * S) * z, t[10] = (v * _ - p * b + g * y) * z, t[11] = (h * b - l * _ - d * y) * z, t[12] = (s * E - a * P - c * S) * z, t[13] = (n * P - r * E + i * S) * z, t[14] = (p * x - v * w - m * y) * z, t[15] = (l * w - h * x + f * y) * z, t) : null
    }

    function re(t, e) {
        var n = e[0],
            r = e[1],
            i = e[2],
            o = e[3],
            a = e[4],
            s = e[5],
            c = e[6],
            u = e[7],
            l = e[8],
            h = e[9],
            f = e[10],
            d = e[11],
            v = e[12],
            p = e[13],
            m = e[14],
            g = e[15];
        return t[0] = s * (f * g - d * m) - h * (c * g - u * m) + p * (c * d - u * f), t[1] = -(r * (f * g - d * m) - h * (i * g - o * m) + p * (i * d - o * f)), t[2] = r * (c * g - u * m) - s * (i * g - o * m) + p * (i * u - o * c), t[3] = -(r * (c * d - u * f) - s * (i * d - o * f) + h * (i * u - o * c)), t[4] = -(a * (f * g - d * m) - l * (c * g - u * m) + v * (c * d - u * f)), t[5] = n * (f * g - d * m) - l * (i * g - o * m) + v * (i * d - o * f), t[6] = -(n * (c * g - u * m) - a * (i * g - o * m) + v * (i * u - o * c)), t[7] = n * (c * d - u * f) - a * (i * d - o * f) + l * (i * u - o * c), t[8] = a * (h * g - d * p) - l * (s * g - u * p) + v * (s * d - u * h), t[9] = -(n * (h * g - d * p) - l * (r * g - o * p) + v * (r * d - o * h)), t[10] = n * (s * g - u * p) - a * (r * g - o * p) + v * (r * u - o * s), t[11] = -(n * (s * d - u * h) - a * (r * d - o * h) + l * (r * u - o * s)), t[12] = -(a * (h * m - f * p) - l * (s * m - c * p) + v * (s * f - c * h)), t[13] = n * (h * m - f * p) - l * (r * m - i * p) + v * (r * f - i * h), t[14] = -(n * (s * m - c * p) - a * (r * m - i * p) + v * (r * c - i * s)), t[15] = n * (s * f - c * h) - a * (r * f - i * h) + l * (r * c - i * s), t
    }

    function ie(t) {
        var e = t[0],
            n = t[1],
            r = t[2],
            i = t[3],
            o = t[4],
            a = t[5],
            s = t[6],
            c = t[7],
            u = t[8],
            l = t[9],
            h = t[10],
            f = t[11],
            d = t[12],
            v = t[13],
            p = t[14],
            m = t[15];
        return (e * a - n * o) * (h * m - f * p) - (e * s - r * o) * (l * m - f * v) + (e * c - i * o) * (l * p - h * v) + (n * s - r * a) * (u * m - f * d) - (n * c - i * a) * (u * p - h * d) + (r * c - i * s) * (u * v - l * d)
    }

    function oe(t, e, n) {
        var r = e[0],
            i = e[1],
            o = e[2],
            a = e[3],
            s = e[4],
            c = e[5],
            u = e[6],
            l = e[7],
            h = e[8],
            f = e[9],
            d = e[10],
            v = e[11],
            p = e[12],
            m = e[13],
            g = e[14],
            y = e[15],
            x = n[0],
            b = n[1],
            w = n[2],
            _ = n[3];
        return t[0] = x * r + b * s + w * h + _ * p, t[1] = x * i + b * c + w * f + _ * m, t[2] = x * o + b * u + w * d + _ * g, t[3] = x * a + b * l + w * v + _ * y, x = n[4], b = n[5], w = n[6], _ = n[7], t[4] = x * r + b * s + w * h + _ * p, t[5] = x * i + b * c + w * f + _ * m, t[6] = x * o + b * u + w * d + _ * g, t[7] = x * a + b * l + w * v + _ * y, x = n[8], b = n[9], w = n[10], _ = n[11], t[8] = x * r + b * s + w * h + _ * p, t[9] = x * i + b * c + w * f + _ * m, t[10] = x * o + b * u + w * d + _ * g, t[11] = x * a + b * l + w * v + _ * y, x = n[12], b = n[13], w = n[14], _ = n[15], t[12] = x * r + b * s + w * h + _ * p, t[13] = x * i + b * c + w * f + _ * m, t[14] = x * o + b * u + w * d + _ * g, t[15] = x * a + b * l + w * v + _ * y, t
    }

    function ae(t, e, n) {
        var r = n[0],
            i = n[1],
            o = n[2],
            a = void 0,
            s = void 0,
            c = void 0,
            u = void 0,
            l = void 0,
            h = void 0,
            f = void 0,
            d = void 0,
            v = void 0,
            p = void 0,
            m = void 0,
            g = void 0;
        return e === t ? (t[12] = e[0] * r + e[4] * i + e[8] * o + e[12], t[13] = e[1] * r + e[5] * i + e[9] * o + e[13], t[14] = e[2] * r + e[6] * i + e[10] * o + e[14], t[15] = e[3] * r + e[7] * i + e[11] * o + e[15]) : (a = e[0], s = e[1], c = e[2], u = e[3], l = e[4], h = e[5], f = e[6], d = e[7], v = e[8], p = e[9], m = e[10], g = e[11], t[0] = a, t[1] = s, t[2] = c, t[3] = u, t[4] = l, t[5] = h, t[6] = f, t[7] = d, t[8] = v, t[9] = p, t[10] = m, t[11] = g, t[12] = a * r + l * i + v * o + e[12], t[13] = s * r + h * i + p * o + e[13], t[14] = c * r + f * i + m * o + e[14], t[15] = u * r + d * i + g * o + e[15]), t
    }

    function se(t, e, n) {
        var r = n[0],
            i = n[1],
            o = n[2];
        return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * o, t[9] = e[9] * o, t[10] = e[10] * o, t[11] = e[11] * o, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t
    }

    function ce(t, e, n, r) {
        var i, o, a, s, c, u, l, h, f, v, p, m, g, y, x, b, w, _, M, S, E, T, P, L, A = r[0],
            z = r[1],
            C = r[2],
            R = Math.sqrt(A * A + z * z + C * C);
        return R < d ? null : (A *= R = 1 / R, z *= R, C *= R, i = Math.sin(n), a = 1 - (o = Math.cos(n)), s = e[0], c = e[1], u = e[2], l = e[3], h = e[4], f = e[5], v = e[6], p = e[7], m = e[8], g = e[9], y = e[10], x = e[11], b = A * A * a + o, w = z * A * a + C * i, _ = C * A * a - z * i, M = A * z * a - C * i, S = z * z * a + o, E = C * z * a + A * i, T = A * C * a + z * i, P = z * C * a - A * i, L = C * C * a + o, t[0] = s * b + h * w + m * _, t[1] = c * b + f * w + g * _, t[2] = u * b + v * w + y * _, t[3] = l * b + p * w + x * _, t[4] = s * M + h * S + m * E, t[5] = c * M + f * S + g * E, t[6] = u * M + v * S + y * E, t[7] = l * M + p * S + x * E, t[8] = s * T + h * P + m * L, t[9] = c * T + f * P + g * L, t[10] = u * T + v * P + y * L, t[11] = l * T + p * P + x * L, e !== t && (t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t)
    }

    function ue(t, e, n) {
        var r = Math.sin(n),
            i = Math.cos(n),
            o = e[4],
            a = e[5],
            s = e[6],
            c = e[7],
            u = e[8],
            l = e[9],
            h = e[10],
            f = e[11];
        return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = o * i + u * r, t[5] = a * i + l * r, t[6] = s * i + h * r, t[7] = c * i + f * r, t[8] = u * i - o * r, t[9] = l * i - a * r, t[10] = h * i - s * r, t[11] = f * i - c * r, t
    }

    function le(t, e, n) {
        var r = Math.sin(n),
            i = Math.cos(n),
            o = e[0],
            a = e[1],
            s = e[2],
            c = e[3],
            u = e[8],
            l = e[9],
            h = e[10],
            f = e[11];
        return e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = o * i - u * r, t[1] = a * i - l * r, t[2] = s * i - h * r, t[3] = c * i - f * r, t[8] = o * r + u * i, t[9] = a * r + l * i, t[10] = s * r + h * i, t[11] = c * r + f * i, t
    }

    function he(t, e, n) {
        var r = Math.sin(n),
            i = Math.cos(n),
            o = e[0],
            a = e[1],
            s = e[2],
            c = e[3],
            u = e[4],
            l = e[5],
            h = e[6],
            f = e[7];
        return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = o * i + u * r, t[1] = a * i + l * r, t[2] = s * i + h * r, t[3] = c * i + f * r, t[4] = u * i - o * r, t[5] = l * i - a * r, t[6] = h * i - s * r, t[7] = f * i - c * r, t
    }

    function fe(t, e) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = e[0], t[13] = e[1], t[14] = e[2], t[15] = 1, t
    }

    function de(t, e) {
        return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
    }

    function ve(t, e, n) {
        var r, i, o, a = n[0],
            s = n[1],
            c = n[2],
            u = Math.sqrt(a * a + s * s + c * c);
        return u < d ? null : (a *= u = 1 / u, s *= u, c *= u, r = Math.sin(e), o = 1 - (i = Math.cos(e)), t[0] = a * a * o + i, t[1] = s * a * o + c * r, t[2] = c * a * o - s * r, t[3] = 0, t[4] = a * s * o - c * r, t[5] = s * s * o + i, t[6] = c * s * o + a * r, t[7] = 0, t[8] = a * c * o + s * r, t[9] = s * c * o - a * r, t[10] = c * c * o + i, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t)
    }

    function pe(t, e) {
        var n = Math.sin(e),
            r = Math.cos(e);
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = r, t[6] = n, t[7] = 0, t[8] = 0, t[9] = -n, t[10] = r, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
    }

    function me(t, e) {
        var n = Math.sin(e),
            r = Math.cos(e);
        return t[0] = r, t[1] = 0, t[2] = -n, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = n, t[9] = 0, t[10] = r, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
    }

    function ge(t, e) {
        var n = Math.sin(e),
            r = Math.cos(e);
        return t[0] = r, t[1] = n, t[2] = 0, t[3] = 0, t[4] = -n, t[5] = r, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
    }

    function ye(t, e, n) {
        var r = e[0],
            i = e[1],
            o = e[2],
            a = e[3],
            s = r + r,
            c = i + i,
            u = o + o,
            l = r * s,
            h = r * c,
            f = r * u,
            d = i * c,
            v = i * u,
            p = o * u,
            m = a * s,
            g = a * c,
            y = a * u;
        return t[0] = 1 - (d + p), t[1] = h + y, t[2] = f - g, t[3] = 0, t[4] = h - y, t[5] = 1 - (l + p), t[6] = v + m, t[7] = 0, t[8] = f + g, t[9] = v - m, t[10] = 1 - (l + d), t[11] = 0, t[12] = n[0], t[13] = n[1], t[14] = n[2], t[15] = 1, t
    }

    function xe(t, e) {
        var n = new v(3),
            r = -e[0],
            i = -e[1],
            o = -e[2],
            a = e[3],
            s = e[4],
            c = e[5],
            u = e[6],
            l = e[7],
            h = r * r + i * i + o * o + a * a;
        return h > 0 ? (n[0] = 2 * (s * a + l * r + c * o - u * i) / h, n[1] = 2 * (c * a + l * i + u * r - s * o) / h, n[2] = 2 * (u * a + l * o + s * i - c * r) / h) : (n[0] = 2 * (s * a + l * r + c * o - u * i), n[1] = 2 * (c * a + l * i + u * r - s * o), n[2] = 2 * (u * a + l * o + s * i - c * r)), ye(t, e, n), t
    }

    function be(t, e) {
        return t[0] = e[12], t[1] = e[13], t[2] = e[14], t
    }

    function we(t, e) {
        var n = e[0],
            r = e[1],
            i = e[2],
            o = e[4],
            a = e[5],
            s = e[6],
            c = e[8],
            u = e[9],
            l = e[10];
        return t[0] = Math.sqrt(n * n + r * r + i * i), t[1] = Math.sqrt(o * o + a * a + s * s), t[2] = Math.sqrt(c * c + u * u + l * l), t
    }

    function _e(t, e) {
        var n = e[0] + e[5] + e[10],
            r = 0;
        return n > 0 ? (r = 2 * Math.sqrt(n + 1), t[3] = .25 * r, t[0] = (e[6] - e[9]) / r, t[1] = (e[8] - e[2]) / r, t[2] = (e[1] - e[4]) / r) : e[0] > e[5] && e[0] > e[10] ? (r = 2 * Math.sqrt(1 + e[0] - e[5] - e[10]), t[3] = (e[6] - e[9]) / r, t[0] = .25 * r, t[1] = (e[1] + e[4]) / r, t[2] = (e[8] + e[2]) / r) : e[5] > e[10] ? (r = 2 * Math.sqrt(1 + e[5] - e[0] - e[10]), t[3] = (e[8] - e[2]) / r, t[0] = (e[1] + e[4]) / r, t[1] = .25 * r, t[2] = (e[6] + e[9]) / r) : (r = 2 * Math.sqrt(1 + e[10] - e[0] - e[5]), t[3] = (e[1] - e[4]) / r, t[0] = (e[8] + e[2]) / r, t[1] = (e[6] + e[9]) / r, t[2] = .25 * r), t
    }

    function Me(t, e, n, r) {
        var i = e[0],
            o = e[1],
            a = e[2],
            s = e[3],
            c = i + i,
            u = o + o,
            l = a + a,
            h = i * c,
            f = i * u,
            d = i * l,
            v = o * u,
            p = o * l,
            m = a * l,
            g = s * c,
            y = s * u,
            x = s * l,
            b = r[0],
            w = r[1],
            _ = r[2];
        return t[0] = (1 - (v + m)) * b, t[1] = (f + x) * b, t[2] = (d - y) * b, t[3] = 0, t[4] = (f - x) * w, t[5] = (1 - (h + m)) * w, t[6] = (p + g) * w, t[7] = 0, t[8] = (d + y) * _, t[9] = (p - g) * _, t[10] = (1 - (h + v)) * _, t[11] = 0, t[12] = n[0], t[13] = n[1], t[14] = n[2], t[15] = 1, t
    }

    function Se(t, e, n, r, i) {
        var o = e[0],
            a = e[1],
            s = e[2],
            c = e[3],
            u = o + o,
            l = a + a,
            h = s + s,
            f = o * u,
            d = o * l,
            v = o * h,
            p = a * l,
            m = a * h,
            g = s * h,
            y = c * u,
            x = c * l,
            b = c * h,
            w = r[0],
            _ = r[1],
            M = r[2],
            S = i[0],
            E = i[1],
            T = i[2],
            P = (1 - (p + g)) * w,
            L = (d + b) * w,
            A = (v - x) * w,
            z = (d - b) * _,
            C = (1 - (f + g)) * _,
            R = (m + y) * _,
            I = (v + x) * M,
            D = (m - y) * M,
            O = (1 - (f + p)) * M;
        return t[0] = P, t[1] = L, t[2] = A, t[3] = 0, t[4] = z, t[5] = C, t[6] = R, t[7] = 0, t[8] = I, t[9] = D, t[10] = O, t[11] = 0, t[12] = n[0] + S - (P * S + z * E + I * T), t[13] = n[1] + E - (L * S + C * E + D * T), t[14] = n[2] + T - (A * S + R * E + O * T), t[15] = 1, t
    }

    function Ee(t, e) {
        var n = e[0],
            r = e[1],
            i = e[2],
            o = e[3],
            a = n + n,
            s = r + r,
            c = i + i,
            u = n * a,
            l = r * a,
            h = r * s,
            f = i * a,
            d = i * s,
            v = i * c,
            p = o * a,
            m = o * s,
            g = o * c;
        return t[0] = 1 - h - v, t[1] = l + g, t[2] = f - m, t[3] = 0, t[4] = l - g, t[5] = 1 - u - v, t[6] = d + p, t[7] = 0, t[8] = f + m, t[9] = d - p, t[10] = 1 - u - h, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
    }

    function Te(t, e, n, r, i, o, a) {
        var s = 1 / (n - e),
            c = 1 / (i - r),
            u = 1 / (o - a);
        return t[0] = 2 * o * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 2 * o * c, t[6] = 0, t[7] = 0, t[8] = (n + e) * s, t[9] = (i + r) * c, t[10] = (a + o) * u, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = a * o * 2 * u, t[15] = 0, t
    }

    function Pe(t, e, n, r, i) {
        var o = 1 / Math.tan(e / 2),
            a = void 0;
        return t[0] = o / n, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = o, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != i && i !== 1 / 0 ? (a = 1 / (r - i), t[10] = (i + r) * a, t[14] = 2 * i * r * a) : (t[10] = -1, t[14] = -2 * r), t
    }

    function Le(t, e, n, r) {
        var i = Math.tan(e.upDegrees * Math.PI / 180),
            o = Math.tan(e.downDegrees * Math.PI / 180),
            a = Math.tan(e.leftDegrees * Math.PI / 180),
            s = Math.tan(e.rightDegrees * Math.PI / 180),
            c = 2 / (a + s),
            u = 2 / (i + o);
        return t[0] = c, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = u, t[6] = 0, t[7] = 0, t[8] = -(a - s) * c * .5, t[9] = (i - o) * u * .5, t[10] = r / (n - r), t[11] = -1, t[12] = 0, t[13] = 0, t[14] = r * n / (n - r), t[15] = 0, t
    }

    function Ae(t, e, n, r, i, o, a) {
        var s = 1 / (e - n),
            c = 1 / (r - i),
            u = 1 / (o - a);
        return t[0] = -2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * c, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * u, t[11] = 0, t[12] = (e + n) * s, t[13] = (i + r) * c, t[14] = (a + o) * u, t[15] = 1, t
    }

    function ze(t, e, n, r) {
        var i = void 0,
            o = void 0,
            a = void 0,
            s = void 0,
            c = void 0,
            u = void 0,
            l = void 0,
            h = void 0,
            f = void 0,
            v = void 0,
            p = e[0],
            m = e[1],
            g = e[2],
            y = r[0],
            x = r[1],
            b = r[2],
            w = n[0],
            _ = n[1],
            M = n[2];
        return Math.abs(p - w) < d && Math.abs(m - _) < d && Math.abs(g - M) < d ? te(t) : (l = p - w, h = m - _, f = g - M, i = x * (f *= v = 1 / Math.sqrt(l * l + h * h + f * f)) - b * (h *= v), o = b * (l *= v) - y * f, a = y * h - x * l, (v = Math.sqrt(i * i + o * o + a * a)) ? (i *= v = 1 / v, o *= v, a *= v) : (i = 0, o = 0, a = 0), s = h * a - f * o, c = f * i - l * a, u = l * o - h * i, (v = Math.sqrt(s * s + c * c + u * u)) ? (s *= v = 1 / v, c *= v, u *= v) : (s = 0, c = 0, u = 0), t[0] = i, t[1] = s, t[2] = l, t[3] = 0, t[4] = o, t[5] = c, t[6] = h, t[7] = 0, t[8] = a, t[9] = u, t[10] = f, t[11] = 0, t[12] = -(i * p + o * m + a * g), t[13] = -(s * p + c * m + u * g), t[14] = -(l * p + h * m + f * g), t[15] = 1, t)
    }

    function Ce(t, e, n, r) {
        var i = e[0],
            o = e[1],
            a = e[2],
            s = r[0],
            c = r[1],
            u = r[2],
            l = i - n[0],
            h = o - n[1],
            f = a - n[2],
            d = l * l + h * h + f * f;
        d > 0 && (l *= d = 1 / Math.sqrt(d), h *= d, f *= d);
        var v = c * f - u * h,
            p = u * l - s * f,
            m = s * h - c * l;
        return (d = v * v + p * p + m * m) > 0 && (v *= d = 1 / Math.sqrt(d), p *= d, m *= d), t[0] = v, t[1] = p, t[2] = m, t[3] = 0, t[4] = h * m - f * p, t[5] = f * v - l * m, t[6] = l * p - h * v, t[7] = 0, t[8] = l, t[9] = h, t[10] = f, t[11] = 0, t[12] = i, t[13] = o, t[14] = a, t[15] = 1, t
    }

    function Re(t) {
        return "mat4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ", " + t[9] + ", " + t[10] + ", " + t[11] + ", " + t[12] + ", " + t[13] + ", " + t[14] + ", " + t[15] + ")"
    }

    function Ie(t) {
        return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2) + Math.pow(t[4], 2) + Math.pow(t[5], 2) + Math.pow(t[6], 2) + Math.pow(t[7], 2) + Math.pow(t[8], 2) + Math.pow(t[9], 2) + Math.pow(t[10], 2) + Math.pow(t[11], 2) + Math.pow(t[12], 2) + Math.pow(t[13], 2) + Math.pow(t[14], 2) + Math.pow(t[15], 2))
    }

    function De(t, e, n) {
        return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t[3] = e[3] + n[3], t[4] = e[4] + n[4], t[5] = e[5] + n[5], t[6] = e[6] + n[6], t[7] = e[7] + n[7], t[8] = e[8] + n[8], t[9] = e[9] + n[9], t[10] = e[10] + n[10], t[11] = e[11] + n[11], t[12] = e[12] + n[12], t[13] = e[13] + n[13], t[14] = e[14] + n[14], t[15] = e[15] + n[15], t
    }

    function Oe(t, e, n) {
        return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t[3] = e[3] - n[3], t[4] = e[4] - n[4], t[5] = e[5] - n[5], t[6] = e[6] - n[6], t[7] = e[7] - n[7], t[8] = e[8] - n[8], t[9] = e[9] - n[9], t[10] = e[10] - n[10], t[11] = e[11] - n[11], t[12] = e[12] - n[12], t[13] = e[13] - n[13], t[14] = e[14] - n[14], t[15] = e[15] - n[15], t
    }

    function Fe(t, e, n) {
        return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * n, t[5] = e[5] * n, t[6] = e[6] * n, t[7] = e[7] * n, t[8] = e[8] * n, t[9] = e[9] * n, t[10] = e[10] * n, t[11] = e[11] * n, t[12] = e[12] * n, t[13] = e[13] * n, t[14] = e[14] * n, t[15] = e[15] * n, t
    }

    function je(t, e, n, r) {
        return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t[2] = e[2] + n[2] * r, t[3] = e[3] + n[3] * r, t[4] = e[4] + n[4] * r, t[5] = e[5] + n[5] * r, t[6] = e[6] + n[6] * r, t[7] = e[7] + n[7] * r, t[8] = e[8] + n[8] * r, t[9] = e[9] + n[9] * r, t[10] = e[10] + n[10] * r, t[11] = e[11] + n[11] * r, t[12] = e[12] + n[12] * r, t[13] = e[13] + n[13] * r, t[14] = e[14] + n[14] * r, t[15] = e[15] + n[15] * r, t
    }

    function ke(t, e) {
        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8] && t[9] === e[9] && t[10] === e[10] && t[11] === e[11] && t[12] === e[12] && t[13] === e[13] && t[14] === e[14] && t[15] === e[15]
    }

    function Ue(t, e) {
        var n = t[0],
            r = t[1],
            i = t[2],
            o = t[3],
            a = t[4],
            s = t[5],
            c = t[6],
            u = t[7],
            l = t[8],
            h = t[9],
            f = t[10],
            v = t[11],
            p = t[12],
            m = t[13],
            g = t[14],
            y = t[15],
            x = e[0],
            b = e[1],
            w = e[2],
            _ = e[3],
            M = e[4],
            S = e[5],
            E = e[6],
            T = e[7],
            P = e[8],
            L = e[9],
            A = e[10],
            z = e[11],
            C = e[12],
            R = e[13],
            I = e[14],
            D = e[15];
        return Math.abs(n - x) <= d * Math.max(1, Math.abs(n), Math.abs(x)) && Math.abs(r - b) <= d * Math.max(1, Math.abs(r), Math.abs(b)) && Math.abs(i - w) <= d * Math.max(1, Math.abs(i), Math.abs(w)) && Math.abs(o - _) <= d * Math.max(1, Math.abs(o), Math.abs(_)) && Math.abs(a - M) <= d * Math.max(1, Math.abs(a), Math.abs(M)) && Math.abs(s - S) <= d * Math.max(1, Math.abs(s), Math.abs(S)) && Math.abs(c - E) <= d * Math.max(1, Math.abs(c), Math.abs(E)) && Math.abs(u - T) <= d * Math.max(1, Math.abs(u), Math.abs(T)) && Math.abs(l - P) <= d * Math.max(1, Math.abs(l), Math.abs(P)) && Math.abs(h - L) <= d * Math.max(1, Math.abs(h), Math.abs(L)) && Math.abs(f - A) <= d * Math.max(1, Math.abs(f), Math.abs(A)) && Math.abs(v - z) <= d * Math.max(1, Math.abs(v), Math.abs(z)) && Math.abs(p - C) <= d * Math.max(1, Math.abs(p), Math.abs(C)) && Math.abs(m - R) <= d * Math.max(1, Math.abs(m), Math.abs(R)) && Math.abs(g - I) <= d * Math.max(1, Math.abs(g), Math.abs(I)) && Math.abs(y - D) <= d * Math.max(1, Math.abs(y), Math.abs(D))
    }
    var Be = oe,
        Ne = Oe;

    function Ge() {
        var t = new v(3);
        return v != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t
    }

    function He(t) {
        var e = new v(3);
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e
    }

    function Ve(t) {
        var e = t[0],
            n = t[1],
            r = t[2];
        return Math.sqrt(e * e + n * n + r * r)
    }

    function We(t, e, n) {
        var r = new v(3);
        return r[0] = t, r[1] = e, r[2] = n, r
    }

    function Ye(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t
    }

    function Xe(t, e, n, r) {
        return t[0] = e, t[1] = n, t[2] = r, t
    }

    function qe(t, e, n) {
        return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t
    }

    function Ke(t, e, n) {
        return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t
    }

    function Ze(t, e, n) {
        return t[0] = e[0] * n[0], t[1] = e[1] * n[1], t[2] = e[2] * n[2], t
    }

    function Je(t, e, n) {
        return t[0] = e[0] / n[0], t[1] = e[1] / n[1], t[2] = e[2] / n[2], t
    }

    function Qe(t, e) {
        return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t[2] = Math.ceil(e[2]), t
    }

    function $e(t, e) {
        return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t[2] = Math.floor(e[2]), t
    }

    function tn(t, e, n) {
        return t[0] = Math.min(e[0], n[0]), t[1] = Math.min(e[1], n[1]), t[2] = Math.min(e[2], n[2]), t
    }

    function en(t, e, n) {
        return t[0] = Math.max(e[0], n[0]), t[1] = Math.max(e[1], n[1]), t[2] = Math.max(e[2], n[2]), t
    }

    function nn(t, e) {
        return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t[2] = Math.round(e[2]), t
    }

    function rn(t, e, n) {
        return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t
    }

    function on(t, e, n, r) {
        return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t[2] = e[2] + n[2] * r, t
    }

    function an(t, e) {
        var n = e[0] - t[0],
            r = e[1] - t[1],
            i = e[2] - t[2];
        return Math.sqrt(n * n + r * r + i * i)
    }

    function sn(t, e) {
        var n = e[0] - t[0],
            r = e[1] - t[1],
            i = e[2] - t[2];
        return n * n + r * r + i * i
    }

    function cn(t) {
        var e = t[0],
            n = t[1],
            r = t[2];
        return e * e + n * n + r * r
    }

    function un(t, e) {
        return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t
    }

    function ln(t, e) {
        return t[0] = 1 / e[0], t[1] = 1 / e[1], t[2] = 1 / e[2], t
    }

    function hn(t, e) {
        var n = e[0],
            r = e[1],
            i = e[2],
            o = n * n + r * r + i * i;
        return o > 0 && (o = 1 / Math.sqrt(o), t[0] = e[0] * o, t[1] = e[1] * o, t[2] = e[2] * o), t
    }

    function fn(t, e) {
        return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
    }

    function dn(t, e, n) {
        var r = e[0],
            i = e[1],
            o = e[2],
            a = n[0],
            s = n[1],
            c = n[2];
        return t[0] = i * c - o * s, t[1] = o * a - r * c, t[2] = r * s - i * a, t
    }

    function vn(t, e, n, r) {
        var i = e[0],
            o = e[1],
            a = e[2];
        return t[0] = i + r * (n[0] - i), t[1] = o + r * (n[1] - o), t[2] = a + r * (n[2] - a), t
    }

    function pn(t, e, n, r, i, o) {
        var a = o * o,
            s = a * (2 * o - 3) + 1,
            c = a * (o - 2) + o,
            u = a * (o - 1),
            l = a * (3 - 2 * o);
        return t[0] = e[0] * s + n[0] * c + r[0] * u + i[0] * l, t[1] = e[1] * s + n[1] * c + r[1] * u + i[1] * l, t[2] = e[2] * s + n[2] * c + r[2] * u + i[2] * l, t
    }

    function mn(t, e, n, r, i, o) {
        var a = 1 - o,
            s = a * a,
            c = o * o,
            u = s * a,
            l = 3 * o * s,
            h = 3 * c * a,
            f = c * o;
        return t[0] = e[0] * u + n[0] * l + r[0] * h + i[0] * f, t[1] = e[1] * u + n[1] * l + r[1] * h + i[1] * f, t[2] = e[2] * u + n[2] * l + r[2] * h + i[2] * f, t
    }

    function gn(t, e) {
        e = e || 1;
        var n = 2 * p() * Math.PI,
            r = 2 * p() - 1,
            i = Math.sqrt(1 - r * r) * e;
        return t[0] = Math.cos(n) * i, t[1] = Math.sin(n) * i, t[2] = r * e, t
    }

    function yn(t, e, n) {
        var r = e[0],
            i = e[1],
            o = e[2],
            a = n[3] * r + n[7] * i + n[11] * o + n[15];
        return a = a || 1, t[0] = (n[0] * r + n[4] * i + n[8] * o + n[12]) / a, t[1] = (n[1] * r + n[5] * i + n[9] * o + n[13]) / a, t[2] = (n[2] * r + n[6] * i + n[10] * o + n[14]) / a, t
    }

    function xn(t, e, n) {
        var r = e[0],
            i = e[1],
            o = e[2];
        return t[0] = r * n[0] + i * n[3] + o * n[6], t[1] = r * n[1] + i * n[4] + o * n[7], t[2] = r * n[2] + i * n[5] + o * n[8], t
    }

    function bn(t, e, n) {
        var r = n[0],
            i = n[1],
            o = n[2],
            a = n[3],
            s = e[0],
            c = e[1],
            u = e[2],
            l = i * u - o * c,
            h = o * s - r * u,
            f = r * c - i * s,
            d = i * f - o * h,
            v = o * l - r * f,
            p = r * h - i * l,
            m = 2 * a;
        return l *= m, h *= m, f *= m, d *= 2, v *= 2, p *= 2, t[0] = s + l + d, t[1] = c + h + v, t[2] = u + f + p, t
    }

    function wn(t, e, n, r) {
        var i = [],
            o = [];
        return i[0] = e[0] - n[0], i[1] = e[1] - n[1], i[2] = e[2] - n[2], o[0] = i[0], o[1] = i[1] * Math.cos(r) - i[2] * Math.sin(r), o[2] = i[1] * Math.sin(r) + i[2] * Math.cos(r), t[0] = o[0] + n[0], t[1] = o[1] + n[1], t[2] = o[2] + n[2], t
    }

    function _n(t, e, n, r) {
        var i = [],
            o = [];
        return i[0] = e[0] - n[0], i[1] = e[1] - n[1], i[2] = e[2] - n[2], o[0] = i[2] * Math.sin(r) + i[0] * Math.cos(r), o[1] = i[1], o[2] = i[2] * Math.cos(r) - i[0] * Math.sin(r), t[0] = o[0] + n[0], t[1] = o[1] + n[1], t[2] = o[2] + n[2], t
    }

    function Mn(t, e, n, r) {
        var i = [],
            o = [];
        return i[0] = e[0] - n[0], i[1] = e[1] - n[1], i[2] = e[2] - n[2], o[0] = i[0] * Math.cos(r) - i[1] * Math.sin(r), o[1] = i[0] * Math.sin(r) + i[1] * Math.cos(r), o[2] = i[2], t[0] = o[0] + n[0], t[1] = o[1] + n[1], t[2] = o[2] + n[2], t
    }

    function Sn(t, e) {
        var n = We(t[0], t[1], t[2]),
            r = We(e[0], e[1], e[2]);
        hn(n, n), hn(r, r);
        var i = fn(n, r);
        return i > 1 ? 0 : i < -1 ? Math.PI : Math.acos(i)
    }

    function En(t) {
        return "vec3(" + t[0] + ", " + t[1] + ", " + t[2] + ")"
    }

    function Tn(t, e) {
        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2]
    }

    function Pn(t, e) {
        var n = t[0],
            r = t[1],
            i = t[2],
            o = e[0],
            a = e[1],
            s = e[2];
        return Math.abs(n - o) <= d * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(r - a) <= d * Math.max(1, Math.abs(r), Math.abs(a)) && Math.abs(i - s) <= d * Math.max(1, Math.abs(i), Math.abs(s))
    }
    var Ln = Ke,
        An = Ze,
        zn = Je,
        Cn = an,
        Rn = sn,
        In = Ve,
        Dn = cn,
        On = function() {
            var t = Ge();
            return function(e, n, r, i, o, a) {
                var s = void 0,
                    c = void 0;
                for (n || (n = 3), r || (r = 0), c = i ? Math.min(i * n + r, e.length) : e.length, s = r; s < c; s += n) t[0] = e[s], t[1] = e[s + 1], t[2] = e[s + 2], o(t, t, a), e[s] = t[0], e[s + 1] = t[1], e[s + 2] = t[2];
                return e
            }
        }();

    function Fn() {
        var t = new v(4);
        return v != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t
    }

    function jn(t) {
        var e = new v(4);
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e
    }

    function kn(t, e, n, r) {
        var i = new v(4);
        return i[0] = t, i[1] = e, i[2] = n, i[3] = r, i
    }

    function Un(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t
    }

    function Bn(t, e, n, r, i) {
        return t[0] = e, t[1] = n, t[2] = r, t[3] = i, t
    }

    function Nn(t, e, n) {
        return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t[3] = e[3] + n[3], t
    }

    function Gn(t, e, n) {
        return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t[3] = e[3] - n[3], t
    }

    function Hn(t, e, n) {
        return t[0] = e[0] * n[0], t[1] = e[1] * n[1], t[2] = e[2] * n[2], t[3] = e[3] * n[3], t
    }

    function Vn(t, e, n) {
        return t[0] = e[0] / n[0], t[1] = e[1] / n[1], t[2] = e[2] / n[2], t[3] = e[3] / n[3], t
    }

    function Wn(t, e) {
        return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t[2] = Math.ceil(e[2]), t[3] = Math.ceil(e[3]), t
    }

    function Yn(t, e) {
        return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t[2] = Math.floor(e[2]), t[3] = Math.floor(e[3]), t
    }

    function Xn(t, e, n) {
        return t[0] = Math.min(e[0], n[0]), t[1] = Math.min(e[1], n[1]), t[2] = Math.min(e[2], n[2]), t[3] = Math.min(e[3], n[3]), t
    }

    function qn(t, e, n) {
        return t[0] = Math.max(e[0], n[0]), t[1] = Math.max(e[1], n[1]), t[2] = Math.max(e[2], n[2]), t[3] = Math.max(e[3], n[3]), t
    }

    function Kn(t, e) {
        return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t[2] = Math.round(e[2]), t[3] = Math.round(e[3]), t
    }

    function Zn(t, e, n) {
        return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t
    }

    function Jn(t, e, n, r) {
        return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t[2] = e[2] + n[2] * r, t[3] = e[3] + n[3] * r, t
    }

    function Qn(t, e) {
        var n = e[0] - t[0],
            r = e[1] - t[1],
            i = e[2] - t[2],
            o = e[3] - t[3];
        return Math.sqrt(n * n + r * r + i * i + o * o)
    }

    function $n(t, e) {
        var n = e[0] - t[0],
            r = e[1] - t[1],
            i = e[2] - t[2],
            o = e[3] - t[3];
        return n * n + r * r + i * i + o * o
    }

    function tr(t) {
        var e = t[0],
            n = t[1],
            r = t[2],
            i = t[3];
        return Math.sqrt(e * e + n * n + r * r + i * i)
    }

    function er(t) {
        var e = t[0],
            n = t[1],
            r = t[2],
            i = t[3];
        return e * e + n * n + r * r + i * i
    }

    function nr(t, e) {
        return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = -e[3], t
    }

    function rr(t, e) {
        return t[0] = 1 / e[0], t[1] = 1 / e[1], t[2] = 1 / e[2], t[3] = 1 / e[3], t
    }

    function ir(t, e) {
        var n = e[0],
            r = e[1],
            i = e[2],
            o = e[3],
            a = n * n + r * r + i * i + o * o;
        return a > 0 && (a = 1 / Math.sqrt(a), t[0] = n * a, t[1] = r * a, t[2] = i * a, t[3] = o * a), t
    }

    function or(t, e) {
        return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3]
    }

    function ar(t, e, n, r) {
        var i = e[0],
            o = e[1],
            a = e[2],
            s = e[3];
        return t[0] = i + r * (n[0] - i), t[1] = o + r * (n[1] - o), t[2] = a + r * (n[2] - a), t[3] = s + r * (n[3] - s), t
    }

    function sr(t, e) {
        var n, r, i, o, a, s;
        e = e || 1;
        do {
            a = (n = 2 * p() - 1) * n + (r = 2 * p() - 1) * r
        } while (a >= 1);
        do {
            s = (i = 2 * p() - 1) * i + (o = 2 * p() - 1) * o
        } while (s >= 1);
        var c = Math.sqrt((1 - a) / s);
        return t[0] = e * n, t[1] = e * r, t[2] = e * i * c, t[3] = e * o * c, t
    }

    function cr(t, e, n) {
        var r = e[0],
            i = e[1],
            o = e[2],
            a = e[3];
        return t[0] = n[0] * r + n[4] * i + n[8] * o + n[12] * a, t[1] = n[1] * r + n[5] * i + n[9] * o + n[13] * a, t[2] = n[2] * r + n[6] * i + n[10] * o + n[14] * a, t[3] = n[3] * r + n[7] * i + n[11] * o + n[15] * a, t
    }

    function ur(t, e, n) {
        var r = e[0],
            i = e[1],
            o = e[2],
            a = n[0],
            s = n[1],
            c = n[2],
            u = n[3],
            l = u * r + s * o - c * i,
            h = u * i + c * r - a * o,
            f = u * o + a * i - s * r,
            d = -a * r - s * i - c * o;
        return t[0] = l * u + d * -a + h * -c - f * -s, t[1] = h * u + d * -s + f * -a - l * -c, t[2] = f * u + d * -c + l * -s - h * -a, t[3] = e[3], t
    }

    function lr(t) {
        return "vec4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
    }

    function hr(t, e) {
        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3]
    }

    function fr(t, e) {
        var n = t[0],
            r = t[1],
            i = t[2],
            o = t[3],
            a = e[0],
            s = e[1],
            c = e[2],
            u = e[3];
        return Math.abs(n - a) <= d * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(r - s) <= d * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(i - c) <= d * Math.max(1, Math.abs(i), Math.abs(c)) && Math.abs(o - u) <= d * Math.max(1, Math.abs(o), Math.abs(u))
    }
    var dr = Gn,
        vr = Hn,
        pr = Vn,
        mr = Qn,
        gr = $n,
        yr = tr,
        xr = er,
        br = function() {
            var t = Fn();
            return function(e, n, r, i, o, a) {
                var s = void 0,
                    c = void 0;
                for (n || (n = 4), r || (r = 0), c = i ? Math.min(i * n + r, e.length) : e.length, s = r; s < c; s += n) t[0] = e[s], t[1] = e[s + 1], t[2] = e[s + 2], t[3] = e[s + 3], o(t, t, a), e[s] = t[0], e[s + 1] = t[1], e[s + 2] = t[2], e[s + 3] = t[3];
                return e
            }
        }();

    function wr() {
        var t = new v(4);
        return v != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t
    }

    function _r(t) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t
    }

    function Mr(t, e, n) {
        n *= .5;
        var r = Math.sin(n);
        return t[0] = r * e[0], t[1] = r * e[1], t[2] = r * e[2], t[3] = Math.cos(n), t
    }

    function Sr(t, e) {
        var n = 2 * Math.acos(e[3]),
            r = Math.sin(n / 2);
        return r > d ? (t[0] = e[0] / r, t[1] = e[1] / r, t[2] = e[2] / r) : (t[0] = 1, t[1] = 0, t[2] = 0), n
    }

    function Er(t, e, n) {
        var r = e[0],
            i = e[1],
            o = e[2],
            a = e[3],
            s = n[0],
            c = n[1],
            u = n[2],
            l = n[3];
        return t[0] = r * l + a * s + i * u - o * c, t[1] = i * l + a * c + o * s - r * u, t[2] = o * l + a * u + r * c - i * s, t[3] = a * l - r * s - i * c - o * u, t
    }

    function Tr(t, e, n) {
        n *= .5;
        var r = e[0],
            i = e[1],
            o = e[2],
            a = e[3],
            s = Math.sin(n),
            c = Math.cos(n);
        return t[0] = r * c + a * s, t[1] = i * c + o * s, t[2] = o * c - i * s, t[3] = a * c - r * s, t
    }

    function Pr(t, e, n) {
        n *= .5;
        var r = e[0],
            i = e[1],
            o = e[2],
            a = e[3],
            s = Math.sin(n),
            c = Math.cos(n);
        return t[0] = r * c - o * s, t[1] = i * c + a * s, t[2] = o * c + r * s, t[3] = a * c - i * s, t
    }

    function Lr(t, e, n) {
        n *= .5;
        var r = e[0],
            i = e[1],
            o = e[2],
            a = e[3],
            s = Math.sin(n),
            c = Math.cos(n);
        return t[0] = r * c + i * s, t[1] = i * c - r * s, t[2] = o * c + a * s, t[3] = a * c - o * s, t
    }

    function Ar(t, e) {
        var n = e[0],
            r = e[1],
            i = e[2];
        return t[0] = n, t[1] = r, t[2] = i, t[3] = Math.sqrt(Math.abs(1 - n * n - r * r - i * i)), t
    }

    function zr(t, e, n, r) {
        var i = e[0],
            o = e[1],
            a = e[2],
            s = e[3],
            c = n[0],
            u = n[1],
            l = n[2],
            h = n[3],
            f = void 0,
            v = void 0,
            p = void 0,
            m = void 0,
            g = void 0;
        return (v = i * c + o * u + a * l + s * h) < 0 && (v = -v, c = -c, u = -u, l = -l, h = -h), 1 - v > d ? (f = Math.acos(v), p = Math.sin(f), m = Math.sin((1 - r) * f) / p, g = Math.sin(r * f) / p) : (m = 1 - r, g = r), t[0] = m * i + g * c, t[1] = m * o + g * u, t[2] = m * a + g * l, t[3] = m * s + g * h, t
    }

    function Cr(t) {
        var e = p(),
            n = p(),
            r = p(),
            i = Math.sqrt(1 - e),
            o = Math.sqrt(e);
        return t[0] = i * Math.sin(2 * Math.PI * n), t[1] = i * Math.cos(2 * Math.PI * n), t[2] = o * Math.sin(2 * Math.PI * r), t[3] = o * Math.cos(2 * Math.PI * r), t
    }

    function Rr(t, e) {
        var n = e[0],
            r = e[1],
            i = e[2],
            o = e[3],
            a = n * n + r * r + i * i + o * o,
            s = a ? 1 / a : 0;
        return t[0] = -n * s, t[1] = -r * s, t[2] = -i * s, t[3] = o * s, t
    }

    function Ir(t, e) {
        return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t
    }

    function Dr(t, e) {
        var n = e[0] + e[4] + e[8],
            r = void 0;
        if (n > 0) r = Math.sqrt(n + 1), t[3] = .5 * r, r = .5 / r, t[0] = (e[5] - e[7]) * r, t[1] = (e[6] - e[2]) * r, t[2] = (e[1] - e[3]) * r;
        else {
            var i = 0;
            e[4] > e[0] && (i = 1), e[8] > e[3 * i + i] && (i = 2);
            var o = (i + 1) % 3,
                a = (i + 2) % 3;
            r = Math.sqrt(e[3 * i + i] - e[3 * o + o] - e[3 * a + a] + 1), t[i] = .5 * r, r = .5 / r, t[3] = (e[3 * o + a] - e[3 * a + o]) * r, t[o] = (e[3 * o + i] + e[3 * i + o]) * r, t[a] = (e[3 * a + i] + e[3 * i + a]) * r
        }
        return t
    }

    function Or(t, e, n, r) {
        var i = .5 * Math.PI / 180;
        e *= i, n *= i, r *= i;
        var o = Math.sin(e),
            a = Math.cos(e),
            s = Math.sin(n),
            c = Math.cos(n),
            u = Math.sin(r),
            l = Math.cos(r);
        return t[0] = o * c * l - a * s * u, t[1] = a * s * l + o * c * u, t[2] = a * c * u - o * s * l, t[3] = a * c * l + o * s * u, t
    }

    function Fr(t) {
        return "quat(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
    }
    var jr = jn,
        kr = kn,
        Ur = Un,
        Br = Bn,
        Nr = Nn,
        Gr = Er,
        Hr = Zn,
        Vr = or,
        Wr = ar,
        Yr = tr,
        Xr = Yr,
        qr = er,
        Kr = qr,
        Zr = ir,
        Jr = hr,
        Qr = fr,
        $r = function() {
            var t = Ge(),
                e = We(1, 0, 0),
                n = We(0, 1, 0);
            return function(r, i, o) {
                var a = fn(i, o);
                return a < -.999999 ? (dn(t, e, i), In(t) < 1e-6 && dn(t, n, i), hn(t, t), Mr(r, t, Math.PI), r) : a > .999999 ? (r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 1, r) : (dn(t, i, o), r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = 1 + a, Zr(r, r))
            }
        }(),
        ti = function() {
            var t = wr(),
                e = wr();
            return function(n, r, i, o, a, s) {
                return zr(t, r, a, s), zr(e, i, o, s), zr(n, t, e, 2 * s * (1 - s)), n
            }
        }(),
        ei = function() {
            var t = gt();
            return function(e, n, r, i) {
                return t[0] = r[0], t[3] = r[1], t[6] = r[2], t[1] = i[0], t[4] = i[1], t[7] = i[2], t[2] = -n[0], t[5] = -n[1], t[8] = -n[2], Zr(e, Dr(e, t))
            }
        }();

    function ni() {
        var t = new v(8);
        return v != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[3] = 1, t
    }

    function ri(t) {
        var e = new v(8);
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e
    }

    function ii(t, e, n, r, i, o, a, s) {
        var c = new v(8);
        return c[0] = t, c[1] = e, c[2] = n, c[3] = r, c[4] = i, c[5] = o, c[6] = a, c[7] = s, c
    }

    function oi(t, e, n, r, i, o, a) {
        var s = new v(8);
        s[0] = t, s[1] = e, s[2] = n, s[3] = r;
        var c = .5 * i,
            u = .5 * o,
            l = .5 * a;
        return s[4] = c * r + u * n - l * e, s[5] = u * r + l * t - c * n, s[6] = l * r + c * e - u * t, s[7] = -c * t - u * e - l * n, s
    }

    function ai(t, e, n) {
        var r = .5 * n[0],
            i = .5 * n[1],
            o = .5 * n[2],
            a = e[0],
            s = e[1],
            c = e[2],
            u = e[3];
        return t[0] = a, t[1] = s, t[2] = c, t[3] = u, t[4] = r * u + i * c - o * s, t[5] = i * u + o * a - r * c, t[6] = o * u + r * s - i * a, t[7] = -r * a - i * s - o * c, t
    }

    function si(t, e) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = .5 * e[0], t[5] = .5 * e[1], t[6] = .5 * e[2], t[7] = 0, t
    }

    function ci(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t
    }

    function ui(t, e) {
        var n = wr();
        _e(n, e);
        var r = new v(3);
        return be(r, e), ai(t, n, r), t
    }

    function li(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t
    }

    function hi(t) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t
    }

    function fi(t, e, n, r, i, o, a, s, c) {
        return t[0] = e, t[1] = n, t[2] = r, t[3] = i, t[4] = o, t[5] = a, t[6] = s, t[7] = c, t
    }
    var di = Ur;

    function vi(t, e) {
        return t[0] = e[4], t[1] = e[5], t[2] = e[6], t[3] = e[7], t
    }
    var pi = Ur;

    function mi(t, e) {
        return t[4] = e[0], t[5] = e[1], t[6] = e[2], t[7] = e[3], t
    }

    function gi(t, e) {
        var n = e[4],
            r = e[5],
            i = e[6],
            o = e[7],
            a = -e[0],
            s = -e[1],
            c = -e[2],
            u = e[3];
        return t[0] = 2 * (n * u + o * a + r * c - i * s), t[1] = 2 * (r * u + o * s + i * a - n * c), t[2] = 2 * (i * u + o * c + n * s - r * a), t
    }

    function yi(t, e, n) {
        var r = e[0],
            i = e[1],
            o = e[2],
            a = e[3],
            s = .5 * n[0],
            c = .5 * n[1],
            u = .5 * n[2],
            l = e[4],
            h = e[5],
            f = e[6],
            d = e[7];
        return t[0] = r, t[1] = i, t[2] = o, t[3] = a, t[4] = a * s + i * u - o * c + l, t[5] = a * c + o * s - r * u + h, t[6] = a * u + r * c - i * s + f, t[7] = -r * s - i * c - o * u + d, t
    }

    function xi(t, e, n) {
        var r = -e[0],
            i = -e[1],
            o = -e[2],
            a = e[3],
            s = e[4],
            c = e[5],
            u = e[6],
            l = e[7],
            h = s * a + l * r + c * o - u * i,
            f = c * a + l * i + u * r - s * o,
            d = u * a + l * o + s * i - c * r,
            v = l * a - s * r - c * i - u * o;
        return Tr(t, e, n), r = t[0], i = t[1], o = t[2], a = t[3], t[4] = h * a + v * r + f * o - d * i, t[5] = f * a + v * i + d * r - h * o, t[6] = d * a + v * o + h * i - f * r, t[7] = v * a - h * r - f * i - d * o, t
    }

    function bi(t, e, n) {
        var r = -e[0],
            i = -e[1],
            o = -e[2],
            a = e[3],
            s = e[4],
            c = e[5],
            u = e[6],
            l = e[7],
            h = s * a + l * r + c * o - u * i,
            f = c * a + l * i + u * r - s * o,
            d = u * a + l * o + s * i - c * r,
            v = l * a - s * r - c * i - u * o;
        return Pr(t, e, n), r = t[0], i = t[1], o = t[2], a = t[3], t[4] = h * a + v * r + f * o - d * i, t[5] = f * a + v * i + d * r - h * o, t[6] = d * a + v * o + h * i - f * r, t[7] = v * a - h * r - f * i - d * o, t
    }

    function wi(t, e, n) {
        var r = -e[0],
            i = -e[1],
            o = -e[2],
            a = e[3],
            s = e[4],
            c = e[5],
            u = e[6],
            l = e[7],
            h = s * a + l * r + c * o - u * i,
            f = c * a + l * i + u * r - s * o,
            d = u * a + l * o + s * i - c * r,
            v = l * a - s * r - c * i - u * o;
        return Lr(t, e, n), r = t[0], i = t[1], o = t[2], a = t[3], t[4] = h * a + v * r + f * o - d * i, t[5] = f * a + v * i + d * r - h * o, t[6] = d * a + v * o + h * i - f * r, t[7] = v * a - h * r - f * i - d * o, t
    }

    function _i(t, e, n) {
        var r = n[0],
            i = n[1],
            o = n[2],
            a = n[3],
            s = e[0],
            c = e[1],
            u = e[2],
            l = e[3];
        return t[0] = s * a + l * r + c * o - u * i, t[1] = c * a + l * i + u * r - s * o, t[2] = u * a + l * o + s * i - c * r, t[3] = l * a - s * r - c * i - u * o, s = e[4], c = e[5], u = e[6], l = e[7], t[4] = s * a + l * r + c * o - u * i, t[5] = c * a + l * i + u * r - s * o, t[6] = u * a + l * o + s * i - c * r, t[7] = l * a - s * r - c * i - u * o, t
    }

    function Mi(t, e, n) {
        var r = e[0],
            i = e[1],
            o = e[2],
            a = e[3],
            s = n[0],
            c = n[1],
            u = n[2],
            l = n[3];
        return t[0] = r * l + a * s + i * u - o * c, t[1] = i * l + a * c + o * s - r * u, t[2] = o * l + a * u + r * c - i * s, t[3] = a * l - r * s - i * c - o * u, s = n[4], c = n[5], u = n[6], l = n[7], t[4] = r * l + a * s + i * u - o * c, t[5] = i * l + a * c + o * s - r * u, t[6] = o * l + a * u + r * c - i * s, t[7] = a * l - r * s - i * c - o * u, t
    }

    function Si(t, e, n, r) {
        if (Math.abs(r) < d) return li(t, e);
        var i = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
        r *= .5;
        var o = Math.sin(r),
            a = o * n[0] / i,
            s = o * n[1] / i,
            c = o * n[2] / i,
            u = Math.cos(r),
            l = e[0],
            h = e[1],
            f = e[2],
            v = e[3];
        t[0] = l * u + v * a + h * c - f * s, t[1] = h * u + v * s + f * a - l * c, t[2] = f * u + v * c + l * s - h * a, t[3] = v * u - l * a - h * s - f * c;
        var p = e[4],
            m = e[5],
            g = e[6],
            y = e[7];
        return t[4] = p * u + y * a + m * c - g * s, t[5] = m * u + y * s + g * a - p * c, t[6] = g * u + y * c + p * s - m * a, t[7] = y * u - p * a - m * s - g * c, t
    }

    function Ei(t, e, n) {
        return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t[3] = e[3] + n[3], t[4] = e[4] + n[4], t[5] = e[5] + n[5], t[6] = e[6] + n[6], t[7] = e[7] + n[7], t
    }

    function Ti(t, e, n) {
        var r = e[0],
            i = e[1],
            o = e[2],
            a = e[3],
            s = n[4],
            c = n[5],
            u = n[6],
            l = n[7],
            h = e[4],
            f = e[5],
            d = e[6],
            v = e[7],
            p = n[0],
            m = n[1],
            g = n[2],
            y = n[3];
        return t[0] = r * y + a * p + i * g - o * m, t[1] = i * y + a * m + o * p - r * g, t[2] = o * y + a * g + r * m - i * p, t[3] = a * y - r * p - i * m - o * g, t[4] = r * l + a * s + i * u - o * c + h * y + v * p + f * g - d * m, t[5] = i * l + a * c + o * s - r * u + f * y + v * m + d * p - h * g, t[6] = o * l + a * u + r * c - i * s + d * y + v * g + h * m - f * p, t[7] = a * l - r * s - i * c - o * u + v * y - h * p - f * m - d * g, t
    }
    var Pi = Ti;

    function Li(t, e, n) {
        return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * n, t[5] = e[5] * n, t[6] = e[6] * n, t[7] = e[7] * n, t
    }
    var Ai = Vr;

    function zi(t, e, n, r) {
        var i = 1 - r;
        return Ai(e, n) < 0 && (r = -r), t[0] = e[0] * i + n[0] * r, t[1] = e[1] * i + n[1] * r, t[2] = e[2] * i + n[2] * r, t[3] = e[3] * i + n[3] * r, t[4] = e[4] * i + n[4] * r, t[5] = e[5] * i + n[5] * r, t[6] = e[6] * i + n[6] * r, t[7] = e[7] * i + n[7] * r, t
    }

    function Ci(t, e) {
        var n = Oi(e);
        return t[0] = -e[0] / n, t[1] = -e[1] / n, t[2] = -e[2] / n, t[3] = e[3] / n, t[4] = -e[4] / n, t[5] = -e[5] / n, t[6] = -e[6] / n, t[7] = e[7] / n, t
    }

    function Ri(t, e) {
        return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t[4] = -e[4], t[5] = -e[5], t[6] = -e[6], t[7] = e[7], t
    }
    var Ii = Yr,
        Di = Ii,
        Oi = qr,
        Fi = Oi;

    function ji(t, e) {
        var n = Oi(e);
        if (n > 0) {
            n = Math.sqrt(n);
            var r = e[0] / n,
                i = e[1] / n,
                o = e[2] / n,
                a = e[3] / n,
                s = e[4],
                c = e[5],
                u = e[6],
                l = e[7],
                h = r * s + i * c + o * u + a * l;
            t[0] = r, t[1] = i, t[2] = o, t[3] = a, t[4] = (s - r * h) / n, t[5] = (c - i * h) / n, t[6] = (u - o * h) / n, t[7] = (l - a * h) / n
        }
        return t
    }

    function ki(t) {
        return "quat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ")"
    }

    function Ui(t, e) {
        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7]
    }

    function Bi(t, e) {
        var n = t[0],
            r = t[1],
            i = t[2],
            o = t[3],
            a = t[4],
            s = t[5],
            c = t[6],
            u = t[7],
            l = e[0],
            h = e[1],
            f = e[2],
            v = e[3],
            p = e[4],
            m = e[5],
            g = e[6],
            y = e[7];
        return Math.abs(n - l) <= d * Math.max(1, Math.abs(n), Math.abs(l)) && Math.abs(r - h) <= d * Math.max(1, Math.abs(r), Math.abs(h)) && Math.abs(i - f) <= d * Math.max(1, Math.abs(i), Math.abs(f)) && Math.abs(o - v) <= d * Math.max(1, Math.abs(o), Math.abs(v)) && Math.abs(a - p) <= d * Math.max(1, Math.abs(a), Math.abs(p)) && Math.abs(s - m) <= d * Math.max(1, Math.abs(s), Math.abs(m)) && Math.abs(c - g) <= d * Math.max(1, Math.abs(c), Math.abs(g)) && Math.abs(u - y) <= d * Math.max(1, Math.abs(u), Math.abs(y))
    }

    function Ni() {
        var t = new v(2);
        return v != Float32Array && (t[0] = 0, t[1] = 0), t
    }

    function Gi(t) {
        var e = new v(2);
        return e[0] = t[0], e[1] = t[1], e
    }

    function Hi(t, e) {
        var n = new v(2);
        return n[0] = t, n[1] = e, n
    }

    function Vi(t, e) {
        return t[0] = e[0], t[1] = e[1], t
    }

    function Wi(t, e, n) {
        return t[0] = e, t[1] = n, t
    }

    function Yi(t, e, n) {
        return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t
    }

    function Xi(t, e, n) {
        return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t
    }

    function qi(t, e, n) {
        return t[0] = e[0] * n[0], t[1] = e[1] * n[1], t
    }

    function Ki(t, e, n) {
        return t[0] = e[0] / n[0], t[1] = e[1] / n[1], t
    }

    function Zi(t, e) {
        return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t
    }

    function Ji(t, e) {
        return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t
    }

    function Qi(t, e, n) {
        return t[0] = Math.min(e[0], n[0]), t[1] = Math.min(e[1], n[1]), t
    }

    function $i(t, e, n) {
        return t[0] = Math.max(e[0], n[0]), t[1] = Math.max(e[1], n[1]), t
    }

    function to(t, e) {
        return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t
    }

    function eo(t, e, n) {
        return t[0] = e[0] * n, t[1] = e[1] * n, t
    }

    function no(t, e, n, r) {
        return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t
    }

    function ro(t, e) {
        var n = e[0] - t[0],
            r = e[1] - t[1];
        return Math.sqrt(n * n + r * r)
    }

    function io(t, e) {
        var n = e[0] - t[0],
            r = e[1] - t[1];
        return n * n + r * r
    }

    function oo(t) {
        var e = t[0],
            n = t[1];
        return Math.sqrt(e * e + n * n)
    }

    function ao(t) {
        var e = t[0],
            n = t[1];
        return e * e + n * n
    }

    function so(t, e) {
        return t[0] = -e[0], t[1] = -e[1], t
    }

    function co(t, e) {
        return t[0] = 1 / e[0], t[1] = 1 / e[1], t
    }

    function uo(t, e) {
        var n = e[0],
            r = e[1],
            i = n * n + r * r;
        return i > 0 && (i = 1 / Math.sqrt(i), t[0] = e[0] * i, t[1] = e[1] * i), t
    }

    function lo(t, e) {
        return t[0] * e[0] + t[1] * e[1]
    }

    function ho(t, e, n) {
        var r = e[0] * n[1] - e[1] * n[0];
        return t[0] = t[1] = 0, t[2] = r, t
    }

    function fo(t, e, n, r) {
        var i = e[0],
            o = e[1];
        return t[0] = i + r * (n[0] - i), t[1] = o + r * (n[1] - o), t
    }

    function vo(t, e) {
        e = e || 1;
        var n = 2 * p() * Math.PI;
        return t[0] = Math.cos(n) * e, t[1] = Math.sin(n) * e, t
    }

    function po(t, e, n) {
        var r = e[0],
            i = e[1];
        return t[0] = n[0] * r + n[2] * i, t[1] = n[1] * r + n[3] * i, t
    }

    function mo(t, e, n) {
        var r = e[0],
            i = e[1];
        return t[0] = n[0] * r + n[2] * i + n[4], t[1] = n[1] * r + n[3] * i + n[5], t
    }

    function go(t, e, n) {
        var r = e[0],
            i = e[1];
        return t[0] = n[0] * r + n[3] * i + n[6], t[1] = n[1] * r + n[4] * i + n[7], t
    }

    function yo(t, e, n) {
        var r = e[0],
            i = e[1];
        return t[0] = n[0] * r + n[4] * i + n[12], t[1] = n[1] * r + n[5] * i + n[13], t
    }

    function xo(t, e, n, r) {
        var i = e[0] - n[0],
            o = e[1] - n[1],
            a = Math.sin(r),
            s = Math.cos(r);
        return t[0] = i * s - o * a + n[0], t[1] = i * a + o * s + n[1], t
    }

    function bo(t, e) {
        var n = t[0],
            r = t[1],
            i = e[0],
            o = e[1],
            a = n * n + r * r;
        a > 0 && (a = 1 / Math.sqrt(a));
        var s = i * i + o * o;
        s > 0 && (s = 1 / Math.sqrt(s));
        var c = (n * i + r * o) * a * s;
        return c > 1 ? 0 : c < -1 ? Math.PI : Math.acos(c)
    }

    function wo(t) {
        return "vec2(" + t[0] + ", " + t[1] + ")"
    }

    function _o(t, e) {
        return t[0] === e[0] && t[1] === e[1]
    }

    function Mo(t, e) {
        var n = t[0],
            r = t[1],
            i = e[0],
            o = e[1];
        return Math.abs(n - i) <= d * Math.max(1, Math.abs(n), Math.abs(i)) && Math.abs(r - o) <= d * Math.max(1, Math.abs(r), Math.abs(o))
    }
    var So = oo,
        Eo = Xi,
        To = qi,
        Po = Ki,
        Lo = ro,
        Ao = io,
        zo = ao,
        Co = function() {
            var t = Ni();
            return function(e, n, r, i, o, a) {
                var s = void 0,
                    c = void 0;
                for (n || (n = 2), r || (r = 0), c = i ? Math.min(i * n + r, e.length) : e.length, s = r; s < c; s += n) t[0] = e[s], t[1] = e[s + 1], o(t, t, a), e[s] = t[0], e[s + 1] = t[1];
                return e
            }
        }();
    n.d(e, "glMatrix", function() {
        return r
    }), n.d(e, "mat2", function() {
        return i
    }), n.d(e, "mat2d", function() {
        return o
    }), n.d(e, "mat3", function() {
        return a
    }), n.d(e, "mat4", function() {
        return s
    }), n.d(e, "quat", function() {
        return l
    }), n.d(e, "quat2", function() {
        return h
    }), n.d(e, "vec2", function() {
        return f
    }), n.d(e, "vec3", function() {
        return c
    }), n.d(e, "vec4", function() {
        return u
    })
}, function(t, e, n) {
    var r = n(6),
        i = n(5).document,
        o = r(i) && r(i.createElement);
    t.exports = function(t) {
        return o ? i.createElement(t) : {}
    }
}, function(t, e, n) {
    var r = n(11),
        i = n(5),
        o = i["__core-js_shared__"] || (i["__core-js_shared__"] = {});
    (t.exports = function(t, e) {
        return o[t] || (o[t] = void 0 !== e ? e : {})
    })("versions", []).push({
        version: r.version,
        mode: n(36) ? "pure" : "global",
        copyright: "© 2018 Denis Pushkarev (zloirock.ru)"
    })
}, function(t, e, n) {
    e.f = n(8)
}, function(t, e, n) {
    var r = n(70)("keys"),
        i = n(35);
    t.exports = function(t) {
        return r[t] || (r[t] = i(t))
    }
}, function(t, e) {
    t.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")
}, function(t, e, n) {
    var r = n(27);
    t.exports = Array.isArray || function(t) {
        return "Array" == r(t)
    }
}, function(t, e, n) {
    var r = n(5).document;
    t.exports = r && r.documentElement
}, function(t, e, n) {
    var r = n(6),
        i = n(7),
        o = function(t, e) {
            if (i(t), !r(e) && null !== e) throw TypeError(e + ": can't set as prototype!")
        };
    t.exports = {
        set: Object.setPrototypeOf || ("__proto__" in {} ? function(t, e, r) {
            try {
                (r = n(25)(Function.call, n(22).f(Object.prototype, "__proto__").set, 2))(t, []), e = !(t instanceof Array)
            } catch (t) {
                e = !0
            }
            return function(t, n) {
                return o(t, n), e ? t.__proto__ = n : r(t, n), t
            }
        }({}, !1) : void 0),
        check: o
    }
}, function(t, e) {
    t.exports = "\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"
}, function(t, e, n) {
    var r = n(6),
        i = n(76).set;
    t.exports = function(t, e, n) {
        var o, a = e.constructor;
        return a !== n && "function" == typeof a && (o = a.prototype) !== n.prototype && r(o) && i && i(t, o), t
    }
}, function(t, e, n) {
    "use strict";
    var r = n(29),
        i = n(28);
    t.exports = function(t) {
        var e = String(i(this)),
            n = "",
            o = r(t);
        if (o < 0 || o == 1 / 0) throw RangeError("Count can't be negative");
        for (; o > 0;
            (o >>>= 1) && (e += e)) 1 & o && (n += e);
        return n
    }
}, function(t, e) {
    t.exports = Math.sign || function(t) {
        return 0 == (t = +t) || t != t ? t : t < 0 ? -1 : 1
    }
}, function(t, e) {
    var n = Math.expm1;
    t.exports = !n || n(10) > 22025.465794806718 || n(10) < 22025.465794806718 || -2e-17 != n(-2e-17) ? function(t) {
        return 0 == (t = +t) ? t : t > -1e-6 && t < 1e-6 ? t + t * t / 2 : Math.exp(t) - 1
    } : n
}, function(t, e, n) {
    "use strict";
    var r = n(36),
        i = n(1),
        o = n(15),
        a = n(18),
        s = n(44),
        c = n(116),
        u = n(43),
        l = n(41),
        h = n(8)("iterator"),
        f = !([].keys && "next" in [].keys()),
        d = function() {
            return this
        };
    t.exports = function(t, e, n, v, p, m, g) {
        c(n, e, v);
        var y, x, b, w = function(t) {
                if (!f && t in E) return E[t];
                switch (t) {
                    case "keys":
                    case "values":
                        return function() {
                            return new n(this, t)
                        }
                }
                return function() {
                    return new n(this, t)
                }
            },
            _ = e + " Iterator",
            M = "values" == p,
            S = !1,
            E = t.prototype,
            T = E[h] || E["@@iterator"] || p && E[p],
            P = T || w(p),
            L = p ? M ? w("entries") : P : void 0,
            A = "Array" == e && E.entries || T;
        if (A && (b = l(A.call(new t))) !== Object.prototype && b.next && (u(b, _, !0), r || "function" == typeof b[h] || a(b, h, d)), M && T && "values" !== T.name && (S = !0, P = function() {
                return T.call(this)
            }), r && !g || !f && !S && E[h] || a(E, h, P), s[e] = P, s[_] = d, p)
            if (y = {
                    values: M ? P : w("values"),
                    keys: m ? P : w("keys"),
                    entries: L
                }, g)
                for (x in y) x in E || o(E, x, y[x]);
            else i(i.P + i.F * (f || S), e, y);
        return y
    }
}, function(t, e, n) {
    var r = n(84),
        i = n(28);
    t.exports = function(t, e, n) {
        if (r(e)) throw TypeError("String#" + n + " doesn't accept regex!");
        return String(i(t))
    }
}, function(t, e, n) {
    var r = n(6),
        i = n(27),
        o = n(8)("match");
    t.exports = function(t) {
        var e;
        return r(t) && (void 0 !== (e = t[o]) ? !!e : "RegExp" == i(t))
    }
}, function(t, e, n) {
    var r = n(8)("match");
    t.exports = function(t) {
        var e = /./;
        try {
            "/./" [t](e)
        } catch (n) {
            try {
                return e[r] = !1, !"/./" [t](e)
            } catch (t) {}
        }
        return !0
    }
}, function(t, e, n) {
    var r = n(44),
        i = n(8)("iterator"),
        o = Array.prototype;
    t.exports = function(t) {
        return void 0 !== t && (r.Array === t || o[i] === t)
    }
}, function(t, e, n) {
    "use strict";
    var r = n(9),
        i = n(34);
    t.exports = function(t, e, n) {
        e in t ? r.f(t, e, i(0, n)) : t[e] = n
    }
}, function(t, e, n) {
    var r = n(54),
        i = n(8)("iterator"),
        o = n(44);
    t.exports = n(11).getIteratorMethod = function(t) {
        if (void 0 != t) return t[i] || t["@@iterator"] || o[r(t)]
    }
}, function(t, e, n) {
    "use strict";
    var r = n(20),
        i = n(38),
        o = n(12);
    t.exports = function(t) {
        for (var e = r(this), n = o(e.length), a = arguments.length, s = i(a > 1 ? arguments[1] : void 0, n), c = a > 2 ? arguments[2] : void 0, u = void 0 === c ? n : i(c, n); u > s;) e[s++] = t;
        return e
    }
}, function(t, e, n) {
    "use strict";
    var r = n(45),
        i = n(120),
        o = n(44),
        a = n(19);
    t.exports = n(82)(Array, "Array", function(t, e) {
        this._t = a(t), this._i = 0, this._k = e
    }, function() {
        var t = this._t,
            e = this._k,
            n = this._i++;
        return !t || n >= t.length ? (this._t = void 0, i(1)) : i(0, "keys" == e ? n : "values" == e ? t[n] : [n, t[n]])
    }, "values"), o.Arguments = o.Array, r("keys"), r("values"), r("entries")
}, function(t, e, n) {
    "use strict";
    var r = n(7);
    t.exports = function() {
        var t = r(this),
            e = "";
        return t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.unicode && (e += "u"), t.sticky && (e += "y"), e
    }
}, function(t, e, n) {
    var r, i, o, a = n(25),
        s = n(109),
        c = n(75),
        u = n(69),
        l = n(5),
        h = l.process,
        f = l.setImmediate,
        d = l.clearImmediate,
        v = l.MessageChannel,
        p = l.Dispatch,
        m = 0,
        g = {},
        y = function() {
            var t = +this;
            if (g.hasOwnProperty(t)) {
                var e = g[t];
                delete g[t], e()
            }
        },
        x = function(t) {
            y.call(t.data)
        };
    f && d || (f = function(t) {
        for (var e = [], n = 1; arguments.length > n;) e.push(arguments[n++]);
        return g[++m] = function() {
            s("function" == typeof t ? t : Function(t), e)
        }, r(m), m
    }, d = function(t) {
        delete g[t]
    }, "process" == n(27)(h) ? r = function(t) {
        h.nextTick(a(y, t, 1))
    } : p && p.now ? r = function(t) {
        p.now(a(y, t, 1))
    } : v ? (o = (i = new v).port2, i.port1.onmessage = x, r = a(o.postMessage, o, 1)) : l.addEventListener && "function" == typeof postMessage && !l.importScripts ? (r = function(t) {
        l.postMessage(t + "", "*")
    }, l.addEventListener("message", x, !1)) : r = "onreadystatechange" in u("script") ? function(t) {
        c.appendChild(u("script")).onreadystatechange = function() {
            c.removeChild(this), y.call(t)
        }
    } : function(t) {
        setTimeout(a(y, t, 1), 0)
    }), t.exports = {
        set: f,
        clear: d
    }
}, function(t, e, n) {
    "use strict";
    var r = n(5),
        i = n(10),
        o = n(36),
        a = n(62),
        s = n(18),
        c = n(48),
        u = n(4),
        l = n(47),
        h = n(29),
        f = n(12),
        d = n(127),
        v = n(40).f,
        p = n(9).f,
        m = n(89),
        g = n(43),
        y = "prototype",
        x = "Wrong index!",
        b = r.ArrayBuffer,
        w = r.DataView,
        _ = r.Math,
        M = r.RangeError,
        S = r.Infinity,
        E = b,
        T = _.abs,
        P = _.pow,
        L = _.floor,
        A = _.log,
        z = _.LN2,
        C = i ? "_b" : "buffer",
        R = i ? "_l" : "byteLength",
        I = i ? "_o" : "byteOffset";

    function D(t, e, n) {
        var r, i, o, a = new Array(n),
            s = 8 * n - e - 1,
            c = (1 << s) - 1,
            u = c >> 1,
            l = 23 === e ? P(2, -24) - P(2, -77) : 0,
            h = 0,
            f = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
        for ((t = T(t)) != t || t === S ? (i = t != t ? 1 : 0, r = c) : (r = L(A(t) / z), t * (o = P(2, -r)) < 1 && (r--, o *= 2), (t += r + u >= 1 ? l / o : l * P(2, 1 - u)) * o >= 2 && (r++, o /= 2), r + u >= c ? (i = 0, r = c) : r + u >= 1 ? (i = (t * o - 1) * P(2, e), r += u) : (i = t * P(2, u - 1) * P(2, e), r = 0)); e >= 8; a[h++] = 255 & i, i /= 256, e -= 8);
        for (r = r << e | i, s += e; s > 0; a[h++] = 255 & r, r /= 256, s -= 8);
        return a[--h] |= 128 * f, a
    }

    function O(t, e, n) {
        var r, i = 8 * n - e - 1,
            o = (1 << i) - 1,
            a = o >> 1,
            s = i - 7,
            c = n - 1,
            u = t[c--],
            l = 127 & u;
        for (u >>= 7; s > 0; l = 256 * l + t[c], c--, s -= 8);
        for (r = l & (1 << -s) - 1, l >>= -s, s += e; s > 0; r = 256 * r + t[c], c--, s -= 8);
        if (0 === l) l = 1 - a;
        else {
            if (l === o) return r ? NaN : u ? -S : S;
            r += P(2, e), l -= a
        }
        return (u ? -1 : 1) * r * P(2, l - e)
    }

    function F(t) {
        return t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0]
    }

    function j(t) {
        return [255 & t]
    }

    function k(t) {
        return [255 & t, t >> 8 & 255]
    }

    function U(t) {
        return [255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255]
    }

    function B(t) {
        return D(t, 52, 8)
    }

    function N(t) {
        return D(t, 23, 4)
    }

    function G(t, e, n) {
        p(t[y], e, {
            get: function() {
                return this[n]
            }
        })
    }

    function H(t, e, n, r) {
        var i = d(+n);
        if (i + e > t[R]) throw M(x);
        var o = t[C]._b,
            a = i + t[I],
            s = o.slice(a, a + e);
        return r ? s : s.reverse()
    }

    function V(t, e, n, r, i, o) {
        var a = d(+n);
        if (a + e > t[R]) throw M(x);
        for (var s = t[C]._b, c = a + t[I], u = r(+i), l = 0; l < e; l++) s[c + l] = u[o ? l : e - l - 1]
    }
    if (a.ABV) {
        if (!u(function() {
                b(1)
            }) || !u(function() {
                new b(-1)
            }) || u(function() {
                return new b, new b(1.5), new b(NaN), "ArrayBuffer" != b.name
            })) {
            for (var W, Y = (b = function(t) {
                    return l(this, b), new E(d(t))
                })[y] = E[y], X = v(E), q = 0; X.length > q;)(W = X[q++]) in b || s(b, W, E[W]);
            o || (Y.constructor = b)
        }
        var K = new w(new b(2)),
            Z = w[y].setInt8;
        K.setInt8(0, 2147483648), K.setInt8(1, 2147483649), !K.getInt8(0) && K.getInt8(1) || c(w[y], {
            setInt8: function(t, e) {
                Z.call(this, t, e << 24 >> 24)
            },
            setUint8: function(t, e) {
                Z.call(this, t, e << 24 >> 24)
            }
        }, !0)
    } else b = function(t) {
        l(this, b, "ArrayBuffer");
        var e = d(t);
        this._b = m.call(new Array(e), 0), this[R] = e
    }, w = function(t, e, n) {
        l(this, w, "DataView"), l(t, b, "DataView");
        var r = t[R],
            i = h(e);
        if (i < 0 || i > r) throw M("Wrong offset!");
        if (i + (n = void 0 === n ? r - i : f(n)) > r) throw M("Wrong length!");
        this[C] = t, this[I] = i, this[R] = n
    }, i && (G(b, "byteLength", "_l"), G(w, "buffer", "_b"), G(w, "byteLength", "_l"), G(w, "byteOffset", "_o")), c(w[y], {
        getInt8: function(t) {
            return H(this, 1, t)[0] << 24 >> 24
        },
        getUint8: function(t) {
            return H(this, 1, t)[0]
        },
        getInt16: function(t) {
            var e = H(this, 2, t, arguments[1]);
            return (e[1] << 8 | e[0]) << 16 >> 16
        },
        getUint16: function(t) {
            var e = H(this, 2, t, arguments[1]);
            return e[1] << 8 | e[0]
        },
        getInt32: function(t) {
            return F(H(this, 4, t, arguments[1]))
        },
        getUint32: function(t) {
            return F(H(this, 4, t, arguments[1])) >>> 0
        },
        getFloat32: function(t) {
            return O(H(this, 4, t, arguments[1]), 23, 4)
        },
        getFloat64: function(t) {
            return O(H(this, 8, t, arguments[1]), 52, 8)
        },
        setInt8: function(t, e) {
            V(this, 1, t, j, e)
        },
        setUint8: function(t, e) {
            V(this, 1, t, j, e)
        },
        setInt16: function(t, e) {
            V(this, 2, t, k, e, arguments[2])
        },
        setUint16: function(t, e) {
            V(this, 2, t, k, e, arguments[2])
        },
        setInt32: function(t, e) {
            V(this, 4, t, U, e, arguments[2])
        },
        setUint32: function(t, e) {
            V(this, 4, t, U, e, arguments[2])
        },
        setFloat32: function(t, e) {
            V(this, 4, t, N, e, arguments[2])
        },
        setFloat64: function(t, e) {
            V(this, 8, t, B, e, arguments[2])
        }
    });
    g(b, "ArrayBuffer"), g(w, "DataView"), s(w[y], a.VIEW, !0), e.ArrayBuffer = b, e.DataView = w
}, function(t, e) {
    t.exports = function() {
        var t = navigator.userAgent;
        return t.indexOf("iPhone") >= 0 || t.indexOf("iPod") >= 0 || t.indexOf("iPad") >= 0
    }
}, function(t, e) {
    t.exports = function() {
        return navigator.userAgent.indexOf("Android") >= 0
    }
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = new r.TextureLoader;
    e.default = function(t, e) {
        var n = Object.keys(t).length,
            o = {},
            a = 0,
            s = function() {
                var s = c;
                t.hasOwnProperty(s) && i.load(t[s], function(t) {
                    t.repeat = r.RepeatWrapping, o[s] = t, ++a >= n && e(o)
                })
            };
        for (var c in t) s()
    }
}, function(t, e, n) {
    "use strict";

    function r(t) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function i(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }

    function o(t, e) {
        return !e || "object" !== r(e) && "function" != typeof e ? function(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(t) : e
    }

    function a(t) {
        return (a = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }

    function s(t, e) {
        return (s = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }
    n.r(e), n.d(e, "default", function() {
        return l
    });
    var c = n(0),
        u = n(63).default,
        l = function(t) {
            function e(t, n, r, i) {
                var s;
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, e), (s = o(this, a(e).call(this, t, n, r, i))).k = .02, s.d = .2, s.velocity = [0, 0, 0], s.acceleration = [0, 0, 0], s.anchor = [0, 0, 0], s.lookK = .02, s.lookD = .2, s.lookVelocity = [0, 0, 0], s.lookAcceleration = [0, 0, 0], s.lookAnchor = [0, 0, 0], s
            }
            return function(t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            writable: !0,
                            configurable: !0
                        }
                    }), e && s(t, e)
                }(e, c.PerspectiveCamera),
                function(t, e, n) {
                    e && i(t.prototype, e), n && i(t, n)
                }(e, [{
                    key: "updatePosition",
                    value: function() {
                        u.applyHook(this.velocity, this.acceleration, this.anchor, 0, this.k), u.applyDrag(this.acceleration, this.d), u.updateVelocity(this.velocity, this.acceleration, 1)
                    }
                }, {
                    key: "updateLook",
                    value: function() {
                        u.applyHook(this.lookVelocity, this.lookAcceleration, this.lookAnchor, 0, this.lookK), u.applyDrag(this.lookAcceleration, this.lookD), u.updateVelocity(this.lookVelocity, this.lookAcceleration, 1)
                    }
                }, {
                    key: "render",
                    value: function() {
                        this.updatePosition(), this.updateLook(), this.position.set(this.velocity[0], this.velocity[1], this.velocity[2]), this.lookAt(this.lookVelocity[0], this.lookVelocity[1], this.lookVelocity[2])
                    }
                }]), e
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(t, e, n) {
    var r = n(0);
    n(14);
    t.exports = function() {
        var t = function() {
            this.velocity = new r.Vector2, this.acceleration = new r.Vector2, this.anchor = new r.Vector2, this.mass = 1
        };
        return t.prototype.updateVelocity = function() {
            this.acceleration.divideScalar(this.mass), this.velocity.add(this.acceleration)
        }, t.prototype.applyForce = function(t) {
            this.acceleration.add(t)
        }, t.prototype.applyFriction = function(t, e) {
            var n = this.acceleration.clone();
            e || (e = 1), n.multiplyScalar(-1), n.normalize(), n.multiplyScalar(t), this.applyForce(n)
        }, t.prototype.applyDrag = function(t) {
            var e = this.acceleration.clone();
            e.multiplyScalar(-1), e.normalize(), e.multiplyScalar(this.acceleration.length() * t), this.applyForce(e)
        }, t.prototype.applyHook = function(t, e) {
            var n = this.velocity.clone().sub(this.anchor),
                r = n.length() - t;
            n.normalize(), n.multiplyScalar(-1 * e * r), this.applyForce(n)
        }, t
    }()
}, function(t, e, n) {
    t.exports = !n(10) && !n(4)(function() {
        return 7 != Object.defineProperty(n(69)("div"), "a", {
            get: function() {
                return 7
            }
        }).a
    })
}, function(t, e, n) {
    var r = n(5),
        i = n(11),
        o = n(36),
        a = n(71),
        s = n(9).f;
    t.exports = function(t) {
        var e = i.Symbol || (i.Symbol = o ? {} : r.Symbol || {});
        "_" == t.charAt(0) || t in e || s(e, t, {
            value: a.f(t)
        })
    }
}, function(t, e, n) {
    var r = n(17),
        i = n(19),
        o = n(52)(!1),
        a = n(72)("IE_PROTO");
    t.exports = function(t, e) {
        var n, s = i(t),
            c = 0,
            u = [];
        for (n in s) n != a && r(s, n) && u.push(n);
        for (; e.length > c;) r(s, n = e[c++]) && (~o(u, n) || u.push(n));
        return u
    }
}, function(t, e, n) {
    var r = n(9),
        i = n(7),
        o = n(37);
    t.exports = n(10) ? Object.defineProperties : function(t, e) {
        i(t);
        for (var n, a = o(e), s = a.length, c = 0; s > c;) r.f(t, n = a[c++], e[n]);
        return t
    }
}, function(t, e, n) {
    var r = n(19),
        i = n(40).f,
        o = {}.toString,
        a = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
    t.exports.f = function(t) {
        return a && "[object Window]" == o.call(t) ? function(t) {
            try {
                return i(t)
            } catch (t) {
                return a.slice()
            }
        }(t) : i(r(t))
    }
}, function(t, e, n) {
    "use strict";
    var r = n(37),
        i = n(53),
        o = n(51),
        a = n(20),
        s = n(50),
        c = Object.assign;
    t.exports = !c || n(4)(function() {
        var t = {},
            e = {},
            n = Symbol(),
            r = "abcdefghijklmnopqrst";
        return t[n] = 7, r.split("").forEach(function(t) {
            e[t] = t
        }), 7 != c({}, t)[n] || Object.keys(c({}, e)).join("") != r
    }) ? function(t, e) {
        for (var n = a(t), c = arguments.length, u = 1, l = i.f, h = o.f; c > u;)
            for (var f, d = s(arguments[u++]), v = l ? r(d).concat(l(d)) : r(d), p = v.length, m = 0; p > m;) h.call(d, f = v[m++]) && (n[f] = d[f]);
        return n
    } : c
}, function(t, e, n) {
    "use strict";
    var r = n(26),
        i = n(6),
        o = n(109),
        a = [].slice,
        s = {};
    t.exports = Function.bind || function(t) {
        var e = r(this),
            n = a.call(arguments, 1),
            c = function() {
                var r = n.concat(a.call(arguments));
                return this instanceof c ? function(t, e, n) {
                    if (!(e in s)) {
                        for (var r = [], i = 0; i < e; i++) r[i] = "a[" + i + "]";
                        s[e] = Function("F,a", "return new F(" + r.join(",") + ")")
                    }
                    return s[e](t, n)
                }(e, r.length, r) : o(e, r, t)
            };
        return i(e.prototype) && (c.prototype = e.prototype), c
    }
}, function(t, e) {
    t.exports = function(t, e, n) {
        var r = void 0 === n;
        switch (e.length) {
            case 0:
                return r ? t() : t.call(n);
            case 1:
                return r ? t(e[0]) : t.call(n, e[0]);
            case 2:
                return r ? t(e[0], e[1]) : t.call(n, e[0], e[1]);
            case 3:
                return r ? t(e[0], e[1], e[2]) : t.call(n, e[0], e[1], e[2]);
            case 4:
                return r ? t(e[0], e[1], e[2], e[3]) : t.call(n, e[0], e[1], e[2], e[3])
        }
        return t.apply(n, e)
    }
}, function(t, e, n) {
    var r = n(5).parseInt,
        i = n(55).trim,
        o = n(77),
        a = /^[-+]?0[xX]/;
    t.exports = 8 !== r(o + "08") || 22 !== r(o + "0x16") ? function(t, e) {
        var n = i(String(t), 3);
        return r(n, e >>> 0 || (a.test(n) ? 16 : 10))
    } : r
}, function(t, e, n) {
    var r = n(5).parseFloat,
        i = n(55).trim;
    t.exports = 1 / r(n(77) + "-0") != -1 / 0 ? function(t) {
        var e = i(String(t), 3),
            n = r(e);
        return 0 === n && "-" == e.charAt(0) ? -0 : n
    } : r
}, function(t, e, n) {
    var r = n(27);
    t.exports = function(t, e) {
        if ("number" != typeof t && "Number" != r(t)) throw TypeError(e);
        return +t
    }
}, function(t, e, n) {
    var r = n(6),
        i = Math.floor;
    t.exports = function(t) {
        return !r(t) && isFinite(t) && i(t) === t
    }
}, function(t, e) {
    t.exports = Math.log1p || function(t) {
        return (t = +t) > -1e-8 && t < 1e-8 ? t - t * t / 2 : Math.log(1 + t)
    }
}, function(t, e, n) {
    var r = n(29),
        i = n(28);
    t.exports = function(t) {
        return function(e, n) {
            var o, a, s = String(i(e)),
                c = r(n),
                u = s.length;
            return c < 0 || c >= u ? t ? "" : void 0 : (o = s.charCodeAt(c)) < 55296 || o > 56319 || c + 1 === u || (a = s.charCodeAt(c + 1)) < 56320 || a > 57343 ? t ? s.charAt(c) : o : t ? s.slice(c, c + 2) : a - 56320 + (o - 55296 << 10) + 65536
        }
    }
}, function(t, e, n) {
    "use strict";
    var r = n(39),
        i = n(34),
        o = n(43),
        a = {};
    n(18)(a, n(8)("iterator"), function() {
        return this
    }), t.exports = function(t, e, n) {
        t.prototype = r(a, {
            next: i(1, n)
        }), o(t, e + " Iterator")
    }
}, function(t, e, n) {
    var r = n(7);
    t.exports = function(t, e, n, i) {
        try {
            return i ? e(r(n)[0], n[1]) : e(n)
        } catch (e) {
            var o = t.return;
            throw void 0 !== o && r(o.call(t)), e
        }
    }
}, function(t, e, n) {
    var r = n(26),
        i = n(20),
        o = n(50),
        a = n(12);
    t.exports = function(t, e, n, s, c) {
        r(e);
        var u = i(t),
            l = o(u),
            h = a(u.length),
            f = c ? h - 1 : 0,
            d = c ? -1 : 1;
        if (n < 2)
            for (;;) {
                if (f in l) {
                    s = l[f], f += d;
                    break
                }
                if (f += d, c ? f < 0 : h <= f) throw TypeError("Reduce of empty array with no initial value")
            }
        for (; c ? f >= 0 : h > f; f += d) f in l && (s = e(s, l[f], f, u));
        return s
    }
}, function(t, e, n) {
    "use strict";
    var r = n(20),
        i = n(38),
        o = n(12);
    t.exports = [].copyWithin || function(t, e) {
        var n = r(this),
            a = o(n.length),
            s = i(t, a),
            c = i(e, a),
            u = arguments.length > 2 ? arguments[2] : void 0,
            l = Math.min((void 0 === u ? a : i(u, a)) - c, a - s),
            h = 1;
        for (c < s && s < c + l && (h = -1, c += l - 1, s += l - 1); l-- > 0;) c in n ? n[s] = n[c] : delete n[s], s += h, c += h;
        return n
    }
}, function(t, e) {
    t.exports = function(t, e) {
        return {
            value: e,
            done: !!t
        }
    }
}, function(t, e, n) {
    n(10) && "g" != /./g.flags && n(9).f(RegExp.prototype, "flags", {
        configurable: !0,
        get: n(91)
    })
}, function(t, e, n) {
    "use strict";
    var r, i, o, a, s = n(36),
        c = n(5),
        u = n(25),
        l = n(54),
        h = n(1),
        f = n(6),
        d = n(26),
        v = n(47),
        p = n(58),
        m = n(59),
        g = n(92).set,
        y = n(256)(),
        x = n(123),
        b = n(257),
        w = n(60),
        _ = n(124),
        M = c.TypeError,
        S = c.process,
        E = S && S.versions,
        T = E && E.v8 || "",
        P = c.Promise,
        L = "process" == l(S),
        A = function() {},
        z = i = x.f,
        C = !! function() {
            try {
                var t = P.resolve(1),
                    e = (t.constructor = {})[n(8)("species")] = function(t) {
                        t(A, A)
                    };
                return (L || "function" == typeof PromiseRejectionEvent) && t.then(A) instanceof e && 0 !== T.indexOf("6.6") && -1 === w.indexOf("Chrome/66")
            } catch (t) {}
        }(),
        R = function(t) {
            var e;
            return !(!f(t) || "function" != typeof(e = t.then)) && e
        },
        I = function(t, e) {
            if (!t._n) {
                t._n = !0;
                var n = t._c;
                y(function() {
                    for (var r = t._v, i = 1 == t._s, o = 0, a = function(e) {
                            var n, o, a, s = i ? e.ok : e.fail,
                                c = e.resolve,
                                u = e.reject,
                                l = e.domain;
                            try {
                                s ? (i || (2 == t._h && F(t), t._h = 1), !0 === s ? n = r : (l && l.enter(), n = s(r), l && (l.exit(), a = !0)), n === e.promise ? u(M("Promise-chain cycle")) : (o = R(n)) ? o.call(n, c, u) : c(n)) : u(r)
                            } catch (t) {
                                l && !a && l.exit(), u(t)
                            }
                        }; n.length > o;) a(n[o++]);
                    t._c = [], t._n = !1, e && !t._h && D(t)
                })
            }
        },
        D = function(t) {
            g.call(c, function() {
                var e, n, r, i = t._v,
                    o = O(t);
                if (o && (e = b(function() {
                        L ? S.emit("unhandledRejection", i, t) : (n = c.onunhandledrejection) ? n({
                            promise: t,
                            reason: i
                        }) : (r = c.console) && r.error && r.error("Unhandled promise rejection", i)
                    }), t._h = L || O(t) ? 2 : 1), t._a = void 0, o && e.e) throw e.v
            })
        },
        O = function(t) {
            return 1 !== t._h && 0 === (t._a || t._c).length
        },
        F = function(t) {
            g.call(c, function() {
                var e;
                L ? S.emit("rejectionHandled", t) : (e = c.onrejectionhandled) && e({
                    promise: t,
                    reason: t._v
                })
            })
        },
        j = function(t) {
            var e = this;
            e._d || (e._d = !0, (e = e._w || e)._v = t, e._s = 2, e._a || (e._a = e._c.slice()), I(e, !0))
        },
        k = function(t) {
            var e, n = this;
            if (!n._d) {
                n._d = !0, n = n._w || n;
                try {
                    if (n === t) throw M("Promise can't be resolved itself");
                    (e = R(t)) ? y(function() {
                        var r = {
                            _w: n,
                            _d: !1
                        };
                        try {
                            e.call(t, u(k, r, 1), u(j, r, 1))
                        } catch (t) {
                            j.call(r, t)
                        }
                    }): (n._v = t, n._s = 1, I(n, !1))
                } catch (t) {
                    j.call({
                        _w: n,
                        _d: !1
                    }, t)
                }
            }
        };
    C || (P = function(t) {
        v(this, P, "Promise", "_h"), d(t), r.call(this);
        try {
            t(u(k, this, 1), u(j, this, 1))
        } catch (t) {
            j.call(this, t)
        }
    }, (r = function(t) {
        this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, this._n = !1
    }).prototype = n(48)(P.prototype, {
        then: function(t, e) {
            var n = z(m(this, P));
            return n.ok = "function" != typeof t || t, n.fail = "function" == typeof e && e, n.domain = L ? S.domain : void 0, this._c.push(n), this._a && this._a.push(n), this._s && I(this, !1), n.promise
        },
        catch: function(t) {
            return this.then(void 0, t)
        }
    }), o = function() {
        var t = new r;
        this.promise = t, this.resolve = u(k, t, 1), this.reject = u(j, t, 1)
    }, x.f = z = function(t) {
        return t === P || t === a ? new o(t) : i(t)
    }), h(h.G + h.W + h.F * !C, {
        Promise: P
    }), n(43)(P, "Promise"), n(46)("Promise"), a = n(11).Promise, h(h.S + h.F * !C, "Promise", {
        reject: function(t) {
            var e = z(this);
            return (0, e.reject)(t), e.promise
        }
    }), h(h.S + h.F * (s || !C), "Promise", {
        resolve: function(t) {
            return _(s && this === a ? P : this, t)
        }
    }), h(h.S + h.F * !(C && n(56)(function(t) {
        P.all(t).catch(A)
    })), "Promise", {
        all: function(t) {
            var e = this,
                n = z(e),
                r = n.resolve,
                i = n.reject,
                o = b(function() {
                    var n = [],
                        o = 0,
                        a = 1;
                    p(t, !1, function(t) {
                        var s = o++,
                            c = !1;
                        n.push(void 0), a++, e.resolve(t).then(function(t) {
                            c || (c = !0, n[s] = t, --a || r(n))
                        }, i)
                    }), --a || r(n)
                });
            return o.e && i(o.v), n.promise
        },
        race: function(t) {
            var e = this,
                n = z(e),
                r = n.reject,
                i = b(function() {
                    p(t, !1, function(t) {
                        e.resolve(t).then(n.resolve, r)
                    })
                });
            return i.e && r(i.v), n.promise
        }
    })
}, function(t, e, n) {
    "use strict";
    var r = n(26);
    t.exports.f = function(t) {
        return new function(t) {
            var e, n;
            this.promise = new t(function(t, r) {
                if (void 0 !== e || void 0 !== n) throw TypeError("Bad Promise constructor");
                e = t, n = r
            }), this.resolve = r(e), this.reject = r(n)
        }(t)
    }
}, function(t, e, n) {
    var r = n(7),
        i = n(6),
        o = n(123);
    t.exports = function(t, e) {
        if (r(t), i(e) && e.constructor === t) return e;
        var n = o.f(t);
        return (0, n.resolve)(e), n.promise
    }
}, function(t, e, n) {
    "use strict";
    var r = n(9).f,
        i = n(39),
        o = n(48),
        a = n(25),
        s = n(47),
        c = n(58),
        u = n(82),
        l = n(120),
        h = n(46),
        f = n(10),
        d = n(33).fastKey,
        v = n(49),
        p = f ? "_s" : "size",
        m = function(t, e) {
            var n, r = d(e);
            if ("F" !== r) return t._i[r];
            for (n = t._f; n; n = n.n)
                if (n.k == e) return n
        };
    t.exports = {
        getConstructor: function(t, e, n, u) {
            var l = t(function(t, r) {
                s(t, l, e, "_i"), t._t = e, t._i = i(null), t._f = void 0, t._l = void 0, t[p] = 0, void 0 != r && c(r, n, t[u], t)
            });
            return o(l.prototype, {
                clear: function() {
                    for (var t = v(this, e), n = t._i, r = t._f; r; r = r.n) r.r = !0, r.p && (r.p = r.p.n = void 0), delete n[r.i];
                    t._f = t._l = void 0, t[p] = 0
                },
                delete: function(t) {
                    var n = v(this, e),
                        r = m(n, t);
                    if (r) {
                        var i = r.n,
                            o = r.p;
                        delete n._i[r.i], r.r = !0, o && (o.n = i), i && (i.p = o), n._f == r && (n._f = i), n._l == r && (n._l = o), n[p]--
                    }
                    return !!r
                },
                forEach: function(t) {
                    v(this, e);
                    for (var n, r = a(t, arguments.length > 1 ? arguments[1] : void 0, 3); n = n ? n.n : this._f;)
                        for (r(n.v, n.k, this); n && n.r;) n = n.p
                },
                has: function(t) {
                    return !!m(v(this, e), t)
                }
            }), f && r(l.prototype, "size", {
                get: function() {
                    return v(this, e)[p]
                }
            }), l
        },
        def: function(t, e, n) {
            var r, i, o = m(t, e);
            return o ? o.v = n : (t._l = o = {
                i: i = d(e, !0),
                k: e,
                v: n,
                p: r = t._l,
                n: void 0,
                r: !1
            }, t._f || (t._f = o), r && (r.n = o), t[p]++, "F" !== i && (t._i[i] = o)), t
        },
        getEntry: m,
        setStrong: function(t, e, n) {
            u(t, e, function(t, n) {
                this._t = v(t, e), this._k = n, this._l = void 0
            }, function() {
                for (var t = this._k, e = this._l; e && e.r;) e = e.p;
                return this._t && (this._l = e = e ? e.n : this._t._f) ? l(0, "keys" == t ? e.k : "values" == t ? e.v : [e.k, e.v]) : (this._t = void 0, l(1))
            }, n ? "entries" : "values", !n, !0), h(e)
        }
    }
}, function(t, e, n) {
    "use strict";
    var r = n(48),
        i = n(33).getWeak,
        o = n(7),
        a = n(6),
        s = n(47),
        c = n(58),
        u = n(24),
        l = n(17),
        h = n(49),
        f = u(5),
        d = u(6),
        v = 0,
        p = function(t) {
            return t._l || (t._l = new m)
        },
        m = function() {
            this.a = []
        },
        g = function(t, e) {
            return f(t.a, function(t) {
                return t[0] === e
            })
        };
    m.prototype = {
        get: function(t) {
            var e = g(this, t);
            if (e) return e[1]
        },
        has: function(t) {
            return !!g(this, t)
        },
        set: function(t, e) {
            var n = g(this, t);
            n ? n[1] = e : this.a.push([t, e])
        },
        delete: function(t) {
            var e = d(this.a, function(e) {
                return e[0] === t
            });
            return ~e && this.a.splice(e, 1), !!~e
        }
    }, t.exports = {
        getConstructor: function(t, e, n, o) {
            var u = t(function(t, r) {
                s(t, u, e, "_i"), t._t = e, t._i = v++, t._l = void 0, void 0 != r && c(r, n, t[o], t)
            });
            return r(u.prototype, {
                delete: function(t) {
                    if (!a(t)) return !1;
                    var n = i(t);
                    return !0 === n ? p(h(this, e)).delete(t) : n && l(n, this._i) && delete n[this._i]
                },
                has: function(t) {
                    if (!a(t)) return !1;
                    var n = i(t);
                    return !0 === n ? p(h(this, e)).has(t) : n && l(n, this._i)
                }
            }), u
        },
        def: function(t, e, n) {
            var r = i(o(e), !0);
            return !0 === r ? p(t).set(e, n) : r[t._i] = n, t
        },
        ufstore: p
    }
}, function(t, e, n) {
    var r = n(29),
        i = n(12);
    t.exports = function(t) {
        if (void 0 === t) return 0;
        var e = r(t),
            n = i(e);
        if (e !== n) throw RangeError("Wrong length!");
        return n
    }
}, function(t, e, n) {
    var r = n(40),
        i = n(53),
        o = n(7),
        a = n(5).Reflect;
    t.exports = a && a.ownKeys || function(t) {
        var e = r.f(o(t)),
            n = i.f;
        return n ? e.concat(n(t)) : e
    }
}, function(t, e, n) {
    var r = n(12),
        i = n(79),
        o = n(28);
    t.exports = function(t, e, n, a) {
        var s = String(o(t)),
            c = s.length,
            u = void 0 === n ? " " : String(n),
            l = r(e);
        if (l <= c || "" == u) return s;
        var h = l - c,
            f = i.call(u, Math.ceil(h / u.length));
        return f.length > h && (f = f.slice(0, h)), a ? f + s : s + f
    }
}, function(t, e, n) {
    var r = n(37),
        i = n(19),
        o = n(51).f;
    t.exports = function(t) {
        return function(e) {
            for (var n, a = i(e), s = r(a), c = s.length, u = 0, l = []; c > u;) o.call(a, n = s[u++]) && l.push(t ? [n, a[n]] : a[n]);
            return l
        }
    }
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = new(n(0).TextureLoader);
    e.default = function(t) {
        return new Promise(function(e, n) {
            r.load(t, e, null, n)
        })
    }
}, function(t, e, n) {
    var r;
    ! function() {
        "use strict";
        var i = .5 * (Math.sqrt(3) - 1),
            o = (3 - Math.sqrt(3)) / 6,
            a = 1 / 6,
            s = (Math.sqrt(5) - 1) / 4,
            c = (5 - Math.sqrt(5)) / 20;

        function u(t) {
            var e;
            e = "function" == typeof t ? t : t ? function() {
                var t = 0,
                    e = 0,
                    n = 0,
                    r = 1,
                    i = function() {
                        var t = 4022871197;
                        return function(e) {
                            e = e.toString();
                            for (var n = 0; n < e.length; n++) {
                                var r = .02519603282416938 * (t += e.charCodeAt(n));
                                r -= t = r >>> 0, t = (r *= t) >>> 0, t += 4294967296 * (r -= t)
                            }
                            return 2.3283064365386963e-10 * (t >>> 0)
                        }
                    }();
                t = i(" "), e = i(" "), n = i(" ");
                for (var o = 0; o < arguments.length; o++)(t -= i(arguments[o])) < 0 && (t += 1), (e -= i(arguments[o])) < 0 && (e += 1), (n -= i(arguments[o])) < 0 && (n += 1);
                return i = null,
                    function() {
                        var i = 2091639 * t + 2.3283064365386963e-10 * r;
                        return t = e, e = n, n = i - (r = 0 | i)
                    }
            }(t) : Math.random, this.p = l(e), this.perm = new Uint8Array(512), this.permMod12 = new Uint8Array(512);
            for (var n = 0; n < 512; n++) this.perm[n] = this.p[255 & n], this.permMod12[n] = this.perm[n] % 12
        }

        function l(t) {
            var e, n = new Uint8Array(256);
            for (e = 0; e < 256; e++) n[e] = e;
            for (e = 0; e < 255; e++) {
                var r = e + ~~(t() * (256 - e)),
                    i = n[e];
                n[e] = n[r], n[r] = i
            }
            return n
        }
        u.prototype = {
            grad3: new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]),
            grad4: new Float32Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1, -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1, 1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1, -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]),
            noise2D: function(t, e) {
                var n, r, a = this.permMod12,
                    s = this.perm,
                    c = this.grad3,
                    u = 0,
                    l = 0,
                    h = 0,
                    f = (t + e) * i,
                    d = Math.floor(t + f),
                    v = Math.floor(e + f),
                    p = (d + v) * o,
                    m = t - (d - p),
                    g = e - (v - p);
                m > g ? (n = 1, r = 0) : (n = 0, r = 1);
                var y = m - n + o,
                    x = g - r + o,
                    b = m - 1 + 2 * o,
                    w = g - 1 + 2 * o,
                    _ = 255 & d,
                    M = 255 & v,
                    S = .5 - m * m - g * g;
                if (S >= 0) {
                    var E = 3 * a[_ + s[M]];
                    u = (S *= S) * S * (c[E] * m + c[E + 1] * g)
                }
                var T = .5 - y * y - x * x;
                if (T >= 0) {
                    var P = 3 * a[_ + n + s[M + r]];
                    l = (T *= T) * T * (c[P] * y + c[P + 1] * x)
                }
                var L = .5 - b * b - w * w;
                if (L >= 0) {
                    var A = 3 * a[_ + 1 + s[M + 1]];
                    h = (L *= L) * L * (c[A] * b + c[A + 1] * w)
                }
                return 70 * (u + l + h)
            },
            noise3D: function(t, e, n) {
                var r, i, o, s, c, u, l, h, f, d, v = this.permMod12,
                    p = this.perm,
                    m = this.grad3,
                    g = (t + e + n) * (1 / 3),
                    y = Math.floor(t + g),
                    x = Math.floor(e + g),
                    b = Math.floor(n + g),
                    w = (y + x + b) * a,
                    _ = t - (y - w),
                    M = e - (x - w),
                    S = n - (b - w);
                _ >= M ? M >= S ? (c = 1, u = 0, l = 0, h = 1, f = 1, d = 0) : _ >= S ? (c = 1, u = 0, l = 0, h = 1, f = 0, d = 1) : (c = 0, u = 0, l = 1, h = 1, f = 0, d = 1) : M < S ? (c = 0, u = 0, l = 1, h = 0, f = 1, d = 1) : _ < S ? (c = 0, u = 1, l = 0, h = 0, f = 1, d = 1) : (c = 0, u = 1, l = 0, h = 1, f = 1, d = 0);
                var E = _ - c + a,
                    T = M - u + a,
                    P = S - l + a,
                    L = _ - h + 2 * a,
                    A = M - f + 2 * a,
                    z = S - d + 2 * a,
                    C = _ - 1 + .5,
                    R = M - 1 + .5,
                    I = S - 1 + .5,
                    D = 255 & y,
                    O = 255 & x,
                    F = 255 & b,
                    j = .6 - _ * _ - M * M - S * S;
                if (j < 0) r = 0;
                else {
                    var k = 3 * v[D + p[O + p[F]]];
                    r = (j *= j) * j * (m[k] * _ + m[k + 1] * M + m[k + 2] * S)
                }
                var U = .6 - E * E - T * T - P * P;
                if (U < 0) i = 0;
                else {
                    var B = 3 * v[D + c + p[O + u + p[F + l]]];
                    i = (U *= U) * U * (m[B] * E + m[B + 1] * T + m[B + 2] * P)
                }
                var N = .6 - L * L - A * A - z * z;
                if (N < 0) o = 0;
                else {
                    var G = 3 * v[D + h + p[O + f + p[F + d]]];
                    o = (N *= N) * N * (m[G] * L + m[G + 1] * A + m[G + 2] * z)
                }
                var H = .6 - C * C - R * R - I * I;
                if (H < 0) s = 0;
                else {
                    var V = 3 * v[D + 1 + p[O + 1 + p[F + 1]]];
                    s = (H *= H) * H * (m[V] * C + m[V + 1] * R + m[V + 2] * I)
                }
                return 32 * (r + i + o + s)
            },
            noise4D: function(t, e, n, r) {
                var i, o, a, u, l, h, f, d, v, p, m, g, y, x, b, w, _, M = this.perm,
                    S = this.grad4,
                    E = (t + e + n + r) * s,
                    T = Math.floor(t + E),
                    P = Math.floor(e + E),
                    L = Math.floor(n + E),
                    A = Math.floor(r + E),
                    z = (T + P + L + A) * c,
                    C = t - (T - z),
                    R = e - (P - z),
                    I = n - (L - z),
                    D = r - (A - z),
                    O = 0,
                    F = 0,
                    j = 0,
                    k = 0;
                C > R ? O++ : F++, C > I ? O++ : j++, C > D ? O++ : k++, R > I ? F++ : j++, R > D ? F++ : k++, I > D ? j++ : k++;
                var U = C - (h = O >= 3 ? 1 : 0) + c,
                    B = R - (f = F >= 3 ? 1 : 0) + c,
                    N = I - (d = j >= 3 ? 1 : 0) + c,
                    G = D - (v = k >= 3 ? 1 : 0) + c,
                    H = C - (p = O >= 2 ? 1 : 0) + 2 * c,
                    V = R - (m = F >= 2 ? 1 : 0) + 2 * c,
                    W = I - (g = j >= 2 ? 1 : 0) + 2 * c,
                    Y = D - (y = k >= 2 ? 1 : 0) + 2 * c,
                    X = C - (x = O >= 1 ? 1 : 0) + 3 * c,
                    q = R - (b = F >= 1 ? 1 : 0) + 3 * c,
                    K = I - (w = j >= 1 ? 1 : 0) + 3 * c,
                    Z = D - (_ = k >= 1 ? 1 : 0) + 3 * c,
                    J = C - 1 + 4 * c,
                    Q = R - 1 + 4 * c,
                    $ = I - 1 + 4 * c,
                    tt = D - 1 + 4 * c,
                    et = 255 & T,
                    nt = 255 & P,
                    rt = 255 & L,
                    it = 255 & A,
                    ot = .6 - C * C - R * R - I * I - D * D;
                if (ot < 0) i = 0;
                else {
                    var at = M[et + M[nt + M[rt + M[it]]]] % 32 * 4;
                    i = (ot *= ot) * ot * (S[at] * C + S[at + 1] * R + S[at + 2] * I + S[at + 3] * D)
                }
                var st = .6 - U * U - B * B - N * N - G * G;
                if (st < 0) o = 0;
                else {
                    var ct = M[et + h + M[nt + f + M[rt + d + M[it + v]]]] % 32 * 4;
                    o = (st *= st) * st * (S[ct] * U + S[ct + 1] * B + S[ct + 2] * N + S[ct + 3] * G)
                }
                var ut = .6 - H * H - V * V - W * W - Y * Y;
                if (ut < 0) a = 0;
                else {
                    var lt = M[et + p + M[nt + m + M[rt + g + M[it + y]]]] % 32 * 4;
                    a = (ut *= ut) * ut * (S[lt] * H + S[lt + 1] * V + S[lt + 2] * W + S[lt + 3] * Y)
                }
                var ht = .6 - X * X - q * q - K * K - Z * Z;
                if (ht < 0) u = 0;
                else {
                    var ft = M[et + x + M[nt + b + M[rt + w + M[it + _]]]] % 32 * 4;
                    u = (ht *= ht) * ht * (S[ft] * X + S[ft + 1] * q + S[ft + 2] * K + S[ft + 3] * Z)
                }
                var dt = .6 - J * J - Q * Q - $ * $ - tt * tt;
                if (dt < 0) l = 0;
                else {
                    var vt = M[et + 1 + M[nt + 1 + M[rt + 1 + M[it + 1]]]] % 32 * 4;
                    l = (dt *= dt) * dt * (S[vt] * J + S[vt + 1] * Q + S[vt + 2] * $ + S[vt + 3] * tt)
                }
                return 27 * (i + o + a + u + l)
            }
        }, u._buildPermutationTable = l, void 0 === (r = function() {
            return u
        }.call(e, n, e, t)) || (t.exports = r), e.SimplexNoise = u, t.exports = u
    }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 position2;\nattribute vec2 uv;\nattribute float opacity;\nattribute float opacity2;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float timeTransform;\nuniform float durationTransform;\nuniform float prevIndex;\nuniform float nextIndex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\nfloat exponentialOut_1_0(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\n\n\nmat4 calcRotateMat4X_3_1(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Y_4_2(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Z_5_3(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n\nmat4 calcRotateMat4_2_4(vec3 radian) {\n  return calcRotateMat4X_3_1(radian.x) * calcRotateMat4Y_4_2(radian.y) * calcRotateMat4Z_5_3(radian.z);\n}\n\n\n\nvoid main(void) {\n  // transform\n  vec3 prevPosition =\n    position * (1.0 - step(1.0, prevIndex))\n    + position2 * step(1.0, prevIndex) * (1.0 - step(2.0, prevIndex));\n  vec3 nextPosition =\n    position * (1.0 - step(1.0, nextIndex))\n    + position2 * step(1.0, nextIndex) * (1.0 - step(2.0, nextIndex));\n  float prevOpacity =\n    opacity * (1.0 - step(1.0, prevIndex))\n    + opacity2 * step(1.0, prevIndex) * (1.0 - step(2.0, prevIndex));\n  float nextOpacity =\n    opacity * (1.0 - step(1.0, nextIndex))\n    + opacity2 * step(1.0, nextIndex) * (1.0 - step(2.0, nextIndex));\n  float ease = exponentialOut_1_0(min(timeTransform / 1.0, durationTransform) / durationTransform);\n  vec3 mixPosition = mix(prevPosition, nextPosition, ease);\n  float mixOpacity = mix(prevOpacity, nextOpacity, ease);\n\n  // calculate shake moving.\n  float now = time * 10.0 + length(mixPosition);\n  mat4 rotateMat = calcRotateMat4_2_4(vec3(now));\n  vec3 shake = (rotateMat * vec4(vec3(0.0, sin(now) * 5.0, 0.0), 1.0)).xyz;\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(mixPosition + shake, 1.0);\n\n  vPosition = mixPosition;\n  vUv = uv;\n  vOpacity = mixOpacity;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float timeShow;\nuniform float durationShow;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nmat4 calcRotateMat4X_3_1(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Y_4_2(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Z_5_3(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n\nmat4 calcRotateMat4_2_4(vec3 radian) {\n  return calcRotateMat4X_3_1(radian.x) * calcRotateMat4Y_4_2(radian.y) * calcRotateMat4Z_5_3(radian.z);\n}\n\n\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main() {\n  // convert uv to range from -1.0 to 1.0\n  vec2 resolution = uv * 2.0 - 1.0;\n\n  // update rotation\n  float rotateX = resolution.x * 100.0 + time / 2.0;\n  float rotateY = resolution.y * 200.0 + time / 2.0;\n  float rotateZ = length(resolution.xy) * 150.0 + time / 2.0;\n  mat4 rotateMat = calcRotateMat4_2_4(vec3(rotateX, rotateY, rotateZ));\n  vec3 rotatePosition = (rotateMat * vec4(vec3(sin(time * 0.1 + resolution.x * 10.0) * 150.0), 1.0)).xyz;\n\n  // update position\n  vec3 wavePosition = vec3(0.0, 0.0, sin(time * 0.1 + (resolution.x + resolution.y) * 5.6) * 300.0);\n  vec3 updatePosition = position + rotatePosition + wavePosition;\n\n  // calculate colors\n  vec3 hsv = vec3(time * 0.1 + 0.5, 0.35, 0.6);\n  vec3 rgb = convertHsvToRgb_1_0(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(updatePosition, 1.0);\n\n  vPosition = updatePosition;\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t(e, n, r, o) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    resolution: {
                        type: "v2",
                        value: new i.Vector2
                    },
                    direction: {
                        type: "v2",
                        value: new i.Vector2(n, r)
                    },
                    radius: {
                        type: "f",
                        value: o
                    },
                    texture: {
                        type: "t",
                        value: e
                    }
                }, this.obj, this.createObj()
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.PlaneBufferGeometry(2, 2),
                        e = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(98),
                            fragmentShader: n(467)
                        });
                    this.obj = new i.Mesh(t, e), this.obj.visible = !1
                }
            }, {
                key: "resize",
                value: function(t) {
                    this.uniforms.resolution.value.set(t.x, t.y)
                }
            }, {
                key: "render",
                value: function(t, e, n, r) {
                    this.obj.visible = !0, t.render(e, n, r), this.obj.visible = !1
                }
            }]), t
        }()
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t(e, n, r, o) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    resolution: {
                        type: "v2",
                        value: new i.Vector2
                    },
                    direction: {
                        type: "v2",
                        value: new i.Vector2(n, r)
                    },
                    radius: {
                        type: "f",
                        value: o
                    },
                    texture: {
                        type: "t",
                        value: e
                    }
                }, this.obj = this.createObj(), this.obj.visible = !1
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(99),
                        fragmentShader: n(486)
                    }))
                }
            }, {
                key: "resize",
                value: function(t) {
                    this.uniforms.resolution.value.set(t.x, t.y)
                }
            }, {
                key: "render",
                value: function(t, e, n, r) {
                    this.obj.visible = !0, t.render(e, n, r), this.obj.visible = !1
                }
            }]), t
        }()
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t(e, n, r, o) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.side = 0, this.aScene = new i.Scene, this.vScene = new i.Scene, this.camera = new i.PerspectiveCamera(45, 1, 1, 1e3), this.option = {
                    type: i.FloatType,
                    minFilter: i.LinearFilter,
                    magFilter: i.NearestFilter
                }, this.acceleration = [new i.WebGLRenderTarget(0, 0, this.option), new i.WebGLRenderTarget(0, 0, this.option)], this.velocity = [new i.WebGLRenderTarget(0, 0, this.option), new i.WebGLRenderTarget(0, 0, this.option)], this.aUniforms = {
                    resolution: {
                        type: "v2",
                        value: new i.Vector2(document.body.clientWidth, window.innerHeight)
                    },
                    velocity: {
                        type: "t",
                        value: null
                    },
                    acceleration: {
                        type: "t",
                        value: null
                    },
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.vUniforms = {
                    resolution: {
                        type: "v2",
                        value: new i.Vector2(document.body.clientWidth, window.innerHeight)
                    },
                    side: {
                        type: "f",
                        value: 0
                    },
                    velocityInit: {
                        type: "t",
                        value: null
                    },
                    velocity: {
                        type: "t",
                        value: null
                    },
                    acceleration: {
                        type: "t",
                        value: null
                    },
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.accelerationMesh = this.createMesh(this.aUniforms, e, n), this.velocityMesh = this.createMesh(this.vUniforms, r, o), this.uvs = [], this.targetIndex = 0
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "init",
                value: function(t, e, r, o) {
                    this.side = Math.ceil(Math.sqrt(e.length / 3)), this.vUniforms.side.value = this.side;
                    for (var a = [], s = 0; s < 3 * Math.pow(this.side, 2); s += 3) void 0 != e[s] ? (a[s + 0] = e[s + 0], a[s + 1] = e[s + 1], a[s + 2] = e[s + 2], this.uvs[s / 3 * 2 + 0] = s / 3 % this.side / (this.side - 1), this.uvs[s / 3 * 2 + 1] = Math.floor(s / 3 / this.side) / (this.side - 1)) : (a[s + 0] = 0, a[s + 1] = 0, a[s + 2] = 0);
                    if (r) {
                        var c = Object.keys(r);
                        if (c.length)
                            for (s = 0; s < c.length; s++) {
                                for (var u = r[c[s]], l = u.array.length; l < a.length / 3 * u.itemSize; l++) u.array.push(0);
                                this.accelerationMesh.geometry.addAttribute(c[s], new i.BufferAttribute(new Float32Array(u.array), u.itemSize))
                            }
                    }
                    if (o) {
                        var h = Object.keys(o);
                        if (h.length)
                            for (s = 0; s < h.length; s++) {
                                var f = o[h[s]];
                                for (l = f.array.length; l < a.length / 3 * f.itemSize; l++) f.array.push(0);
                                this.velocityMesh.geometry.addAttribute(h[s], new i.BufferAttribute(new Float32Array(f.array), f.itemSize))
                            }
                    }
                    this.vUniforms.velocityInit.value = new i.DataTexture(new Float32Array(a), this.side, this.side, i.RGBFormat, i.FloatType), this.vUniforms.velocityInit.value.needsUpdate = !0;
                    var d = new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.ShaderMaterial({
                        uniforms: {
                            velocity: {
                                type: "t",
                                value: this.vUniforms.velocityInit.value
                            }
                        },
                        vertexShader: n(539),
                        fragmentShader: n(540)
                    }));
                    for (s = 0; s < 2; s++) this.acceleration[s].setSize(this.side, this.side), this.velocity[s].setSize(this.side, this.side);
                    this.vScene.add(this.camera), this.vScene.add(d), t.render(this.vScene, this.camera, this.velocity[0]), t.render(this.vScene, this.camera, this.velocity[1]), this.vScene.remove(d), this.vScene.add(this.velocityMesh), this.aScene.add(this.accelerationMesh)
                }
            }, {
                key: "createMesh",
                value: function(t, e, n) {
                    return new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.ShaderMaterial({
                        uniforms: t,
                        vertexShader: e,
                        fragmentShader: n
                    }))
                }
            }, {
                key: "render",
                value: function(t, e) {
                    var n = Math.abs(this.targetIndex - 1),
                        r = this.targetIndex;
                    this.aUniforms.acceleration.value = this.acceleration[n].texture, this.aUniforms.velocity.value = this.velocity[r].texture, t.render(this.aScene, this.camera, this.acceleration[r]), this.vUniforms.acceleration.value = this.acceleration[r].texture, this.vUniforms.velocity.value = this.velocity[r].texture, t.render(this.vScene, this.camera, this.velocity[n]), this.targetIndex = n, this.aUniforms.time.value += e, this.vUniforms.time.value += e
                }
            }, {
                key: "getBufferAttributeUv",
                value: function() {
                    return new i.BufferAttribute(new Float32Array(this.uvs), 2)
                }
            }, {
                key: "getCurrentVelocity",
                value: function() {
                    return this.velocity[Math.abs(this.targetIndex - 1)].texture
                }
            }, {
                key: "getCurrentAcceleration",
                value: function() {
                    return this.acceleration[Math.abs(this.targetIndex - 1)].texture
                }
            }, {
                key: "mergeAUniforms",
                value: function(t) {
                    this.aUniforms = Object.assign(this.aUniforms, t)
                }
            }, {
                key: "mergeVUniforms",
                value: function(t) {
                    this.vUniforms = Object.assign(this.vUniforms, t)
                }
            }, {
                key: "resize",
                value: function(t) {
                    this.aUniforms.resolution.value.set(document.body.clientWidth, window.clientHeight), this.vUniforms.resolution.value.set(document.body.clientWidth, window.clientHeight)
                }
            }]), t
        }()
}, function(t, e, n) {
    var r = n(0),
        i = n(14),
        o = n(42);
    t.exports = function() {
        var t = function(t, e, n) {
            r.HemisphereLight.call(this, t, e, n), this.force = new o
        };
        return (t.prototype = Object.create(r.HemisphereLight.prototype)).constructor = t, t.prototype.updatePosition = function() {
            this.position.copy(this.force.velocity)
        }, t.prototype.setPositionSpherical = function(t, e, n) {
            this.position.copy(i.getPolarCoord(t, e, n))
        }, t
    }()
}, function(t, e, n) {
    var r = n(0),
        i = n(14),
        o = n(42);
    t.exports = function() {
        var t = function(t, e, n, i) {
            r.PointLight.call(this, t, e, n, i), this.force = new o
        };
        return (t.prototype = Object.create(r.PointLight.prototype)).constructor = t, t.prototype.updatePosition = function() {
            this.position.copy(this.force.velocity)
        }, t.prototype.setPolarCoord = function(t, e, n) {
            this.position.copy(i.getPolarCoord(t, e, n))
        }, t
    }()
}, function(t, e, n) {
    n(141);
    var r = n(308).default,
        i = n(309).default,
        o = document.querySelector(".l-page").dataset.id;
    new r;
    if ("index" == o) n(310).default();
    else {
        var a = document.getElementById("canvas-webgl");
        switch (a.addEventListener("contextmenu", function(t) {
            t.preventDefault()
        }), a.addEventListener("selectstart", function(t) {
            t.preventDefault()
        }), o) {
            case "buddha":
                n(339).default();
                break;
            case "planet":
                n(358).default();
                break;
            case "land":
                n(372).default();
                break;
            case "webcam":
                n(380).default();
                break;
            case "fog":
                n(398).default();
                break;
            case "node_text":
                n(402).default();
                break;
            case "repel":
                n(411).default();
                break;
            case "flame":
                n(415).default();
                break;
            case "cyberspace":
                n(429).default();
                break;
            case "beam":
                n(451).default();
                break;
            case "blink":
                n(455).default();
                break;
            case "transform":
                n(459).default();
                break;
            case "egg":
                n(474).default();
                break;
            case "butterfly":
                n(478).default();
                break;
            case "puddle":
                n(493).default();
                break;
            case "reel":
                n(497).default();
                break;
            case "glitch":
                n(513).default();
                break;
            case "instancing":
                n(520).default();
                break;
            case "particle":
                n(531).default();
                break;
            case "attract":
                n(547).default();
                break;
            case "hole":
                n(554).default();
                break;
            case "metal_cube":
                n(567).default();
                break;
            case "distort":
                n(572).default();
                break;
            case "image_data":
                n(577).default();
                break;
            case "gallery":
                n(578).default();
                break;
            case "comet":
                n(579).default();
                break;
            case "hyper_space":
                n(580).default();
                break;
            case "fire_ball":
                n(581).default()
        }
    }
    i()
}, function(t, e, n) {
    "use strict";
    (function(t) {
        n(143), n(287), n(289), n(291), n(293), n(295), n(297), n(299), n(301), n(303), n(307), t._babelPolyfill && "undefined" != typeof console && console.warn && console.warn("@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended and may have consequences if different versions of the polyfills are applied sequentially. If you do need to load the polyfill more than once, use @babel/polyfill/noConflict instead to bypass the warning."), t._babelPolyfill = !0
    }).call(this, n(142))
}, function(t, e) {
    var n;
    n = function() {
        return this
    }();
    try {
        n = n || Function("return this")() || (0, eval)("this")
    } catch (t) {
        "object" == typeof window && (n = window)
    }
    t.exports = n
}, function(t, e, n) {
    n(144), n(146), n(147), n(148), n(149), n(150), n(151), n(152), n(153), n(154), n(155), n(156), n(157), n(158), n(159), n(160), n(162), n(163), n(164), n(165), n(166), n(167), n(168), n(169), n(170), n(171), n(172), n(173), n(174), n(175), n(176), n(177), n(178), n(179), n(180), n(181), n(182), n(183), n(184), n(185), n(186), n(187), n(188), n(190), n(191), n(192), n(193), n(194), n(195), n(196), n(197), n(198), n(199), n(200), n(201), n(202), n(203), n(204), n(205), n(206), n(207), n(208), n(209), n(210), n(211), n(212), n(213), n(214), n(215), n(216), n(217), n(218), n(219), n(220), n(221), n(222), n(223), n(225), n(226), n(228), n(229), n(230), n(231), n(232), n(233), n(234), n(237), n(238), n(239), n(240), n(241), n(242), n(243), n(244), n(245), n(246), n(247), n(248), n(249), n(90), n(250), n(251), n(121), n(252), n(253), n(254), n(255), n(122), n(258), n(259), n(260), n(261), n(262), n(263), n(264), n(265), n(266), n(267), n(268), n(269), n(270), n(271), n(272), n(273), n(274), n(275), n(276), n(277), n(278), n(279), n(280), n(281), n(282), n(283), n(284), n(285), n(286), t.exports = n(11)
}, function(t, e, n) {
    "use strict";
    var r = n(5),
        i = n(17),
        o = n(10),
        a = n(1),
        s = n(15),
        c = n(33).KEY,
        u = n(4),
        l = n(70),
        h = n(43),
        f = n(35),
        d = n(8),
        v = n(71),
        p = n(103),
        m = n(145),
        g = n(74),
        y = n(7),
        x = n(6),
        b = n(19),
        w = n(32),
        _ = n(34),
        M = n(39),
        S = n(106),
        E = n(22),
        T = n(9),
        P = n(37),
        L = E.f,
        A = T.f,
        z = S.f,
        C = r.Symbol,
        R = r.JSON,
        I = R && R.stringify,
        D = d("_hidden"),
        O = d("toPrimitive"),
        F = {}.propertyIsEnumerable,
        j = l("symbol-registry"),
        k = l("symbols"),
        U = l("op-symbols"),
        B = Object.prototype,
        N = "function" == typeof C,
        G = r.QObject,
        H = !G || !G.prototype || !G.prototype.findChild,
        V = o && u(function() {
            return 7 != M(A({}, "a", {
                get: function() {
                    return A(this, "a", {
                        value: 7
                    }).a
                }
            })).a
        }) ? function(t, e, n) {
            var r = L(B, e);
            r && delete B[e], A(t, e, n), r && t !== B && A(B, e, r)
        } : A,
        W = function(t) {
            var e = k[t] = M(C.prototype);
            return e._k = t, e
        },
        Y = N && "symbol" == typeof C.iterator ? function(t) {
            return "symbol" == typeof t
        } : function(t) {
            return t instanceof C
        },
        X = function(t, e, n) {
            return t === B && X(U, e, n), y(t), e = w(e, !0), y(n), i(k, e) ? (n.enumerable ? (i(t, D) && t[D][e] && (t[D][e] = !1), n = M(n, {
                enumerable: _(0, !1)
            })) : (i(t, D) || A(t, D, _(1, {})), t[D][e] = !0), V(t, e, n)) : A(t, e, n)
        },
        q = function(t, e) {
            y(t);
            for (var n, r = m(e = b(e)), i = 0, o = r.length; o > i;) X(t, n = r[i++], e[n]);
            return t
        },
        K = function(t) {
            var e = F.call(this, t = w(t, !0));
            return !(this === B && i(k, t) && !i(U, t)) && (!(e || !i(this, t) || !i(k, t) || i(this, D) && this[D][t]) || e)
        },
        Z = function(t, e) {
            if (t = b(t), e = w(e, !0), t !== B || !i(k, e) || i(U, e)) {
                var n = L(t, e);
                return !n || !i(k, e) || i(t, D) && t[D][e] || (n.enumerable = !0), n
            }
        },
        J = function(t) {
            for (var e, n = z(b(t)), r = [], o = 0; n.length > o;) i(k, e = n[o++]) || e == D || e == c || r.push(e);
            return r
        },
        Q = function(t) {
            for (var e, n = t === B, r = z(n ? U : b(t)), o = [], a = 0; r.length > a;) !i(k, e = r[a++]) || n && !i(B, e) || o.push(k[e]);
            return o
        };
    N || (s((C = function() {
        if (this instanceof C) throw TypeError("Symbol is not a constructor!");
        var t = f(arguments.length > 0 ? arguments[0] : void 0),
            e = function(n) {
                this === B && e.call(U, n), i(this, D) && i(this[D], t) && (this[D][t] = !1), V(this, t, _(1, n))
            };
        return o && H && V(B, t, {
            configurable: !0,
            set: e
        }), W(t)
    }).prototype, "toString", function() {
        return this._k
    }), E.f = Z, T.f = X, n(40).f = S.f = J, n(51).f = K, n(53).f = Q, o && !n(36) && s(B, "propertyIsEnumerable", K, !0), v.f = function(t) {
        return W(d(t))
    }), a(a.G + a.W + a.F * !N, {
        Symbol: C
    });
    for (var $ = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), tt = 0; $.length > tt;) d($[tt++]);
    for (var et = P(d.store), nt = 0; et.length > nt;) p(et[nt++]);
    a(a.S + a.F * !N, "Symbol", {
        for: function(t) {
            return i(j, t += "") ? j[t] : j[t] = C(t)
        },
        keyFor: function(t) {
            if (!Y(t)) throw TypeError(t + " is not a symbol!");
            for (var e in j)
                if (j[e] === t) return e
        },
        useSetter: function() {
            H = !0
        },
        useSimple: function() {
            H = !1
        }
    }), a(a.S + a.F * !N, "Object", {
        create: function(t, e) {
            return void 0 === e ? M(t) : q(M(t), e)
        },
        defineProperty: X,
        defineProperties: q,
        getOwnPropertyDescriptor: Z,
        getOwnPropertyNames: J,
        getOwnPropertySymbols: Q
    }), R && a(a.S + a.F * (!N || u(function() {
        var t = C();
        return "[null]" != I([t]) || "{}" != I({
            a: t
        }) || "{}" != I(Object(t))
    })), "JSON", {
        stringify: function(t) {
            for (var e, n, r = [t], i = 1; arguments.length > i;) r.push(arguments[i++]);
            if (n = e = r[1], (x(e) || void 0 !== t) && !Y(t)) return g(e) || (e = function(t, e) {
                if ("function" == typeof n && (e = n.call(this, t, e)), !Y(e)) return e
            }), r[1] = e, I.apply(R, r)
        }
    }), C.prototype[O] || n(18)(C.prototype, O, C.prototype.valueOf), h(C, "Symbol"), h(Math, "Math", !0), h(r.JSON, "JSON", !0)
}, function(t, e, n) {
    var r = n(37),
        i = n(53),
        o = n(51);
    t.exports = function(t) {
        var e = r(t),
            n = i.f;
        if (n)
            for (var a, s = n(t), c = o.f, u = 0; s.length > u;) c.call(t, a = s[u++]) && e.push(a);
        return e
    }
}, function(t, e, n) {
    var r = n(1);
    r(r.S, "Object", {
        create: n(39)
    })
}, function(t, e, n) {
    var r = n(1);
    r(r.S + r.F * !n(10), "Object", {
        defineProperty: n(9).f
    })
}, function(t, e, n) {
    var r = n(1);
    r(r.S + r.F * !n(10), "Object", {
        defineProperties: n(105)
    })
}, function(t, e, n) {
    var r = n(19),
        i = n(22).f;
    n(23)("getOwnPropertyDescriptor", function() {
        return function(t, e) {
            return i(r(t), e)
        }
    })
}, function(t, e, n) {
    var r = n(20),
        i = n(41);
    n(23)("getPrototypeOf", function() {
        return function(t) {
            return i(r(t))
        }
    })
}, function(t, e, n) {
    var r = n(20),
        i = n(37);
    n(23)("keys", function() {
        return function(t) {
            return i(r(t))
        }
    })
}, function(t, e, n) {
    n(23)("getOwnPropertyNames", function() {
        return n(106).f
    })
}, function(t, e, n) {
    var r = n(6),
        i = n(33).onFreeze;
    n(23)("freeze", function(t) {
        return function(e) {
            return t && r(e) ? t(i(e)) : e
        }
    })
}, function(t, e, n) {
    var r = n(6),
        i = n(33).onFreeze;
    n(23)("seal", function(t) {
        return function(e) {
            return t && r(e) ? t(i(e)) : e
        }
    })
}, function(t, e, n) {
    var r = n(6),
        i = n(33).onFreeze;
    n(23)("preventExtensions", function(t) {
        return function(e) {
            return t && r(e) ? t(i(e)) : e
        }
    })
}, function(t, e, n) {
    var r = n(6);
    n(23)("isFrozen", function(t) {
        return function(e) {
            return !r(e) || !!t && t(e)
        }
    })
}, function(t, e, n) {
    var r = n(6);
    n(23)("isSealed", function(t) {
        return function(e) {
            return !r(e) || !!t && t(e)
        }
    })
}, function(t, e, n) {
    var r = n(6);
    n(23)("isExtensible", function(t) {
        return function(e) {
            return !!r(e) && (!t || t(e))
        }
    })
}, function(t, e, n) {
    var r = n(1);
    r(r.S + r.F, "Object", {
        assign: n(107)
    })
}, function(t, e, n) {
    var r = n(1);
    r(r.S, "Object", {
        is: n(161)
    })
}, function(t, e) {
    t.exports = Object.is || function(t, e) {
        return t === e ? 0 !== t || 1 / t == 1 / e : t != t && e != e
    }
}, function(t, e, n) {
    var r = n(1);
    r(r.S, "Object", {
        setPrototypeOf: n(76).set
    })
}, function(t, e, n) {
    "use strict";
    var r = n(54),
        i = {};
    i[n(8)("toStringTag")] = "z", i + "" != "[object z]" && n(15)(Object.prototype, "toString", function() {
        return "[object " + r(this) + "]"
    }, !0)
}, function(t, e, n) {
    var r = n(1);
    r(r.P, "Function", {
        bind: n(108)
    })
}, function(t, e, n) {
    var r = n(9).f,
        i = Function.prototype,
        o = /^\s*function ([^ (]*)/;
    "name" in i || n(10) && r(i, "name", {
        configurable: !0,
        get: function() {
            try {
                return ("" + this).match(o)[1]
            } catch (t) {
                return ""
            }
        }
    })
}, function(t, e, n) {
    "use strict";
    var r = n(6),
        i = n(41),
        o = n(8)("hasInstance"),
        a = Function.prototype;
    o in a || n(9).f(a, o, {
        value: function(t) {
            if ("function" != typeof this || !r(t)) return !1;
            if (!r(this.prototype)) return t instanceof this;
            for (; t = i(t);)
                if (this.prototype === t) return !0;
            return !1
        }
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(110);
    r(r.G + r.F * (parseInt != i), {
        parseInt: i
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(111);
    r(r.G + r.F * (parseFloat != i), {
        parseFloat: i
    })
}, function(t, e, n) {
    "use strict";
    var r = n(5),
        i = n(17),
        o = n(27),
        a = n(78),
        s = n(32),
        c = n(4),
        u = n(40).f,
        l = n(22).f,
        h = n(9).f,
        f = n(55).trim,
        d = r.Number,
        v = d,
        p = d.prototype,
        m = "Number" == o(n(39)(p)),
        g = "trim" in String.prototype,
        y = function(t) {
            var e = s(t, !1);
            if ("string" == typeof e && e.length > 2) {
                var n, r, i, o = (e = g ? e.trim() : f(e, 3)).charCodeAt(0);
                if (43 === o || 45 === o) {
                    if (88 === (n = e.charCodeAt(2)) || 120 === n) return NaN
                } else if (48 === o) {
                    switch (e.charCodeAt(1)) {
                        case 66:
                        case 98:
                            r = 2, i = 49;
                            break;
                        case 79:
                        case 111:
                            r = 8, i = 55;
                            break;
                        default:
                            return +e
                    }
                    for (var a, c = e.slice(2), u = 0, l = c.length; u < l; u++)
                        if ((a = c.charCodeAt(u)) < 48 || a > i) return NaN;
                    return parseInt(c, r)
                }
            }
            return +e
        };
    if (!d(" 0o1") || !d("0b1") || d("+0x1")) {
        d = function(t) {
            var e = arguments.length < 1 ? 0 : t,
                n = this;
            return n instanceof d && (m ? c(function() {
                p.valueOf.call(n)
            }) : "Number" != o(n)) ? a(new v(y(e)), n, d) : y(e)
        };
        for (var x, b = n(10) ? u(v) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), w = 0; b.length > w; w++) i(v, x = b[w]) && !i(d, x) && h(d, x, l(v, x));
        d.prototype = p, p.constructor = d, n(15)(r, "Number", d)
    }
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(29),
        o = n(112),
        a = n(79),
        s = 1..toFixed,
        c = Math.floor,
        u = [0, 0, 0, 0, 0, 0],
        l = "Number.toFixed: incorrect invocation!",
        h = function(t, e) {
            for (var n = -1, r = e; ++n < 6;) r += t * u[n], u[n] = r % 1e7, r = c(r / 1e7)
        },
        f = function(t) {
            for (var e = 6, n = 0; --e >= 0;) n += u[e], u[e] = c(n / t), n = n % t * 1e7
        },
        d = function() {
            for (var t = 6, e = ""; --t >= 0;)
                if ("" !== e || 0 === t || 0 !== u[t]) {
                    var n = String(u[t]);
                    e = "" === e ? n : e + a.call("0", 7 - n.length) + n
                }
            return e
        },
        v = function(t, e, n) {
            return 0 === e ? n : e % 2 == 1 ? v(t, e - 1, n * t) : v(t * t, e / 2, n)
        };
    r(r.P + r.F * (!!s && ("0.000" !== 8e-5.toFixed(3) || "1" !== .9. toFixed(0) || "1.25" !== 1.255.toFixed(2) || "1000000000000000128" !== (0xde0b6b3a7640080).toFixed(0)) || !n(4)(function() {
        s.call({})
    })), "Number", {
        toFixed: function(t) {
            var e, n, r, s, c = o(this, l),
                u = i(t),
                p = "",
                m = "0";
            if (u < 0 || u > 20) throw RangeError(l);
            if (c != c) return "NaN";
            if (c <= -1e21 || c >= 1e21) return String(c);
            if (c < 0 && (p = "-", c = -c), c > 1e-21)
                if (n = (e = function(t) {
                        for (var e = 0, n = t; n >= 4096;) e += 12, n /= 4096;
                        for (; n >= 2;) e += 1, n /= 2;
                        return e
                    }(c * v(2, 69, 1)) - 69) < 0 ? c * v(2, -e, 1) : c / v(2, e, 1), n *= 4503599627370496, (e = 52 - e) > 0) {
                    for (h(0, n), r = u; r >= 7;) h(1e7, 0), r -= 7;
                    for (h(v(10, r, 1), 0), r = e - 1; r >= 23;) f(1 << 23), r -= 23;
                    f(1 << r), h(1, 1), f(2), m = d()
                } else h(0, n), h(1 << -e, 0), m = d() + a.call("0", u);
            return m = u > 0 ? p + ((s = m.length) <= u ? "0." + a.call("0", u - s) + m : m.slice(0, s - u) + "." + m.slice(s - u)) : p + m
        }
    })
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(4),
        o = n(112),
        a = 1..toPrecision;
    r(r.P + r.F * (i(function() {
        return "1" !== a.call(1, void 0)
    }) || !i(function() {
        a.call({})
    })), "Number", {
        toPrecision: function(t) {
            var e = o(this, "Number#toPrecision: incorrect invocation!");
            return void 0 === t ? a.call(e) : a.call(e, t)
        }
    })
}, function(t, e, n) {
    var r = n(1);
    r(r.S, "Number", {
        EPSILON: Math.pow(2, -52)
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(5).isFinite;
    r(r.S, "Number", {
        isFinite: function(t) {
            return "number" == typeof t && i(t)
        }
    })
}, function(t, e, n) {
    var r = n(1);
    r(r.S, "Number", {
        isInteger: n(113)
    })
}, function(t, e, n) {
    var r = n(1);
    r(r.S, "Number", {
        isNaN: function(t) {
            return t != t
        }
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(113),
        o = Math.abs;
    r(r.S, "Number", {
        isSafeInteger: function(t) {
            return i(t) && o(t) <= 9007199254740991
        }
    })
}, function(t, e, n) {
    var r = n(1);
    r(r.S, "Number", {
        MAX_SAFE_INTEGER: 9007199254740991
    })
}, function(t, e, n) {
    var r = n(1);
    r(r.S, "Number", {
        MIN_SAFE_INTEGER: -9007199254740991
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(111);
    r(r.S + r.F * (Number.parseFloat != i), "Number", {
        parseFloat: i
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(110);
    r(r.S + r.F * (Number.parseInt != i), "Number", {
        parseInt: i
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(114),
        o = Math.sqrt,
        a = Math.acosh;
    r(r.S + r.F * !(a && 710 == Math.floor(a(Number.MAX_VALUE)) && a(1 / 0) == 1 / 0), "Math", {
        acosh: function(t) {
            return (t = +t) < 1 ? NaN : t > 94906265.62425156 ? Math.log(t) + Math.LN2 : i(t - 1 + o(t - 1) * o(t + 1))
        }
    })
}, function(t, e, n) {
    var r = n(1),
        i = Math.asinh;
    r(r.S + r.F * !(i && 1 / i(0) > 0), "Math", {
        asinh: function t(e) {
            return isFinite(e = +e) && 0 != e ? e < 0 ? -t(-e) : Math.log(e + Math.sqrt(e * e + 1)) : e
        }
    })
}, function(t, e, n) {
    var r = n(1),
        i = Math.atanh;
    r(r.S + r.F * !(i && 1 / i(-0) < 0), "Math", {
        atanh: function(t) {
            return 0 == (t = +t) ? t : Math.log((1 + t) / (1 - t)) / 2
        }
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(80);
    r(r.S, "Math", {
        cbrt: function(t) {
            return i(t = +t) * Math.pow(Math.abs(t), 1 / 3)
        }
    })
}, function(t, e, n) {
    var r = n(1);
    r(r.S, "Math", {
        clz32: function(t) {
            return (t >>>= 0) ? 31 - Math.floor(Math.log(t + .5) * Math.LOG2E) : 32
        }
    })
}, function(t, e, n) {
    var r = n(1),
        i = Math.exp;
    r(r.S, "Math", {
        cosh: function(t) {
            return (i(t = +t) + i(-t)) / 2
        }
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(81);
    r(r.S + r.F * (i != Math.expm1), "Math", {
        expm1: i
    })
}, function(t, e, n) {
    var r = n(1);
    r(r.S, "Math", {
        fround: n(189)
    })
}, function(t, e, n) {
    var r = n(80),
        i = Math.pow,
        o = i(2, -52),
        a = i(2, -23),
        s = i(2, 127) * (2 - a),
        c = i(2, -126);
    t.exports = Math.fround || function(t) {
        var e, n, i = Math.abs(t),
            u = r(t);
        return i < c ? u * function(t) {
            return t + 1 / o - 1 / o
        }(i / c / a) * c * a : (n = (e = (1 + a / o) * i) - (e - i)) > s || n != n ? u * (1 / 0) : u * n
    }
}, function(t, e, n) {
    var r = n(1),
        i = Math.abs;
    r(r.S, "Math", {
        hypot: function(t, e) {
            for (var n, r, o = 0, a = 0, s = arguments.length, c = 0; a < s;) c < (n = i(arguments[a++])) ? (o = o * (r = c / n) * r + 1, c = n) : o += n > 0 ? (r = n / c) * r : n;
            return c === 1 / 0 ? 1 / 0 : c * Math.sqrt(o)
        }
    })
}, function(t, e, n) {
    var r = n(1),
        i = Math.imul;
    r(r.S + r.F * n(4)(function() {
        return -5 != i(4294967295, 5) || 2 != i.length
    }), "Math", {
        imul: function(t, e) {
            var n = +t,
                r = +e,
                i = 65535 & n,
                o = 65535 & r;
            return 0 | i * o + ((65535 & n >>> 16) * o + i * (65535 & r >>> 16) << 16 >>> 0)
        }
    })
}, function(t, e, n) {
    var r = n(1);
    r(r.S, "Math", {
        log10: function(t) {
            return Math.log(t) * Math.LOG10E
        }
    })
}, function(t, e, n) {
    var r = n(1);
    r(r.S, "Math", {
        log1p: n(114)
    })
}, function(t, e, n) {
    var r = n(1);
    r(r.S, "Math", {
        log2: function(t) {
            return Math.log(t) / Math.LN2
        }
    })
}, function(t, e, n) {
    var r = n(1);
    r(r.S, "Math", {
        sign: n(80)
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(81),
        o = Math.exp;
    r(r.S + r.F * n(4)(function() {
        return -2e-17 != !Math.sinh(-2e-17)
    }), "Math", {
        sinh: function(t) {
            return Math.abs(t = +t) < 1 ? (i(t) - i(-t)) / 2 : (o(t - 1) - o(-t - 1)) * (Math.E / 2)
        }
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(81),
        o = Math.exp;
    r(r.S, "Math", {
        tanh: function(t) {
            var e = i(t = +t),
                n = i(-t);
            return e == 1 / 0 ? 1 : n == 1 / 0 ? -1 : (e - n) / (o(t) + o(-t))
        }
    })
}, function(t, e, n) {
    var r = n(1);
    r(r.S, "Math", {
        trunc: function(t) {
            return (t > 0 ? Math.floor : Math.ceil)(t)
        }
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(38),
        o = String.fromCharCode,
        a = String.fromCodePoint;
    r(r.S + r.F * (!!a && 1 != a.length), "String", {
        fromCodePoint: function(t) {
            for (var e, n = [], r = arguments.length, a = 0; r > a;) {
                if (e = +arguments[a++], i(e, 1114111) !== e) throw RangeError(e + " is not a valid code point");
                n.push(e < 65536 ? o(e) : o(55296 + ((e -= 65536) >> 10), e % 1024 + 56320))
            }
            return n.join("")
        }
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(19),
        o = n(12);
    r(r.S, "String", {
        raw: function(t) {
            for (var e = i(t.raw), n = o(e.length), r = arguments.length, a = [], s = 0; n > s;) a.push(String(e[s++])), s < r && a.push(String(arguments[s]));
            return a.join("")
        }
    })
}, function(t, e, n) {
    "use strict";
    n(55)("trim", function(t) {
        return function() {
            return t(this, 3)
        }
    })
}, function(t, e, n) {
    "use strict";
    var r = n(115)(!0);
    n(82)(String, "String", function(t) {
        this._t = String(t), this._i = 0
    }, function() {
        var t, e = this._t,
            n = this._i;
        return n >= e.length ? {
            value: void 0,
            done: !0
        } : (t = r(e, n), this._i += t.length, {
            value: t,
            done: !1
        })
    })
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(115)(!1);
    r(r.P, "String", {
        codePointAt: function(t) {
            return i(this, t)
        }
    })
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(12),
        o = n(83),
        a = "".endsWith;
    r(r.P + r.F * n(85)("endsWith"), "String", {
        endsWith: function(t) {
            var e = o(this, t, "endsWith"),
                n = arguments.length > 1 ? arguments[1] : void 0,
                r = i(e.length),
                s = void 0 === n ? r : Math.min(i(n), r),
                c = String(t);
            return a ? a.call(e, c, s) : e.slice(s - c.length, s) === c
        }
    })
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(83);
    r(r.P + r.F * n(85)("includes"), "String", {
        includes: function(t) {
            return !!~i(this, t, "includes").indexOf(t, arguments.length > 1 ? arguments[1] : void 0)
        }
    })
}, function(t, e, n) {
    var r = n(1);
    r(r.P, "String", {
        repeat: n(79)
    })
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(12),
        o = n(83),
        a = "".startsWith;
    r(r.P + r.F * n(85)("startsWith"), "String", {
        startsWith: function(t) {
            var e = o(this, t, "startsWith"),
                n = i(Math.min(arguments.length > 1 ? arguments[1] : void 0, e.length)),
                r = String(t);
            return a ? a.call(e, r, n) : e.slice(n, n + r.length) === r
        }
    })
}, function(t, e, n) {
    "use strict";
    n(16)("anchor", function(t) {
        return function(e) {
            return t(this, "a", "name", e)
        }
    })
}, function(t, e, n) {
    "use strict";
    n(16)("big", function(t) {
        return function() {
            return t(this, "big", "", "")
        }
    })
}, function(t, e, n) {
    "use strict";
    n(16)("blink", function(t) {
        return function() {
            return t(this, "blink", "", "")
        }
    })
}, function(t, e, n) {
    "use strict";
    n(16)("bold", function(t) {
        return function() {
            return t(this, "b", "", "")
        }
    })
}, function(t, e, n) {
    "use strict";
    n(16)("fixed", function(t) {
        return function() {
            return t(this, "tt", "", "")
        }
    })
}, function(t, e, n) {
    "use strict";
    n(16)("fontcolor", function(t) {
        return function(e) {
            return t(this, "font", "color", e)
        }
    })
}, function(t, e, n) {
    "use strict";
    n(16)("fontsize", function(t) {
        return function(e) {
            return t(this, "font", "size", e)
        }
    })
}, function(t, e, n) {
    "use strict";
    n(16)("italics", function(t) {
        return function() {
            return t(this, "i", "", "")
        }
    })
}, function(t, e, n) {
    "use strict";
    n(16)("link", function(t) {
        return function(e) {
            return t(this, "a", "href", e)
        }
    })
}, function(t, e, n) {
    "use strict";
    n(16)("small", function(t) {
        return function() {
            return t(this, "small", "", "")
        }
    })
}, function(t, e, n) {
    "use strict";
    n(16)("strike", function(t) {
        return function() {
            return t(this, "strike", "", "")
        }
    })
}, function(t, e, n) {
    "use strict";
    n(16)("sub", function(t) {
        return function() {
            return t(this, "sub", "", "")
        }
    })
}, function(t, e, n) {
    "use strict";
    n(16)("sup", function(t) {
        return function() {
            return t(this, "sup", "", "")
        }
    })
}, function(t, e, n) {
    var r = n(1);
    r(r.S, "Date", {
        now: function() {
            return (new Date).getTime()
        }
    })
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(20),
        o = n(32);
    r(r.P + r.F * n(4)(function() {
        return null !== new Date(NaN).toJSON() || 1 !== Date.prototype.toJSON.call({
            toISOString: function() {
                return 1
            }
        })
    }), "Date", {
        toJSON: function(t) {
            var e = i(this),
                n = o(e);
            return "number" != typeof n || isFinite(n) ? e.toISOString() : null
        }
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(224);
    r(r.P + r.F * (Date.prototype.toISOString !== i), "Date", {
        toISOString: i
    })
}, function(t, e, n) {
    "use strict";
    var r = n(4),
        i = Date.prototype.getTime,
        o = Date.prototype.toISOString,
        a = function(t) {
            return t > 9 ? t : "0" + t
        };
    t.exports = r(function() {
        return "0385-07-25T07:06:39.999Z" != o.call(new Date(-5e13 - 1))
    }) || !r(function() {
        o.call(new Date(NaN))
    }) ? function() {
        if (!isFinite(i.call(this))) throw RangeError("Invalid time value");
        var t = this,
            e = t.getUTCFullYear(),
            n = t.getUTCMilliseconds(),
            r = e < 0 ? "-" : e > 9999 ? "+" : "";
        return r + ("00000" + Math.abs(e)).slice(r ? -6 : -4) + "-" + a(t.getUTCMonth() + 1) + "-" + a(t.getUTCDate()) + "T" + a(t.getUTCHours()) + ":" + a(t.getUTCMinutes()) + ":" + a(t.getUTCSeconds()) + "." + (n > 99 ? n : "0" + a(n)) + "Z"
    } : o
}, function(t, e, n) {
    var r = Date.prototype,
        i = r.toString,
        o = r.getTime;
    new Date(NaN) + "" != "Invalid Date" && n(15)(r, "toString", function() {
        var t = o.call(this);
        return t == t ? i.call(this) : "Invalid Date"
    })
}, function(t, e, n) {
    var r = n(8)("toPrimitive"),
        i = Date.prototype;
    r in i || n(18)(i, r, n(227))
}, function(t, e, n) {
    "use strict";
    var r = n(7),
        i = n(32);
    t.exports = function(t) {
        if ("string" !== t && "number" !== t && "default" !== t) throw TypeError("Incorrect hint");
        return i(r(this), "number" != t)
    }
}, function(t, e, n) {
    var r = n(1);
    r(r.S, "Array", {
        isArray: n(74)
    })
}, function(t, e, n) {
    "use strict";
    var r = n(25),
        i = n(1),
        o = n(20),
        a = n(117),
        s = n(86),
        c = n(12),
        u = n(87),
        l = n(88);
    i(i.S + i.F * !n(56)(function(t) {
        Array.from(t)
    }), "Array", {
        from: function(t) {
            var e, n, i, h, f = o(t),
                d = "function" == typeof this ? this : Array,
                v = arguments.length,
                p = v > 1 ? arguments[1] : void 0,
                m = void 0 !== p,
                g = 0,
                y = l(f);
            if (m && (p = r(p, v > 2 ? arguments[2] : void 0, 2)), void 0 == y || d == Array && s(y))
                for (n = new d(e = c(f.length)); e > g; g++) u(n, g, m ? p(f[g], g) : f[g]);
            else
                for (h = y.call(f), n = new d; !(i = h.next()).done; g++) u(n, g, m ? a(h, p, [i.value, g], !0) : i.value);
            return n.length = g, n
        }
    })
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(87);
    r(r.S + r.F * n(4)(function() {
        function t() {}
        return !(Array.of.call(t) instanceof t)
    }), "Array", {
        of: function() {
            for (var t = 0, e = arguments.length, n = new("function" == typeof this ? this : Array)(e); e > t;) i(n, t, arguments[t++]);
            return n.length = e, n
        }
    })
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(19),
        o = [].join;
    r(r.P + r.F * (n(50) != Object || !n(21)(o)), "Array", {
        join: function(t) {
            return o.call(i(this), void 0 === t ? "," : t)
        }
    })
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(75),
        o = n(27),
        a = n(38),
        s = n(12),
        c = [].slice;
    r(r.P + r.F * n(4)(function() {
        i && c.call(i)
    }), "Array", {
        slice: function(t, e) {
            var n = s(this.length),
                r = o(this);
            if (e = void 0 === e ? n : e, "Array" == r) return c.call(this, t, e);
            for (var i = a(t, n), u = a(e, n), l = s(u - i), h = new Array(l), f = 0; f < l; f++) h[f] = "String" == r ? this.charAt(i + f) : this[i + f];
            return h
        }
    })
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(26),
        o = n(20),
        a = n(4),
        s = [].sort,
        c = [1, 2, 3];
    r(r.P + r.F * (a(function() {
        c.sort(void 0)
    }) || !a(function() {
        c.sort(null)
    }) || !n(21)(s)), "Array", {
        sort: function(t) {
            return void 0 === t ? s.call(o(this)) : s.call(o(this), i(t))
        }
    })
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(24)(0),
        o = n(21)([].forEach, !0);
    r(r.P + r.F * !o, "Array", {
        forEach: function(t) {
            return i(this, t, arguments[1])
        }
    })
}, function(t, e, n) {
    var r = n(236);
    t.exports = function(t, e) {
        return new(r(t))(e)
    }
}, function(t, e, n) {
    var r = n(6),
        i = n(74),
        o = n(8)("species");
    t.exports = function(t) {
        var e;
        return i(t) && ("function" != typeof(e = t.constructor) || e !== Array && !i(e.prototype) || (e = void 0), r(e) && null === (e = e[o]) && (e = void 0)), void 0 === e ? Array : e
    }
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(24)(1);
    r(r.P + r.F * !n(21)([].map, !0), "Array", {
        map: function(t) {
            return i(this, t, arguments[1])
        }
    })
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(24)(2);
    r(r.P + r.F * !n(21)([].filter, !0), "Array", {
        filter: function(t) {
            return i(this, t, arguments[1])
        }
    })
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(24)(3);
    r(r.P + r.F * !n(21)([].some, !0), "Array", {
        some: function(t) {
            return i(this, t, arguments[1])
        }
    })
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(24)(4);
    r(r.P + r.F * !n(21)([].every, !0), "Array", {
        every: function(t) {
            return i(this, t, arguments[1])
        }
    })
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(118);
    r(r.P + r.F * !n(21)([].reduce, !0), "Array", {
        reduce: function(t) {
            return i(this, t, arguments.length, arguments[1], !1)
        }
    })
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(118);
    r(r.P + r.F * !n(21)([].reduceRight, !0), "Array", {
        reduceRight: function(t) {
            return i(this, t, arguments.length, arguments[1], !0)
        }
    })
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(52)(!1),
        o = [].indexOf,
        a = !!o && 1 / [1].indexOf(1, -0) < 0;
    r(r.P + r.F * (a || !n(21)(o)), "Array", {
        indexOf: function(t) {
            return a ? o.apply(this, arguments) || 0 : i(this, t, arguments[1])
        }
    })
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(19),
        o = n(29),
        a = n(12),
        s = [].lastIndexOf,
        c = !!s && 1 / [1].lastIndexOf(1, -0) < 0;
    r(r.P + r.F * (c || !n(21)(s)), "Array", {
        lastIndexOf: function(t) {
            if (c) return s.apply(this, arguments) || 0;
            var e = i(this),
                n = a(e.length),
                r = n - 1;
            for (arguments.length > 1 && (r = Math.min(r, o(arguments[1]))), r < 0 && (r = n + r); r >= 0; r--)
                if (r in e && e[r] === t) return r || 0;
            return -1
        }
    })
}, function(t, e, n) {
    var r = n(1);
    r(r.P, "Array", {
        copyWithin: n(119)
    }), n(45)("copyWithin")
}, function(t, e, n) {
    var r = n(1);
    r(r.P, "Array", {
        fill: n(89)
    }), n(45)("fill")
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(24)(5),
        o = !0;
    "find" in [] && Array(1).find(function() {
        o = !1
    }), r(r.P + r.F * o, "Array", {
        find: function(t) {
            return i(this, t, arguments.length > 1 ? arguments[1] : void 0)
        }
    }), n(45)("find")
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(24)(6),
        o = "findIndex",
        a = !0;
    o in [] && Array(1)[o](function() {
        a = !1
    }), r(r.P + r.F * a, "Array", {
        findIndex: function(t) {
            return i(this, t, arguments.length > 1 ? arguments[1] : void 0)
        }
    }), n(45)(o)
}, function(t, e, n) {
    n(46)("Array")
}, function(t, e, n) {
    var r = n(5),
        i = n(78),
        o = n(9).f,
        a = n(40).f,
        s = n(84),
        c = n(91),
        u = r.RegExp,
        l = u,
        h = u.prototype,
        f = /a/g,
        d = /a/g,
        v = new u(f) !== f;
    if (n(10) && (!v || n(4)(function() {
            return d[n(8)("match")] = !1, u(f) != f || u(d) == d || "/a/i" != u(f, "i")
        }))) {
        u = function(t, e) {
            var n = this instanceof u,
                r = s(t),
                o = void 0 === e;
            return !n && r && t.constructor === u && o ? t : i(v ? new l(r && !o ? t.source : t, e) : l((r = t instanceof u) ? t.source : t, r && o ? c.call(t) : e), n ? this : h, u)
        };
        for (var p = function(t) {
                t in u || o(u, t, {
                    configurable: !0,
                    get: function() {
                        return l[t]
                    },
                    set: function(e) {
                        l[t] = e
                    }
                })
            }, m = a(l), g = 0; m.length > g;) p(m[g++]);
        h.constructor = u, u.prototype = h, n(15)(r, "RegExp", u)
    }
    n(46)("RegExp")
}, function(t, e, n) {
    "use strict";
    n(121);
    var r = n(7),
        i = n(91),
        o = n(10),
        a = /./.toString,
        s = function(t) {
            n(15)(RegExp.prototype, "toString", t, !0)
        };
    n(4)(function() {
        return "/a/b" != a.call({
            source: "a",
            flags: "b"
        })
    }) ? s(function() {
        var t = r(this);
        return "/".concat(t.source, "/", "flags" in t ? t.flags : !o && t instanceof RegExp ? i.call(t) : void 0)
    }) : "toString" != a.name && s(function() {
        return a.call(this)
    })
}, function(t, e, n) {
    n(57)("match", 1, function(t, e, n) {
        return [function(n) {
            "use strict";
            var r = t(this),
                i = void 0 == n ? void 0 : n[e];
            return void 0 !== i ? i.call(n, r) : new RegExp(n)[e](String(r))
        }, n]
    })
}, function(t, e, n) {
    n(57)("replace", 2, function(t, e, n) {
        return [function(r, i) {
            "use strict";
            var o = t(this),
                a = void 0 == r ? void 0 : r[e];
            return void 0 !== a ? a.call(r, o, i) : n.call(String(o), r, i)
        }, n]
    })
}, function(t, e, n) {
    n(57)("search", 1, function(t, e, n) {
        return [function(n) {
            "use strict";
            var r = t(this),
                i = void 0 == n ? void 0 : n[e];
            return void 0 !== i ? i.call(n, r) : new RegExp(n)[e](String(r))
        }, n]
    })
}, function(t, e, n) {
    n(57)("split", 2, function(t, e, r) {
        "use strict";
        var i = n(84),
            o = r,
            a = [].push;
        if ("c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length) {
            var s = void 0 === /()??/.exec("")[1];
            r = function(t, e) {
                var n = String(this);
                if (void 0 === t && 0 === e) return [];
                if (!i(t)) return o.call(n, t, e);
                var r, c, u, l, h, f = [],
                    d = (t.ignoreCase ? "i" : "") + (t.multiline ? "m" : "") + (t.unicode ? "u" : "") + (t.sticky ? "y" : ""),
                    v = 0,
                    p = void 0 === e ? 4294967295 : e >>> 0,
                    m = new RegExp(t.source, d + "g");
                for (s || (r = new RegExp("^" + m.source + "$(?!\\s)", d));
                    (c = m.exec(n)) && !((u = c.index + c[0].length) > v && (f.push(n.slice(v, c.index)), !s && c.length > 1 && c[0].replace(r, function() {
                        for (h = 1; h < arguments.length - 2; h++) void 0 === arguments[h] && (c[h] = void 0)
                    }), c.length > 1 && c.index < n.length && a.apply(f, c.slice(1)), l = c[0].length, v = u, f.length >= p));) m.lastIndex === c.index && m.lastIndex++;
                return v === n.length ? !l && m.test("") || f.push("") : f.push(n.slice(v)), f.length > p ? f.slice(0, p) : f
            }
        } else "0".split(void 0, 0).length && (r = function(t, e) {
            return void 0 === t && 0 === e ? [] : o.call(this, t, e)
        });
        return [function(n, i) {
            var o = t(this),
                a = void 0 == n ? void 0 : n[e];
            return void 0 !== a ? a.call(n, o, i) : r.call(String(o), n, i)
        }, r]
    })
}, function(t, e, n) {
    var r = n(5),
        i = n(92).set,
        o = r.MutationObserver || r.WebKitMutationObserver,
        a = r.process,
        s = r.Promise,
        c = "process" == n(27)(a);
    t.exports = function() {
        var t, e, n, u = function() {
            var r, i;
            for (c && (r = a.domain) && r.exit(); t;) {
                i = t.fn, t = t.next;
                try {
                    i()
                } catch (r) {
                    throw t ? n() : e = void 0, r
                }
            }
            e = void 0, r && r.enter()
        };
        if (c) n = function() {
            a.nextTick(u)
        };
        else if (!o || r.navigator && r.navigator.standalone)
            if (s && s.resolve) {
                var l = s.resolve(void 0);
                n = function() {
                    l.then(u)
                }
            } else n = function() {
                i.call(r, u)
            };
        else {
            var h = !0,
                f = document.createTextNode("");
            new o(u).observe(f, {
                characterData: !0
            }), n = function() {
                f.data = h = !h
            }
        }
        return function(r) {
            var i = {
                fn: r,
                next: void 0
            };
            e && (e.next = i), t || (t = i, n()), e = i
        }
    }
}, function(t, e) {
    t.exports = function(t) {
        try {
            return {
                e: !1,
                v: t()
            }
        } catch (t) {
            return {
                e: !0,
                v: t
            }
        }
    }
}, function(t, e, n) {
    "use strict";
    var r = n(125),
        i = n(49);
    t.exports = n(61)("Map", function(t) {
        return function() {
            return t(this, arguments.length > 0 ? arguments[0] : void 0)
        }
    }, {
        get: function(t) {
            var e = r.getEntry(i(this, "Map"), t);
            return e && e.v
        },
        set: function(t, e) {
            return r.def(i(this, "Map"), 0 === t ? 0 : t, e)
        }
    }, r, !0)
}, function(t, e, n) {
    "use strict";
    var r = n(125),
        i = n(49);
    t.exports = n(61)("Set", function(t) {
        return function() {
            return t(this, arguments.length > 0 ? arguments[0] : void 0)
        }
    }, {
        add: function(t) {
            return r.def(i(this, "Set"), t = 0 === t ? 0 : t, t)
        }
    }, r)
}, function(t, e, n) {
    "use strict";
    var r, i = n(24)(0),
        o = n(15),
        a = n(33),
        s = n(107),
        c = n(126),
        u = n(6),
        l = n(4),
        h = n(49),
        f = a.getWeak,
        d = Object.isExtensible,
        v = c.ufstore,
        p = {},
        m = function(t) {
            return function() {
                return t(this, arguments.length > 0 ? arguments[0] : void 0)
            }
        },
        g = {
            get: function(t) {
                if (u(t)) {
                    var e = f(t);
                    return !0 === e ? v(h(this, "WeakMap")).get(t) : e ? e[this._i] : void 0
                }
            },
            set: function(t, e) {
                return c.def(h(this, "WeakMap"), t, e)
            }
        },
        y = t.exports = n(61)("WeakMap", m, g, c, !0, !0);
    l(function() {
        return 7 != (new y).set((Object.freeze || Object)(p), 7).get(p)
    }) && (s((r = c.getConstructor(m, "WeakMap")).prototype, g), a.NEED = !0, i(["delete", "has", "get", "set"], function(t) {
        var e = y.prototype,
            n = e[t];
        o(e, t, function(e, i) {
            if (u(e) && !d(e)) {
                this._f || (this._f = new r);
                var o = this._f[t](e, i);
                return "set" == t ? this : o
            }
            return n.call(this, e, i)
        })
    }))
}, function(t, e, n) {
    "use strict";
    var r = n(126),
        i = n(49);
    n(61)("WeakSet", function(t) {
        return function() {
            return t(this, arguments.length > 0 ? arguments[0] : void 0)
        }
    }, {
        add: function(t) {
            return r.def(i(this, "WeakSet"), t, !0)
        }
    }, r, !1, !0)
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(62),
        o = n(93),
        a = n(7),
        s = n(38),
        c = n(12),
        u = n(6),
        l = n(5).ArrayBuffer,
        h = n(59),
        f = o.ArrayBuffer,
        d = o.DataView,
        v = i.ABV && l.isView,
        p = f.prototype.slice,
        m = i.VIEW;
    r(r.G + r.W + r.F * (l !== f), {
        ArrayBuffer: f
    }), r(r.S + r.F * !i.CONSTR, "ArrayBuffer", {
        isView: function(t) {
            return v && v(t) || u(t) && m in t
        }
    }), r(r.P + r.U + r.F * n(4)(function() {
        return !new f(2).slice(1, void 0).byteLength
    }), "ArrayBuffer", {
        slice: function(t, e) {
            if (void 0 !== p && void 0 === e) return p.call(a(this), t);
            for (var n = a(this).byteLength, r = s(t, n), i = s(void 0 === e ? n : e, n), o = new(h(this, f))(c(i - r)), u = new d(this), l = new d(o), v = 0; r < i;) l.setUint8(v++, u.getUint8(r++));
            return o
        }
    }), n(46)("ArrayBuffer")
}, function(t, e, n) {
    var r = n(1);
    r(r.G + r.W + r.F * !n(62).ABV, {
        DataView: n(93).DataView
    })
}, function(t, e, n) {
    n(30)("Int8", 1, function(t) {
        return function(e, n, r) {
            return t(this, e, n, r)
        }
    })
}, function(t, e, n) {
    n(30)("Uint8", 1, function(t) {
        return function(e, n, r) {
            return t(this, e, n, r)
        }
    })
}, function(t, e, n) {
    n(30)("Uint8", 1, function(t) {
        return function(e, n, r) {
            return t(this, e, n, r)
        }
    }, !0)
}, function(t, e, n) {
    n(30)("Int16", 2, function(t) {
        return function(e, n, r) {
            return t(this, e, n, r)
        }
    })
}, function(t, e, n) {
    n(30)("Uint16", 2, function(t) {
        return function(e, n, r) {
            return t(this, e, n, r)
        }
    })
}, function(t, e, n) {
    n(30)("Int32", 4, function(t) {
        return function(e, n, r) {
            return t(this, e, n, r)
        }
    })
}, function(t, e, n) {
    n(30)("Uint32", 4, function(t) {
        return function(e, n, r) {
            return t(this, e, n, r)
        }
    })
}, function(t, e, n) {
    n(30)("Float32", 4, function(t) {
        return function(e, n, r) {
            return t(this, e, n, r)
        }
    })
}, function(t, e, n) {
    n(30)("Float64", 8, function(t) {
        return function(e, n, r) {
            return t(this, e, n, r)
        }
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(26),
        o = n(7),
        a = (n(5).Reflect || {}).apply,
        s = Function.apply;
    r(r.S + r.F * !n(4)(function() {
        a(function() {})
    }), "Reflect", {
        apply: function(t, e, n) {
            var r = i(t),
                c = o(n);
            return a ? a(r, e, c) : s.call(r, e, c)
        }
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(39),
        o = n(26),
        a = n(7),
        s = n(6),
        c = n(4),
        u = n(108),
        l = (n(5).Reflect || {}).construct,
        h = c(function() {
            function t() {}
            return !(l(function() {}, [], t) instanceof t)
        }),
        f = !c(function() {
            l(function() {})
        });
    r(r.S + r.F * (h || f), "Reflect", {
        construct: function(t, e) {
            o(t), a(e);
            var n = arguments.length < 3 ? t : o(arguments[2]);
            if (f && !h) return l(t, e, n);
            if (t == n) {
                switch (e.length) {
                    case 0:
                        return new t;
                    case 1:
                        return new t(e[0]);
                    case 2:
                        return new t(e[0], e[1]);
                    case 3:
                        return new t(e[0], e[1], e[2]);
                    case 4:
                        return new t(e[0], e[1], e[2], e[3])
                }
                var r = [null];
                return r.push.apply(r, e), new(u.apply(t, r))
            }
            var c = n.prototype,
                d = i(s(c) ? c : Object.prototype),
                v = Function.apply.call(t, d, e);
            return s(v) ? v : d
        }
    })
}, function(t, e, n) {
    var r = n(9),
        i = n(1),
        o = n(7),
        a = n(32);
    i(i.S + i.F * n(4)(function() {
        Reflect.defineProperty(r.f({}, 1, {
            value: 1
        }), 1, {
            value: 2
        })
    }), "Reflect", {
        defineProperty: function(t, e, n) {
            o(t), e = a(e, !0), o(n);
            try {
                return r.f(t, e, n), !0
            } catch (t) {
                return !1
            }
        }
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(22).f,
        o = n(7);
    r(r.S, "Reflect", {
        deleteProperty: function(t, e) {
            var n = i(o(t), e);
            return !(n && !n.configurable) && delete t[e]
        }
    })
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(7),
        o = function(t) {
            this._t = i(t), this._i = 0;
            var e, n = this._k = [];
            for (e in t) n.push(e)
        };
    n(116)(o, "Object", function() {
        var t, e = this._k;
        do {
            if (this._i >= e.length) return {
                value: void 0,
                done: !0
            }
        } while (!((t = e[this._i++]) in this._t));
        return {
            value: t,
            done: !1
        }
    }), r(r.S, "Reflect", {
        enumerate: function(t) {
            return new o(t)
        }
    })
}, function(t, e, n) {
    var r = n(22),
        i = n(41),
        o = n(17),
        a = n(1),
        s = n(6),
        c = n(7);
    a(a.S, "Reflect", {
        get: function t(e, n) {
            var a, u, l = arguments.length < 3 ? e : arguments[2];
            return c(e) === l ? e[n] : (a = r.f(e, n)) ? o(a, "value") ? a.value : void 0 !== a.get ? a.get.call(l) : void 0 : s(u = i(e)) ? t(u, n, l) : void 0
        }
    })
}, function(t, e, n) {
    var r = n(22),
        i = n(1),
        o = n(7);
    i(i.S, "Reflect", {
        getOwnPropertyDescriptor: function(t, e) {
            return r.f(o(t), e)
        }
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(41),
        o = n(7);
    r(r.S, "Reflect", {
        getPrototypeOf: function(t) {
            return i(o(t))
        }
    })
}, function(t, e, n) {
    var r = n(1);
    r(r.S, "Reflect", {
        has: function(t, e) {
            return e in t
        }
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(7),
        o = Object.isExtensible;
    r(r.S, "Reflect", {
        isExtensible: function(t) {
            return i(t), !o || o(t)
        }
    })
}, function(t, e, n) {
    var r = n(1);
    r(r.S, "Reflect", {
        ownKeys: n(128)
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(7),
        o = Object.preventExtensions;
    r(r.S, "Reflect", {
        preventExtensions: function(t) {
            i(t);
            try {
                return o && o(t), !0
            } catch (t) {
                return !1
            }
        }
    })
}, function(t, e, n) {
    var r = n(9),
        i = n(22),
        o = n(41),
        a = n(17),
        s = n(1),
        c = n(34),
        u = n(7),
        l = n(6);
    s(s.S, "Reflect", {
        set: function t(e, n, s) {
            var h, f, d = arguments.length < 4 ? e : arguments[3],
                v = i.f(u(e), n);
            if (!v) {
                if (l(f = o(e))) return t(f, n, s, d);
                v = c(0)
            }
            if (a(v, "value")) {
                if (!1 === v.writable || !l(d)) return !1;
                if (h = i.f(d, n)) {
                    if (h.get || h.set || !1 === h.writable) return !1;
                    h.value = s, r.f(d, n, h)
                } else r.f(d, n, c(0, s));
                return !0
            }
            return void 0 !== v.set && (v.set.call(d, s), !0)
        }
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(76);
    i && r(r.S, "Reflect", {
        setPrototypeOf: function(t, e) {
            i.check(t, e);
            try {
                return i.set(t, e), !0
            } catch (t) {
                return !1
            }
        }
    })
}, function(t, e, n) {
    n(288), t.exports = n(11).Array.includes
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(52)(!0);
    r(r.P, "Array", {
        includes: function(t) {
            return i(this, t, arguments.length > 1 ? arguments[1] : void 0)
        }
    }), n(45)("includes")
}, function(t, e, n) {
    n(290), t.exports = n(11).String.padStart
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(129),
        o = n(60);
    r(r.P + r.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(o), "String", {
        padStart: function(t) {
            return i(this, t, arguments.length > 1 ? arguments[1] : void 0, !0)
        }
    })
}, function(t, e, n) {
    n(292), t.exports = n(11).String.padEnd
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(129),
        o = n(60);
    r(r.P + r.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(o), "String", {
        padEnd: function(t) {
            return i(this, t, arguments.length > 1 ? arguments[1] : void 0, !1)
        }
    })
}, function(t, e, n) {
    n(294), t.exports = n(71).f("asyncIterator")
}, function(t, e, n) {
    n(103)("asyncIterator")
}, function(t, e, n) {
    n(296), t.exports = n(11).Object.getOwnPropertyDescriptors
}, function(t, e, n) {
    var r = n(1),
        i = n(128),
        o = n(19),
        a = n(22),
        s = n(87);
    r(r.S, "Object", {
        getOwnPropertyDescriptors: function(t) {
            for (var e, n, r = o(t), c = a.f, u = i(r), l = {}, h = 0; u.length > h;) void 0 !== (n = c(r, e = u[h++])) && s(l, e, n);
            return l
        }
    })
}, function(t, e, n) {
    n(298), t.exports = n(11).Object.values
}, function(t, e, n) {
    var r = n(1),
        i = n(130)(!1);
    r(r.S, "Object", {
        values: function(t) {
            return i(t)
        }
    })
}, function(t, e, n) {
    n(300), t.exports = n(11).Object.entries
}, function(t, e, n) {
    var r = n(1),
        i = n(130)(!0);
    r(r.S, "Object", {
        entries: function(t) {
            return i(t)
        }
    })
}, function(t, e, n) {
    "use strict";
    n(122), n(302), t.exports = n(11).Promise.finally
}, function(t, e, n) {
    "use strict";
    var r = n(1),
        i = n(11),
        o = n(5),
        a = n(59),
        s = n(124);
    r(r.P + r.R, "Promise", {
        finally: function(t) {
            var e = a(this, i.Promise || o.Promise),
                n = "function" == typeof t;
            return this.then(n ? function(n) {
                return s(e, t()).then(function() {
                    return n
                })
            } : t, n ? function(n) {
                return s(e, t()).then(function() {
                    throw n
                })
            } : t)
        }
    })
}, function(t, e, n) {
    n(304), n(305), n(306), t.exports = n(11)
}, function(t, e, n) {
    var r = n(5),
        i = n(1),
        o = n(60),
        a = [].slice,
        s = /MSIE .\./.test(o),
        c = function(t) {
            return function(e, n) {
                var r = arguments.length > 2,
                    i = !!r && a.call(arguments, 2);
                return t(r ? function() {
                    ("function" == typeof e ? e : Function(e)).apply(this, i)
                } : e, n)
            }
        };
    i(i.G + i.B + i.F * s, {
        setTimeout: c(r.setTimeout),
        setInterval: c(r.setInterval)
    })
}, function(t, e, n) {
    var r = n(1),
        i = n(92);
    r(r.G + r.B, {
        setImmediate: i.set,
        clearImmediate: i.clear
    })
}, function(t, e, n) {
    for (var r = n(90), i = n(37), o = n(15), a = n(5), s = n(18), c = n(44), u = n(8), l = u("iterator"), h = u("toStringTag"), f = c.Array, d = {
            CSSRuleList: !0,
            CSSStyleDeclaration: !1,
            CSSValueList: !1,
            ClientRectList: !1,
            DOMRectList: !1,
            DOMStringList: !1,
            DOMTokenList: !0,
            DataTransferItemList: !1,
            FileList: !1,
            HTMLAllCollection: !1,
            HTMLCollection: !1,
            HTMLFormElement: !1,
            HTMLSelectElement: !1,
            MediaList: !0,
            MimeTypeArray: !1,
            NamedNodeMap: !1,
            NodeList: !0,
            PaintRequestList: !1,
            Plugin: !1,
            PluginArray: !1,
            SVGLengthList: !1,
            SVGNumberList: !1,
            SVGPathSegList: !1,
            SVGPointList: !1,
            SVGStringList: !1,
            SVGTransformList: !1,
            SourceBufferList: !1,
            StyleSheetList: !0,
            TextTrackCueList: !1,
            TextTrackList: !1,
            TouchList: !1
        }, v = i(d), p = 0; p < v.length; p++) {
        var m, g = v[p],
            y = d[g],
            x = a[g],
            b = x && x.prototype;
        if (b && (b[l] || s(b, l, f), b[h] || s(b, h, g), c[g] = f, y))
            for (m in r) b[m] || o(b, m, r[m], !0)
    }
}, function(t, e) {
    ! function(e) {
        "use strict";
        var n, r = Object.prototype,
            i = r.hasOwnProperty,
            o = "function" == typeof Symbol ? Symbol : {},
            a = o.iterator || "@@iterator",
            s = o.asyncIterator || "@@asyncIterator",
            c = o.toStringTag || "@@toStringTag",
            u = "object" == typeof t,
            l = e.regeneratorRuntime;
        if (l) u && (t.exports = l);
        else {
            (l = e.regeneratorRuntime = u ? t.exports : {}).wrap = b;
            var h = "suspendedStart",
                f = "suspendedYield",
                d = "executing",
                v = "completed",
                p = {},
                m = {};
            m[a] = function() {
                return this
            };
            var g = Object.getPrototypeOf,
                y = g && g(g(C([])));
            y && y !== r && i.call(y, a) && (m = y);
            var x = S.prototype = _.prototype = Object.create(m);
            M.prototype = x.constructor = S, S.constructor = M, S[c] = M.displayName = "GeneratorFunction", l.isGeneratorFunction = function(t) {
                var e = "function" == typeof t && t.constructor;
                return !!e && (e === M || "GeneratorFunction" === (e.displayName || e.name))
            }, l.mark = function(t) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(t, S) : (t.__proto__ = S, c in t || (t[c] = "GeneratorFunction")), t.prototype = Object.create(x), t
            }, l.awrap = function(t) {
                return {
                    __await: t
                }
            }, E(T.prototype), T.prototype[s] = function() {
                return this
            }, l.AsyncIterator = T, l.async = function(t, e, n, r) {
                var i = new T(b(t, e, n, r));
                return l.isGeneratorFunction(e) ? i : i.next().then(function(t) {
                    return t.done ? t.value : i.next()
                })
            }, E(x), x[c] = "Generator", x[a] = function() {
                return this
            }, x.toString = function() {
                return "[object Generator]"
            }, l.keys = function(t) {
                var e = [];
                for (var n in t) e.push(n);
                return e.reverse(),
                    function n() {
                        for (; e.length;) {
                            var r = e.pop();
                            if (r in t) return n.value = r, n.done = !1, n
                        }
                        return n.done = !0, n
                    }
            }, l.values = C, z.prototype = {
                constructor: z,
                reset: function(t) {
                    if (this.prev = 0, this.next = 0, this.sent = this._sent = n, this.done = !1, this.delegate = null, this.method = "next", this.arg = n, this.tryEntries.forEach(A), !t)
                        for (var e in this) "t" === e.charAt(0) && i.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = n)
                },
                stop: function() {
                    this.done = !0;
                    var t = this.tryEntries[0].completion;
                    if ("throw" === t.type) throw t.arg;
                    return this.rval
                },
                dispatchException: function(t) {
                    if (this.done) throw t;
                    var e = this;

                    function r(r, i) {
                        return s.type = "throw", s.arg = t, e.next = r, i && (e.method = "next", e.arg = n), !!i
                    }
                    for (var o = this.tryEntries.length - 1; o >= 0; --o) {
                        var a = this.tryEntries[o],
                            s = a.completion;
                        if ("root" === a.tryLoc) return r("end");
                        if (a.tryLoc <= this.prev) {
                            var c = i.call(a, "catchLoc"),
                                u = i.call(a, "finallyLoc");
                            if (c && u) {
                                if (this.prev < a.catchLoc) return r(a.catchLoc, !0);
                                if (this.prev < a.finallyLoc) return r(a.finallyLoc)
                            } else if (c) {
                                if (this.prev < a.catchLoc) return r(a.catchLoc, !0)
                            } else {
                                if (!u) throw new Error("try statement without catch or finally");
                                if (this.prev < a.finallyLoc) return r(a.finallyLoc)
                            }
                        }
                    }
                },
                abrupt: function(t, e) {
                    for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                        var r = this.tryEntries[n];
                        if (r.tryLoc <= this.prev && i.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
                            var o = r;
                            break
                        }
                    }
                    o && ("break" === t || "continue" === t) && o.tryLoc <= e && e <= o.finallyLoc && (o = null);
                    var a = o ? o.completion : {};
                    return a.type = t, a.arg = e, o ? (this.method = "next", this.next = o.finallyLoc, p) : this.complete(a)
                },
                complete: function(t, e) {
                    if ("throw" === t.type) throw t.arg;
                    return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), p
                },
                finish: function(t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var n = this.tryEntries[e];
                        if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), A(n), p
                    }
                },
                catch: function(t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var n = this.tryEntries[e];
                        if (n.tryLoc === t) {
                            var r = n.completion;
                            if ("throw" === r.type) {
                                var i = r.arg;
                                A(n)
                            }
                            return i
                        }
                    }
                    throw new Error("illegal catch attempt")
                },
                delegateYield: function(t, e, r) {
                    return this.delegate = {
                        iterator: C(t),
                        resultName: e,
                        nextLoc: r
                    }, "next" === this.method && (this.arg = n), p
                }
            }
        }

        function b(t, e, n, r) {
            var i = e && e.prototype instanceof _ ? e : _,
                o = Object.create(i.prototype),
                a = new z(r || []);
            return o._invoke = function(t, e, n) {
                var r = h;
                return function(i, o) {
                    if (r === d) throw new Error("Generator is already running");
                    if (r === v) {
                        if ("throw" === i) throw o;
                        return R()
                    }
                    for (n.method = i, n.arg = o;;) {
                        var a = n.delegate;
                        if (a) {
                            var s = P(a, n);
                            if (s) {
                                if (s === p) continue;
                                return s
                            }
                        }
                        if ("next" === n.method) n.sent = n._sent = n.arg;
                        else if ("throw" === n.method) {
                            if (r === h) throw r = v, n.arg;
                            n.dispatchException(n.arg)
                        } else "return" === n.method && n.abrupt("return", n.arg);
                        r = d;
                        var c = w(t, e, n);
                        if ("normal" === c.type) {
                            if (r = n.done ? v : f, c.arg === p) continue;
                            return {
                                value: c.arg,
                                done: n.done
                            }
                        }
                        "throw" === c.type && (r = v, n.method = "throw", n.arg = c.arg)
                    }
                }
            }(t, n, a), o
        }

        function w(t, e, n) {
            try {
                return {
                    type: "normal",
                    arg: t.call(e, n)
                }
            } catch (t) {
                return {
                    type: "throw",
                    arg: t
                }
            }
        }

        function _() {}

        function M() {}

        function S() {}

        function E(t) {
            ["next", "throw", "return"].forEach(function(e) {
                t[e] = function(t) {
                    return this._invoke(e, t)
                }
            })
        }

        function T(t) {
            var e;
            this._invoke = function(n, r) {
                function o() {
                    return new Promise(function(e, o) {
                        ! function e(n, r, o, a) {
                            var s = w(t[n], t, r);
                            if ("throw" !== s.type) {
                                var c = s.arg,
                                    u = c.value;
                                return u && "object" == typeof u && i.call(u, "__await") ? Promise.resolve(u.__await).then(function(t) {
                                    e("next", t, o, a)
                                }, function(t) {
                                    e("throw", t, o, a)
                                }) : Promise.resolve(u).then(function(t) {
                                    c.value = t, o(c)
                                }, a)
                            }
                            a(s.arg)
                        }(n, r, e, o)
                    })
                }
                return e = e ? e.then(o, o) : o()
            }
        }

        function P(t, e) {
            var r = t.iterator[e.method];
            if (r === n) {
                if (e.delegate = null, "throw" === e.method) {
                    if (t.iterator.return && (e.method = "return", e.arg = n, P(t, e), "throw" === e.method)) return p;
                    e.method = "throw", e.arg = new TypeError("The iterator does not provide a 'throw' method")
                }
                return p
            }
            var i = w(r, t.iterator, e.arg);
            if ("throw" === i.type) return e.method = "throw", e.arg = i.arg, e.delegate = null, p;
            var o = i.arg;
            return o ? o.done ? (e[t.resultName] = o.value, e.next = t.nextLoc, "return" !== e.method && (e.method = "next", e.arg = n), e.delegate = null, p) : o : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, p)
        }

        function L(t) {
            var e = {
                tryLoc: t[0]
            };
            1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e)
        }

        function A(t) {
            var e = t.completion || {};
            e.type = "normal", delete e.arg, t.completion = e
        }

        function z(t) {
            this.tryEntries = [{
                tryLoc: "root"
            }], t.forEach(L, this), this.reset(!0)
        }

        function C(t) {
            if (t) {
                var e = t[a];
                if (e) return e.call(t);
                if ("function" == typeof t.next) return t;
                if (!isNaN(t.length)) {
                    var r = -1,
                        o = function e() {
                            for (; ++r < t.length;)
                                if (i.call(t, r)) return e.value = t[r], e.done = !1, e;
                            return e.value = n, e.done = !0, e
                        };
                    return o.next = o
                }
            }
            return {
                next: R
            }
        }

        function R() {
            return {
                value: n,
                done: !0
            }
        }
    }(function() {
        return this
    }() || Function("return this")())
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return i
    });
    var i = function() {
        function t() {
            ! function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), this.message = "based on shader by yoichi kobayashi", this.url = "http://www.tplh.net", this.show()
        }
        return function(t, e, n) {
            e && r(t.prototype, e), n && r(t, n)
        }(t, [{
            key: "show",
            value: function() {
                if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
                    var t = ["%c ".concat(this.message, " %c ").concat(this.url), "", "padding:3px 1px;"];
                    console.log.apply(console, t)
                } else window.console && console.log("".concat(this.message, " ").concat(this.url))
            }
        }]), t
    }()
}, function(t, e, n) {
    "use strict";
    n.r(e), e.default = function() {
        for (var t = decodeURIComponent(location.search.substring(1)).split("&"), e = 0; e < t.length; e++)
            if (!(t[e].indexOf("sketch_id") < 0)) {
                var n = t[e].replace("sketch_id=", "");
                switch (n = parseInt(n, 10)) {
                    case 9:
                        location.href = "/sketch-threejs/sketch/attract.html";
                        break;
                    case 8:
                        location.href = "/sketch-threejs/sketch/hole.html";
                        break;
                    case 7:
                        location.href = "/sketch-threejs/sketch/metal_cube.html";
                        break;
                    case 6:
                        location.href = "/sketch-threejs/sketch/distort.html";
                        break;
                    case 5:
                        location.href = "/sketch-threejs/sketch/image_data.html";
                        break;
                    case 4:
                        location.href = "/sketch-threejs/sketch/gallery.html";
                        break;
                    case 3:
                        location.href = "/sketch-threejs/sketch/comet.html";
                        break;
                    case 2:
                        location.href = "/sketch-threejs/sketch/hyper_space.html";
                        break;
                    case 1:
                        location.href = "/sketch-threejs/sketch/fire_ball.html"
                }
            }
    }
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(311).default,
        a = n(318).default,
        s = n(321).default,
        c = n(324).default,
        u = n(327).default,
        l = n(330).default,
        h = n(333).default,
        f = n(336).default;
    e.default = function() {
        var t = new o,
            e = document.getElementById("canvas-webgl"),
            n = new r.WebGLRenderer({
                alpha: true,
                antialias: !1,
                canvas: e
            }),
            d = new r.WebGLRenderTarget(document.body.clientWidth, window.innerHeight),
            v = new r.Scene,
            p = new r.Scene,
            m = new r.OrthographicCamera(-1, 1, 1, -1, 0, 1),
            g = new r.PerspectiveCamera(45, document.body.clientWidth / window.innerHeight, 1, 1e4),
            y = new r.Clock,
            x = new a,
            b = (new s, new c),
            w = new u,
            _ = new l,
            M = [new h(400, -500, 200), new h(-350, -600, -50), new h(-150, -700, -150), new h(-500, -900, 0), new h(100, -1100, 250), new h(-100, -1200, -300), new h(150, -1500, -100)],
            S = new f(d.texture),
            E = document.getElementsByClassName("js-transition-intro"),
            T = function() {
                e.width = document.body.clientWidth, e.height = window.innerHeight, g.aspect = document.body.clientWidth / window.innerHeight, g.updateProjectionMatrix(), d.setSize(document.body.clientWidth, window.innerHeight), n.setSize(document.body.clientWidth, window.innerHeight), S.resize()
            },
            P = function t() {
                ! function() {
                    var t = y.getDelta();
                    x.render(t), b.render(t), w.render(t), _.render(t);
                    for (var e = 0; e < M.length; e++) M[e].render(t);
                    n.render(p, g, d), S.render(t), n.render(v, m)
                }(), requestAnimationFrame(t)
            };
        n.setSize(document.body.clientWidth, window.innerHeight), n.setClearColor(0, 1), g.position.z = 800, v.add(S.obj), x.loadTexture(function() {
            p.add(x.obj), p.add(b.obj), p.add(w.obj), p.add(_.obj);
            for (var t = 0; t < M.length; t++) p.add(M[t].obj);
            ! function() {
                for (var t = 0; t < E.length; t++) E[t].classList.add("is-shown")
            }()
        }), y.start(), window.addEventListener("resize", i(function() {
            T()
        }), 1e3), t.renderNext = function() {
            t.isValidSmooth() ? g.position.y = .6 * t.hookes.contents.velocity[1] : g.position.y = -1 * t.scrollTop
        }, T(), P(), t.start()
    }
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return h
    });
    var i = n(3),
        o = n(94),
        a = n(95),
        s = n(312).default,
        c = n(313).default,
        u = document.querySelector(".js-contents"),
        l = document.querySelector(".js-dummy-scroll"),
        h = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.scrollItems = new c(this), this.scrollTop = 0, this.scrollFrame = 0, this.scrollTopPause = 0, this.resolution = {
                    x: 0,
                    y: 0
                }, this.bodyResolution = {
                    x: 0,
                    y: 0
                }, this.X_SWITCH_SMOOTH = 1024, this.hookes = {}, this.scrollPrev = null, this.scrollNext = null, this.resizeReset = null, this.resizePrev = null, this.resizeNext = null, this.renderPrev = null, this.renderNext = null, this.isWorking = !1, this.isWorkingSmooth = !1, this.isAlreadyAddEvent = !1
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "start",
                value: function(t) {
                    var e = this;
                    setTimeout(function() {
                        e.scrollTop = window.pageYOffset, e.initHookes(), e.scrollItems.init();
                        var n = location.hash,
                            r = n ? document.querySelector(n) : null;
                        if (r) {
                            var i = r.getBoundingClientRect();
                            e.scrollTop + i.top
                        }
                        e.resize(function() {
                            e.scroll(), e.isWorkingSmooth = !0, e.renderLoop(), e.on(), t && t()
                        })
                    }, 100)
                }
            }, {
                key: "pause",
                value: function() {
                    this.isWorking = !1, u.style.position = "fixed", this.hookes.contents.velocity[1] = this.hookes.contents.anchor[1] = -1 * this.scrollTop, this.scrollTopPause = this.scrollTop, window.scrollTo(0, this.scrollTop)
                }
            }, {
                key: "play",
                value: function() {
                    u.style.position = "", this.scrollTop = this.scrollTopPause, this.resolution.x <= this.X_SWITCH_SMOOTH && (this.hookes.contents.velocity[1] = this.hookes.contents.anchor[1] = 0), window.scrollTo(0, this.scrollTop), this.isWorking = !0
                }
            }, {
                key: "initDummyScroll",
                value: function() {
                    this.resolution.x <= this.X_SWITCH_SMOOTH ? (u.style.transform = "", u.classList.remove("is-fixed"), l.style.height = "0") : (u.classList.add("is-fixed"), l.style.height = "".concat(u.clientHeight, "px")), this.render()
                }
            }, {
                key: "initHookes",
                value: function() {
                    this.hookes = {
                        contents: new s({
                            k: .575,
                            d: .8
                        }),
                        smooth: new s({
                            k: .18,
                            d: .75
                        }),
                        parallax: new s({
                            k: .28,
                            d: .7
                        })
                    }
                }
            }, {
                key: "scrollBasis",
                value: function() {
                    this.resolution.x > this.X_SWITCH_SMOOTH && (this.hookes.contents.anchor[1] = -1 * this.scrollTop, this.hookes.smooth.velocity[1] += this.scrollFrame, this.hookes.parallax.anchor[1] = this.scrollTop + .5 * this.resolution.y), this.scrollItems.scroll()
                }
            }, {
                key: "scroll",
                value: function(t) {
                    if (!1 !== this.isWorking) {
                        var e = window.pageYOffset;
                        this.scrollFrame = e - this.scrollTop, this.scrollTop = e, this.scrollPrev && this.scrollPrev(), this.scrollBasis(), this.scrollNext && this.scrollNext()
                    }
                }
            }, {
                key: "tilt",
                value: function(t) {
                    !1 !== this.isWorking && this.resolution.x > this.X_SWITCH_SMOOTH && (this.hookes.parallax.anchor[0] = -100 * (t.clientX / this.resolution.x * 2 - 1))
                }
            }, {
                key: "resizeBasis",
                value: function() {
                    this.scrollItems.resize()
                }
            }, {
                key: "resize",
                value: function(t) {
                    if (this.isWorking = !1, this.resizeReset && this.resizeReset(), this.scrollTop = window.pageYOffset, this.resolution.x = window.innerWidth, this.resolution.y = window.innerHeight, this.bodyResolution.x = document.body.clientWidth, this.bodyResolution.y = document.body.clientHeight, this.resolution.x > this.X_SWITCH_SMOOTH) this.hookes.contents.velocity[1] = this.hookes.contents.anchor[1] = -this.scrollTop, this.hookes.parallax.velocity[1] = this.hookes.parallax.anchor[1] = this.scrollTop + .5 * this.resolution.y;
                    else
                        for (var e in this.hookes) switch (e) {
                            case "contents":
                            case "parallax":
                                this.hookes[e].anchor[1] = this.hookes[e].velocity[1] = 0;
                                break;
                            default:
                                this.hookes[e].velocity[1] = 0
                        }
                    this.resizePrev && this.resizePrev(), this.initDummyScroll(), this.render(), window.scrollTo(0, this.scrollTop), this.resizeBasis(), this.resizeNext && this.resizeNext(), this.isWorking = !0, t && t()
                }
            }, {
                key: "render",
                value: function() {
                    this.renderPrev && this.renderPrev();
                    var t = Math.floor(1e3 * this.hookes.contents.velocity[1]) / 1e3;
                    for (var e in u.style.transform = "translate3D(0, ".concat(t, "px, 0)"), this.hookes) this.hookes[e].render();
                    this.scrollItems.render(this.isValidSmooth()), this.renderNext && this.renderNext()
                }
            }, {
                key: "renderLoop",
                value: function() {
                    var t = this;
                    this.render(), this.isWorkingSmooth && requestAnimationFrame(function() {
                        t.renderLoop()
                    })
                }
            }, {
                key: "on",
                value: function() {
                    var t = this;
                    if (!this.isAlreadyAddEvent) {
                        var e = o() || a() ? "orientationchange" : "resize";
                        window.addEventListener("scroll", function(e) {
                            t.scroll(e)
                        }, !1), window.addEventListener("mousemove", function(e) {
                            t.tilt(e)
                        }, !1), window.addEventListener(e, i(function(e) {
                            t.resize()
                        }, 400), !1), this.isAlreadyAddEvent = !0
                    }
                }
            }, {
                key: "off",
                value: function() {
                    this.scrollPrev = null, this.scrollNext = null, this.resizeReset = null, this.resizePrev = null, this.resizeNext = null, this.renderPrev = null, this.renderNext = null
                }
            }, {
                key: "isValidSmooth",
                value: function() {
                    return this.isWorkingSmooth && this.resolution.x > this.X_SWITCH_SMOOTH
                }
            }]), t
        }()
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(63).default,
        o = function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.velocity = [0, 0, 0], this.acceleration = [0, 0, 0], this.anchor = [0, 0, 0], this.k = e && void 0 !== e.k ? e.k : .3, this.d = e && void 0 !== e.d ? e.d : .7, this.m = e && void 0 !== e.m ? e.m : 1
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "render",
                value: function() {
                    i.applyHook(this.velocity, this.acceleration, this.anchor, 0, this.k), i.applyDrag(this.acceleration, this.d), i.updateVelocity(this.velocity, this.acceleration, this.m)
                }
            }]), t
        }()
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return s
    });
    var i = n(314).default,
        o = n(315).default,
        a = n(316).default,
        s = function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.scrollManager = e, this.scrollItems = [], this.smoothItems = [], this.parallaxItems = []
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "init",
                value: function() {
                    var t = document.querySelectorAll(".js-scroll-item"),
                        e = document.querySelectorAll(".js-smooth-item"),
                        n = document.querySelectorAll(".js-parallax-item");
                    this.scrollItems = [], this.smoothItems = [], this.parallaxItems = [];
                    for (var r = 0; r < t.length; r++) this.scrollItems[r] = new i(t[r], this.scrollManager);
                    for (r = 0; r < e.length; r++) this.smoothItems[r] = new o(e[r], this.scrollManager, this.scrollManager.hookes.smooth, e[r].dataset);
                    for (r = 0; r < n.length; r++) this.parallaxItems[r] = new a(n[r], this.scrollManager, this.scrollManager.hookes.parallax, n[r].dataset)
                }
            }, {
                key: "scroll",
                value: function() {
                    for (var t = 0; t < this.scrollItems.length; t++) this.scrollItems[t].show(this.scrollManager.scrollTop + this.scrollManager.resolution.y, this.scrollManager.scrollTop)
                }
            }, {
                key: "resize",
                value: function() {
                    for (var t = 0; t < this.scrollItems.length; t++) this.scrollItems[t].init(this.scrollManager.scrollTop);
                    for (t = 0; t < this.smoothItems.length; t++) this.smoothItems[t].init(this.scrollManager.scrollTop);
                    for (t = 0; t < this.parallaxItems.length; t++) this.parallaxItems[t].init(this.scrollManager.scrollTop)
                }
            }, {
                key: "render",
                value: function(t) {
                    for (var e = 0; e < this.smoothItems.length; e++) this.smoothItems[e].render(t);
                    for (e = 0; e < this.parallaxItems.length; e++) this.parallaxItems[e].render(t)
                }
            }]), t
        }()
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return i
    });
    var i = function() {
        function t(e) {
            ! function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), this.elm = e, this.elmChildren = e.querySelectorAll(".js-scroll-item-child"), this.top = 0, this.bottom = 0
        }
        return function(t, e, n) {
            e && r(t.prototype, e), n && r(t, n)
        }(t, [{
            key: "init",
            value: function(t) {
                var e = this.elm.getBoundingClientRect();
                this.top = t + e.top, this.bottom = this.top + e.height
            }
        }, {
            key: "show",
            value: function(t, e) {
                if (t > this.top && e < this.bottom) {
                    this.elm.classList.add("is-shown");
                    for (var n = 0; n < this.elmChildren.length; n++) this.elmChildren[n].classList.add("is-shown")
                }
            }
        }]), t
    }()
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return i
    });
    var i = function() {
        function t(e, n, r, i) {
            ! function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), this.scrollManager = n, this.hookes = r, this.elm = e, this.height = 0, this.top = 0, this.max = i && i.max ? i.max : null, this.min = i && i.min ? i.min : null, this.ratio = i && i.ratio ? i.ratio : .1, this.unit = i && i.unit ? i.unit : "px"
        }
        return function(t, e, n) {
            e && r(t.prototype, e), n && r(t, n)
        }(t, [{
            key: "init",
            value: function(t) {
                var e = this.elm.getBoundingClientRect();
                this.height = e.height, this.top = t + e.top, this.elm.style.backfaceVisibility = "hidden"
            }
        }, {
            key: "render",
            value: function(t) {
                var e = 0;
                t && (e = this.hookes.velocity[1] * this.ratio, Math.abs(this.hookes.acceleration[1]) < .01 && (this.hookes.velocity[1] = this.hookes.anchor[1]), this.min && (e = Math.max(e, this.min)), this.max && (e = Math.min(e, this.max))), this.elm.style.transform = "translate3D(0, ".concat(e).concat(this.unit, ", 0)")
            }
        }]), t
    }()
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(2),
        o = n(317),
        a = function() {
            function t(e, n, r, i) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.scrollManager = n, this.hookes = r, this.elm = e, this.height = 0, this.top = 0, this.rangeX = i && i.rangeX ? i.rangeX : 1e4, this.ratioX = i && i.ratioX ? i.ratioX : 0, this.unitX = i && i.unitX ? i.unitX : "px", this.rangeY = i && i.rangeY ? i.rangeY : 10, this.ratioY = i && i.ratioY ? i.ratioY : .012, this.unitY = i && i.unitY ? i.unitY : "%"
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "init",
                value: function(t) {
                    this.elm.style.transform = "";
                    var e = this.elm.getBoundingClientRect();
                    this.height = e.height, this.top = t + e.top, this.elm.style.backfaceVisibility = "hidden", this.render()
                }
            }, {
                key: "render",
                value: function(t) {
                    var e = t ? i.clamp(this.hookes.velocity[0] * this.ratioX, -1 * this.rangeX, this.rangeX) : 0,
                        n = t ? i.clamp((this.hookes.velocity[1] - (this.top + .5 * this.height)) * this.ratioY, -1 * this.rangeY, this.rangeY) : 0;
                    this.elm.style.transform = o() ? "translate(".concat(e).concat(this.unitX, ", ").concat(n).concat(this.unitY, ")") : "translate3D(".concat(e).concat(this.unitX, ", ").concat(n).concat(this.unitY, ", 0)")
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = function() {
        var t = navigator.userAgent;
        return t.indexOf("MSIE") > -1 || t.indexOf("rv:11.0") > -1
    }
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    resolution: {
                        type: "v2",
                        value: new i.Vector2
                    },
                    texture: {
                        type: "t",
                        value: null
                    }
                }, this.obj, this.isLoaded = !1
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "loadTexture",
                value: function(t) {
                    var e = this;
                    (new i.TextureLoader).load("/sketch-threejs/img/index/tex_title.png", function(n) {
                        n.magFilter = i.NearestFilter, n.minFilter = i.NearestFilter, e.uniforms.texture.value = n, e.obj = e.createObj(), e.isLoaded = !0, t()
                    })
                }
            }, {
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(256, 64, 40, 10), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(319),
                        fragmentShader: n(320),
                        transparent: !0
                    }))
                }
            }, {
                key: "render",
                value: function(t) {
                    this.isLoaded && (this.uniforms.time.value += t)
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\n\nvarying vec2 vUv;\n\nconst float interval = 3.0;\n\nfloat cubicOut_1_0(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\n\n\n\n\nvoid main() {\n  float now = cubicOut_1_0(min(time / interval, 1.0));\n  vec3 updatePosition = vec3(\n    position.x * (1.2 - now * 0.2),\n    position.y * (1.2 - now * 0.2),\n    position.z\n  );\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(updatePosition, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nconst float interval = 3.0;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_2_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_2_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_2_1(vec4 x) {\n     return mod289_2_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_2_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_2_3(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_2_4 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_2_5 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_2_5;\n  vec3 i1 = min( g_2_5.xyz, l.zxy );\n  vec3 i2 = max( g_2_5.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_2_4.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_2_0(i);\n  vec4 p = permute_2_1( permute_2_1( permute_2_1(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_2_4.wyz - D_2_4.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_2_6 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_2_7 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_2_6.xy,h.z);\n  vec3 p3 = vec3(a1_2_6.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_2_2(vec4(dot(p0_2_7,p0_2_7), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_2_7 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_2_7,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\nfloat cubicOut_1_8(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\n\n\n\n\nvoid main() {\n  float now = cubicOut_1_8(min(time / interval, 1.0));\n  float noise = (snoise_2_3(vec3(vUv.x * 4.0, vUv.y * 4.0, 1.0)) + 1.0) / 2.0;\n  float opacity = smoothstep(0.4, 0.6, ((noise - 1.0) + now * interval) - vUv.x);\n  gl_FragColor = texture2D(texture, vUv) * vec4(vec3(1.0), opacity);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    resolution: {
                        type: "v2",
                        value: new i.Vector2
                    }
                }, this.obj = this.createObj()
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.BufferGeometry,
                        e = new Float32Array([0, Math.sqrt(3) / 2, 0, -1, Math.sqrt(3) / 2 * -1, 0, 1, Math.sqrt(3) / 2 * -1, 0]),
                        r = new Uint16Array([0, 1, 2, 0]);
                    return t.addAttribute("position", new i.BufferAttribute(e, 3)), t.setIndex(new i.BufferAttribute(r, 1)), new i.Line(t, new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(322),
                        fragmentShader: n(323)
                    }))
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute float index;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nvoid main() {\n  gl_FragColor = vec4(1.0);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = (n(2), function(t, e, n) {
            var r = [],
                i = [e[0] - t[0], e[1] - t[1], e[2] - t[2]],
                o = [n[0] - t[0], n[1] - t[1], n[2] - t[2]];
            r[0] = i[1] * o[2] - i[2] * o[1], r[1] = i[2] * o[0] - i[0] * o[2], r[2] = i[0] * o[1] - i[1] * o[0];
            for (var a = Math.sqrt(r[0] * r[0] + r[1] * r[1] + r[2] * r[2], 2), s = 0; s < r.length; s++) r[s] = r[s] / a;
            return r
        }),
        a = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj = this.createObj()
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    for (var t = new i.OctahedronBufferGeometry(90, 4), e = t.attributes.position.array, r = [], a = [], s = [], c = 0; c < e.length; c += 9) {
                        var u = o([e[c + 0], e[c + 1], e[c + 2]], [e[c + 3], e[c + 4], e[c + 5]], [e[c + 6], e[c + 7], e[c + 8]]);
                        r.push(u[0], u[1], u[2], u[0], u[1], u[2], u[0], u[1], u[2]);
                        var l = [(e[c + 0] + e[c + 3] + e[c + 6]) / 3, (e[c + 1] + e[c + 4] + e[c + 7]) / 3, (e[c + 2] + e[c + 5] + e[c + 8]) / 3],
                            h = .5 * Math.random();
                        a.push(l[0], l[1], l[2], l[0], l[1], l[2], l[0], l[1], l[2]), s.push(h, h, h)
                    }
                    var f = new Float32Array(r),
                        d = new Float32Array(a),
                        v = new Float32Array(s);
                    return t.addAttribute("faceNormal", new i.BufferAttribute(f, 3)), t.addAttribute("center", new i.BufferAttribute(d, 3)), t.addAttribute("delay", new i.BufferAttribute(v, 1)), new i.Mesh(t, new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(325),
                        fragmentShader: n(326),
                        flatShading: !0,
                        transparent: !0,
                        side: i.DoubleSide
                    }))
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = '#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec3 faceNormal;\nattribute vec3 center;\nattribute float delay;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying float vNoise;\nvarying float vNow;\n\nconst float duration = 2.0;\nconst float delayAll = 1.0;\n\nfloat exponentialOut_1_0(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\n\n\nmat4 calcTranslateMat4_3_1(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4X_5_2(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Y_7_3(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Z_6_4(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n\nmat4 calcRotateMat4_2_5(vec3 radian) {\n  return calcRotateMat4X_5_2(radian.x) * calcRotateMat4Y_7_3(radian.y) * calcRotateMat4Z_6_4(radian.z);\n}\n\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_4_6(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_4_6(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_4_7(vec4 x)\n{\n  return mod289_4_6(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_4_8(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_4_9(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_4_10(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_4_6(Pi0);\n  Pi1 = mod289_4_6(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_4_7(permute_4_7(ix) + iy);\n  vec4 ixy0 = permute_4_7(ixy + iz0);\n  vec4 ixy1 = permute_4_7(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_4_8(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_4_8(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_4_9(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\n\n\nvoid main() {\n  float now = exponentialOut_1_0(max((time - delayAll - delay - (faceNormal.x + 1.0) / 2.0 - (faceNormal.y + 1.0) / 2.0) / duration, 0.0));\n  mat4 translateMat = calcTranslateMat4_3_1(vec3(faceNormal) * 1200.0 * (1.0 - now) + vec3(0.0, sin(time) * 10.0 + 210.0, 0.0));\n  mat4 rotateMat = calcRotateMat4_2_5(vec3(0.0, radians((1.0 - now) * faceNormal.y * 4320.0), 0.0));\n  float rotateRadian = radians((time + faceNormal.x + faceNormal.y) * 1440.0);\n  mat4 rotateMatSelf = calcRotateMat4_2_5(vec3(rotateRadian, rotateRadian, 0.0));\n  float noise = smoothstep(-0.4, 0.4,\n    cnoise_4_10(vec3(position.x * 0.035 - time, position.y * 0.035 - time, position.z * 0.035 + time))\n  ) * 2.0 - 1.0;\n  vec3 updatePositionSelf = (rotateMatSelf * vec4(position - center, 1.0)).xyz * (1.0 - now) + position\n    + normalize(position) * noise ;\n  vec4 updatePosition = rotateMat * translateMat * vec4(updatePositionSelf, 1.0);\n  vPosition = updatePosition.xyz;\n  vNoise = noise;\n  vNow = now;\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n'
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform mat3 normalMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying float vNoise;\nvarying float vNow;\n\nconst vec3 lightDirection = vec3(1.0, -1.0, -1.0);\nconst float duration = 2.0;\nconst float delayAll = 1.0;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main() {\n  float now = clamp((time - delayAll - 1.5) / duration, 0.0, 1.0);\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  vec3 light = normalize(normalMatrix * lightDirection);\n  float diff = (dot(normal, light) + 1.0) / 2.0 * 0.2;\n  float opacity = smoothstep(0.1, 0.2, vNow);\n  vec3 v = normalize(vPosition);\n  vec3 rgb = (1.0 - now) * vec3(1.0) + convertHsvToRgb_1_0(vec3(0.5 + (v.x + v.y + v.x) / 40.0 + time * 0.1, 0.8, 0.4 + sin(time) * 0.05 + vNoise * 0.02));\n  gl_FragColor = vec4(rgb + diff, opacity);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = (n(2), function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj = this.createObj()
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.OctahedronBufferGeometry(150, 4);
                    return new i.Mesh(t, new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(328),
                        fragmentShader: n(329),
                        transparent: !0,
                        side: i.DoubleSide,
                        depthWrite: !1
                    }))
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }())
}, function(t, e) {
    t.exports = '#define GLSLIFY 1\nattribute vec3 position;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying float vOpacity;\n\nconst float duration = 4.0;\nconst float delay = 3.0;\n\nfloat exponentialOut_1_0(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\n\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_4_1(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_4_1(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_4_2(vec4 x)\n{\n  return mod289_4_1(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_4_3(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_4_4(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_4_5(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_4_1(Pi0);\n  Pi1 = mod289_4_1(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_4_2(permute_4_2(ix) + iy);\n  vec4 ixy0 = permute_4_2(ixy + iz0);\n  vec4 ixy1 = permute_4_2(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_4_3(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_4_3(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_4_4(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\n\nmat4 calcTranslateMat4_2_6(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\n\nmat4 calcScaleMat4_3_7(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4X_6_8(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Y_7_9(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Z_8_10(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n\nmat4 calcRotateMat4_5_11(vec3 radian) {\n  return calcRotateMat4X_6_8(radian.x) * calcRotateMat4Y_7_9(radian.y) * calcRotateMat4Z_8_10(radian.z);\n}\n\n\n\nvoid main() {\n  float now = clamp((time - delay) / duration, 0.0, 1.0);\n  mat4 translateMat = calcTranslateMat4_2_6(vec3(0.0, sin(time) * 10.0 + 210.0, 0.0));\n  mat4 scaleMat = calcScaleMat4_3_7(vec3(exponentialOut_1_0(now) * 0.6 + 0.4 + sin(time * 2.0) * 0.04));\n  mat4 rotateMat = calcRotateMat4_5_11(vec3(radians(45.0), radians(time * 2.0), radians(-time * 2.0)));\n  float noise = smoothstep(-0.4, 0.4, cnoise_4_5(position * 0.035 - time)) * 2.0 - 1.0;\n  vec4 updatePosition = translateMat * rotateMat * scaleMat * vec4(position + normalize(position) * noise * 2.0, 1.0);\n  vPosition = normalize(position);\n  vOpacity = normalize(updatePosition).z;\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n'
}, function(t, e) {
    t.exports = 'precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vPosition;\nvarying float vOpacity;\n\nconst float duration = 4.0;\nconst float delay = 3.0;\n\nvec3 convertHsvToRgb_3_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1_1(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1_1(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1_2(vec4 x)\n{\n  return mod289_1_1(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_3(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_1_4(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_1_5(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_1_1(Pi0);\n  Pi1 = mod289_1_1(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_1_2(permute_1_2(ix) + iy);\n  vec4 ixy0 = permute_1_2(ixy + iz0);\n  vec4 ixy1 = permute_1_2(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_1_3(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_1_3(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_1_4(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\n\nfloat random_2_6(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n\nvoid main() {\n  float now = clamp((time - delay) / duration, 0.0, 1.0);\n  float noise1 = cnoise_1_5(vec3((vPosition * vec3(0.4, 2.0, -0.6) * 2.0 + time))) * 7.0 - (1.0 + (1.0 - now) * 7.0);\n  float noise2 = cnoise_1_5(vec3((vPosition * 42.0 + time)));\n  float noise3 = cnoise_1_5(vec3((vPosition * 7.0 + time))) * 2.0;\n  float bright = smoothstep(-0.2, 1.0, (noise1 + noise2 + noise3) * now);\n  vec3 v = normalize(vPosition);\n  vec3 rgb = (1.0 - now) * vec3(1.0) + convertHsvToRgb_3_0(vec3(0.5 + (v.x + v.y + v.x) / 40.0 + time * 0.1, 0.4, 1.0));\n  float whiteNoise = random_2_6(vPosition.xy);\n  if (bright < 0.4) discard;\n  gl_FragColor = vec4(rgb * vec3(1.0 - bright + 0.6) + whiteNoise * 0.2, 0.4 + vOpacity * 0.5 + sin(time * 2.0) * 0.1);\n}\n'
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(2),
        a = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj = this.createObj(), this.obj.position.set(0, -200, 0), this.obj.rotation.set(o.radians(-90), 0, 0)
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(1024, 1024, 32, 32), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(331),
                        fragmentShader: n(332),
                        transparent: !0,
                        wireframe: !0
                    }))
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\n\nvoid main() {\n  float sin1 = sin((position.x + position.y) * 0.2 + time * 0.5);\n  float sin2 = sin((position.x - position.y) * 0.4 + time * 2.0);\n  float sin3 = sin((position.x + position.y) * -0.6 + time);\n  vec3 updatePosition = vec3(position.x, position.y, position.z + sin1 * 50.0 + sin2 * 10.0 + sin3 * 8.0);\n  vPosition = position;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(updatePosition, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vPosition;\n\nconst float duration = 8.0;\nconst float delay = 4.0;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main() {\n  float now = clamp((time - delay) / duration, 0.0, 1.0);\n  float opacity = (1.0 - length(vPosition.xy / vec2(512.0))) * 0.6 * now;\n  vec3 v = normalize(vPosition);\n  vec3 rgb = convertHsvToRgb_1_0(vec3(0.5 + (v.x + v.y + v.x) / 40.0 + time * 0.1, 0.4, 1.0));\n  gl_FragColor = vec4(rgb, opacity);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = (n(2), function() {
            function t(e, n, r) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    rotate: {
                        type: "f",
                        value: 10 * Math.random()
                    }
                }, this.obj = this.createObj(), this.obj.position.set(e, n, r)
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.BoxBufferGeometry(100, 100, 100), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(334),
                        fragmentShader: n(335),
                        transparent: !0,
                        wireframe: !0
                    }))
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }())
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float rotate;\n\nmat4 calcRotateMat4X_4_0(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Y_2_1(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Z_3_2(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n\nmat4 calcRotateMat4_1_3(vec3 radian) {\n  return calcRotateMat4X_4_0(radian.x) * calcRotateMat4Y_2_1(radian.y) * calcRotateMat4Z_3_2(radian.z);\n}\n\n\n\nvoid main(void) {\n  mat4 rotateMat = calcRotateMat4_1_3(vec3(time * 0.1 + rotate));\n  vec4 updatePosition = rotateMat * vec4(position, 1.0);\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main() {\n  vec3 hsv = vec3(0.5 + time * 0.1, 0.4, 1.0);\n  vec3 rgb = convertHsvToRgb_1_0(hsv);\n  gl_FragColor = vec4(rgb, 0.25);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    resolution: {
                        type: "v2",
                        value: new i.Vector2(document.body.clientWidth, window.innerHeight)
                    },
                    texture: {
                        type: "t",
                        value: e
                    }
                }, this.obj = this.createObj(e), this.time = 1
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(337),
                        fragmentShader: n(338)
                    }))
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t * this.time
                }
            }, {
                key: "resize",
                value: function() {
                    this.uniforms.resolution.value.set(document.body.clientWidth, window.innerHeight)
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(t, e) {
    t.exports = 'precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform vec2 resolution;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nconst float duration = 8.0;\nconst float delay = 4.0;\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_3_0(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_3_0(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_3_1(vec4 x)\n{\n  return mod289_3_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_3_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_3_3(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_3_4(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_3_0(Pi0);\n  Pi1 = mod289_3_0(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_3_1(permute_3_1(ix) + iy);\n  vec4 ixy0 = permute_3_1(ixy + iz0);\n  vec4 ixy1 = permute_3_1(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_3_2(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_3_2(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_3_3(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\n\nfloat random_2_5(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec3 convertHsvToRgb_1_6(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main() {\n  float now = clamp((time - delay) / duration, 0.0, 1.0);\n\n  // ホワイトノイズ\n  float whiteNoise = random_2_5(vUv.xy * time) * 0.1 - 0.1;\n\n  // モニターエフェクト\n  float monitor1 = abs(sin(vUv.y * resolution.y * 2.4 + time * 10.0)) * 0.04;\n  float monitor2 = abs(sin(vUv.y * resolution.y * 1.0 + time * 3.0)) * 0.04;\n  float monitor = monitor1 - monitor2;\n\n  // ヴィネット\n  float vignetteMask = smoothstep(0.8, 1.4, length(vUv * 2.0 - 1.0));\n  vec3 vignetteColor = convertHsvToRgb_1_6(vec3(0.5 + (vUv.x + vUv.y) / 40.0 + time * 0.1, 0.4, 1.0));\n  vec3 vignette = vignetteMask * vignetteColor * 0.1;\n\n  // RGBズレ\n  float r = texture2D(texture, vUv - vec2(2.0, 0.0) / resolution).r;\n  float g = texture2D(texture, vUv).g;\n  float b = texture2D(texture, vUv + vec2(2.0, 0.0) / resolution).b;\n\n  gl_FragColor = vec4((vec3(r, g, b) + whiteNoise) + monitor + vignette, 1.0);\n}\n'
}, function(t, e, n) {
    "use strict";

    function r(t, e, n, r, i, o, a) {
        try {
            var s = t[o](a),
                c = s.value
        } catch (t) {
            return void n(t)
        }
        s.done ? e(c) : Promise.resolve(c).then(r, i)
    }
    n.r(e);
    var i = n(0),
        o = n(3),
        a = n(2),
        s = n(340).default,
        c = n(345).default,
        u = n(348).default,
        l = n(351).default,
        h = n(354).default,
        f = n(357).default;

    function d() {
        return (d = function(t) {
            return function() {
                var e = this,
                    n = arguments;
                return new Promise(function(i, o) {
                    var a = t.apply(e, n);

                    function s(t) {
                        r(a, i, o, s, c, "next", t)
                    }

                    function c(t) {
                        r(a, i, o, s, c, "throw", t)
                    }
                    s(void 0)
                })
            }
        }(regeneratorRuntime.mark(function t() {
            var e, n, r, d, v, p, m, g, y, x, b, w, _, M, S, E;
            return regeneratorRuntime.wrap(function(t) {
                for (;;) switch (t.prev = t.next) {
                    case 0:
                        return e = new i.Vector2, n = document.getElementById("canvas-webgl"), r = new i.WebGLRenderer({
                                alpha: !0,
                                antialias: !0,
                                canvas: n
                            }), d = new i.Scene, v = new i.PerspectiveCamera, p = new i.Clock({
                                autoStart: !1
                            }), m = new s, g = new c, y = new u, x = new l, b = new h, w = new f(e), _ = function() {
                                var t = p.getDelta();
                                w.render(e), m.render(t, w.v.y, w.v.x), g.render(t), y.render(t), x.render(t), r.render(d, v)
                            }, M = function t() {
                                _(), requestAnimationFrame(t)
                            }, S = function() {
                                v.aspect = e.x / e.y, v.updateProjectionMatrix(), v.setFocalLength(15 * a.step(1, e.y / e.x) + 35)
                            }, E = function() {
                                e.set(document.body.clientWidth, window.innerHeight), n.width = e.x, n.height = e.y, S(), r.setSize(e.x, e.y)
                            },
                            function() {
                                var t = function(t) {
                                        w.touchStart(t)
                                    },
                                    e = function(t) {
                                        w.touchMove(t)
                                    },
                                    r = function(t) {
                                        w.touchEnd(t)
                                    };
                                n.addEventListener("mousedown", t, {
                                    passive: !1
                                }), window.addEventListener("mousemove", e, {
                                    passive: !1
                                }), window.addEventListener("mouseup", r), n.addEventListener("touchstart", t, {
                                    passive: !1
                                }), window.addEventListener("touchmove", e, {
                                    passive: !1
                                }), window.addEventListener("touchend", r), window.addEventListener("resize", o(E, 1e3))
                            }(), E(), r.setClearColor(0, 1), v.far = 1e3, v.position.set(0, 14, 80), v.lookAt(new i.Vector3(0, 14, 0)), t.next = 25, m.createObj();
                    case 25:
                        return t.next = 27, g.createObj();
                    case 27:
                        y.createObj(), x.createObj(), b.createObj(), g.obj.renderOrder = 10, d.add(m.obj), d.add(g.obj), d.add(y.obj), d.add(x.obj), d.add(b.obj), p.start(), M();
                    case 38:
                    case "end":
                        return t.stop()
                }
            }, t, this)
        }))).apply(this, arguments)
    }
    e.default = function() {
        return d.apply(this, arguments)
    }
}, function(t, e, n) {
    "use strict";

    function r(t, e, n, r, i, o, a) {
        try {
            var s = t[o](a),
                c = s.value
        } catch (t) {
            return void n(t)
        }
        s.done ? e(c) : Promise.resolve(c).then(r, i)
    }

    function i(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return u
    });
    var o = n(0),
        a = n(2),
        s = n(341).default,
        c = n(131).default,
        u = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    tex: {
                        type: "t",
                        value: null
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && i(t.prototype, e), n && i(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = function(t) {
                        return function() {
                            var e = this,
                                n = arguments;
                            return new Promise(function(i, o) {
                                var a = t.apply(e, n);

                                function s(t) {
                                    r(a, i, o, s, c, "next", t)
                                }

                                function c(t) {
                                    r(a, i, o, s, c, "throw", t)
                                }
                                s(void 0)
                            })
                        }
                    }(regeneratorRuntime.mark(function t() {
                        var e, r;
                        return regeneratorRuntime.wrap(function(t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    return t.next = 2, s("/sketch-threejs/model/buddha/buddha_head.obj");
                                case 2:
                                    return e = t.sent, t.next = 5, c("/sketch-threejs/model/buddha/buddha_ao.jpg");
                                case 5:
                                    this.uniforms.tex.value = t.sent, r = new o.RawShaderMaterial({
                                        uniforms: this.uniforms,
                                        vertexShader: n(343),
                                        fragmentShader: n(344),
                                        flatShading: !0
                                    }), this.obj = new o.Mesh(e.children[0].geometry, r), this.obj.position.y = 16, this.obj.scale.set(7, 7, 7);
                                case 10:
                                case "end":
                                    return t.stop()
                            }
                        }, t, this)
                    }));
                    return function() {
                        return t.apply(this, arguments)
                    }
                }()
            }, {
                key: "render",
                value: function(t, e, n) {
                    this.uniforms.time.value += t, this.obj.rotation.set(a.radians(e - 15), a.radians(n + 15 - 5 * this.uniforms.time.value), a.radians(-20))
                }
            }]), t
        }()
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0);
    n(342);
    var i = new r.OBJLoader;
    e.default = function(t) {
        return new Promise(function(e, n) {
            i.load(t, e, null, n)
        })
    }
}, function(t, e, n) {
    var r = n(0);
    r.OBJLoader = function() {
        var t = /^[og]\s*(.+)?/,
            e = /^mtllib /,
            n = /^usemtl /;

        function i(t) {
            this.manager = void 0 !== t ? t : r.DefaultLoadingManager, this.materials = null
        }
        return i.prototype = {
            constructor: i,
            load: function(t, e, n, i) {
                var o = this,
                    a = new r.FileLoader(o.manager);
                a.setPath(this.path), a.load(t, function(t) {
                    e(o.parse(t))
                }, n, i)
            },
            setPath: function(t) {
                this.path = t
            },
            setMaterials: function(t) {
                return this.materials = t, this
            },
            parse: function(i) {
                console.time("OBJLoader");
                var o = new function() {
                    var t = {
                        objects: [],
                        object: {},
                        vertices: [],
                        normals: [],
                        colors: [],
                        uvs: [],
                        materialLibraries: [],
                        startObject: function(t, e) {
                            if (this.object && !1 === this.object.fromDeclaration) return this.object.name = t, void(this.object.fromDeclaration = !1 !== e);
                            var n = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
                            if (this.object && "function" == typeof this.object._finalize && this.object._finalize(!0), this.object = {
                                    name: t || "",
                                    fromDeclaration: !1 !== e,
                                    geometry: {
                                        vertices: [],
                                        normals: [],
                                        colors: [],
                                        uvs: []
                                    },
                                    materials: [],
                                    smooth: !0,
                                    startMaterial: function(t, e) {
                                        var n = this._finalize(!1);
                                        n && (n.inherited || n.groupCount <= 0) && this.materials.splice(n.index, 1);
                                        var r = {
                                            index: this.materials.length,
                                            name: t || "",
                                            mtllib: Array.isArray(e) && e.length > 0 ? e[e.length - 1] : "",
                                            smooth: void 0 !== n ? n.smooth : this.smooth,
                                            groupStart: void 0 !== n ? n.groupEnd : 0,
                                            groupEnd: -1,
                                            groupCount: -1,
                                            inherited: !1,
                                            clone: function(t) {
                                                var e = {
                                                    index: "number" == typeof t ? t : this.index,
                                                    name: this.name,
                                                    mtllib: this.mtllib,
                                                    smooth: this.smooth,
                                                    groupStart: 0,
                                                    groupEnd: -1,
                                                    groupCount: -1,
                                                    inherited: !1
                                                };
                                                return e.clone = this.clone.bind(e), e
                                            }
                                        };
                                        return this.materials.push(r), r
                                    },
                                    currentMaterial: function() {
                                        if (this.materials.length > 0) return this.materials[this.materials.length - 1]
                                    },
                                    _finalize: function(t) {
                                        var e = this.currentMaterial();
                                        if (e && -1 === e.groupEnd && (e.groupEnd = this.geometry.vertices.length / 3, e.groupCount = e.groupEnd - e.groupStart, e.inherited = !1), t && this.materials.length > 1)
                                            for (var n = this.materials.length - 1; n >= 0; n--) this.materials[n].groupCount <= 0 && this.materials.splice(n, 1);
                                        return t && 0 === this.materials.length && this.materials.push({
                                            name: "",
                                            smooth: this.smooth
                                        }), e
                                    }
                                }, n && n.name && "function" == typeof n.clone) {
                                var r = n.clone(0);
                                r.inherited = !0, this.object.materials.push(r)
                            }
                            this.objects.push(this.object)
                        },
                        finalize: function() {
                            this.object && "function" == typeof this.object._finalize && this.object._finalize(!0)
                        },
                        parseVertexIndex: function(t, e) {
                            var n = parseInt(t, 10);
                            return 3 * (n >= 0 ? n - 1 : n + e / 3)
                        },
                        parseNormalIndex: function(t, e) {
                            var n = parseInt(t, 10);
                            return 3 * (n >= 0 ? n - 1 : n + e / 3)
                        },
                        parseUVIndex: function(t, e) {
                            var n = parseInt(t, 10);
                            return 2 * (n >= 0 ? n - 1 : n + e / 2)
                        },
                        addVertex: function(t, e, n) {
                            var r = this.vertices,
                                i = this.object.geometry.vertices;
                            i.push(r[t + 0], r[t + 1], r[t + 2]), i.push(r[e + 0], r[e + 1], r[e + 2]), i.push(r[n + 0], r[n + 1], r[n + 2])
                        },
                        addVertexLine: function(t) {
                            var e = this.vertices;
                            this.object.geometry.vertices.push(e[t + 0], e[t + 1], e[t + 2])
                        },
                        addNormal: function(t, e, n) {
                            var r = this.normals,
                                i = this.object.geometry.normals;
                            i.push(r[t + 0], r[t + 1], r[t + 2]), i.push(r[e + 0], r[e + 1], r[e + 2]), i.push(r[n + 0], r[n + 1], r[n + 2])
                        },
                        addColor: function(t, e, n) {
                            var r = this.colors,
                                i = this.object.geometry.colors;
                            i.push(r[t + 0], r[t + 1], r[t + 2]), i.push(r[e + 0], r[e + 1], r[e + 2]), i.push(r[n + 0], r[n + 1], r[n + 2])
                        },
                        addUV: function(t, e, n) {
                            var r = this.uvs,
                                i = this.object.geometry.uvs;
                            i.push(r[t + 0], r[t + 1]), i.push(r[e + 0], r[e + 1]), i.push(r[n + 0], r[n + 1])
                        },
                        addUVLine: function(t) {
                            var e = this.uvs;
                            this.object.geometry.uvs.push(e[t + 0], e[t + 1])
                        },
                        addFace: function(t, e, n, r, i, o, a, s, c) {
                            var u = this.vertices.length,
                                l = this.parseVertexIndex(t, u),
                                h = this.parseVertexIndex(e, u),
                                f = this.parseVertexIndex(n, u);
                            if (this.addVertex(l, h, f), void 0 !== r) {
                                var d = this.uvs.length;
                                l = this.parseUVIndex(r, d), h = this.parseUVIndex(i, d), f = this.parseUVIndex(o, d), this.addUV(l, h, f)
                            }
                            if (void 0 !== a) {
                                var v = this.normals.length;
                                l = this.parseNormalIndex(a, v), h = a === s ? l : this.parseNormalIndex(s, v), f = a === c ? l : this.parseNormalIndex(c, v), this.addNormal(l, h, f)
                            }
                            this.colors.length > 0 && this.addColor(l, h, f)
                        },
                        addLineGeometry: function(t, e) {
                            this.object.geometry.type = "Line";
                            for (var n = this.vertices.length, r = this.uvs.length, i = 0, o = t.length; i < o; i++) this.addVertexLine(this.parseVertexIndex(t[i], n));
                            var a = 0;
                            for (o = e.length; a < o; a++) this.addUVLine(this.parseUVIndex(e[a], r))
                        }
                    };
                    return t.startObject("", !1), t
                }; - 1 !== i.indexOf("\r\n") && (i = i.replace(/\r\n/g, "\n")), -1 !== i.indexOf("\\\n") && (i = i.replace(/\\\n/g, ""));
                for (var a = i.split("\n"), s = "", c = "", u = [], l = "function" == typeof "".trimLeft, h = 0, f = a.length; h < f; h++)
                    if (s = a[h], 0 !== (s = l ? s.trimLeft() : s.trim()).length && "#" !== (c = s.charAt(0)))
                        if ("v" === c) {
                            var d = s.split(/\s+/);
                            switch (d[0]) {
                                case "v":
                                    o.vertices.push(parseFloat(d[1]), parseFloat(d[2]), parseFloat(d[3])), 8 === d.length && o.colors.push(parseFloat(d[4]), parseFloat(d[5]), parseFloat(d[6]));
                                    break;
                                case "vn":
                                    o.normals.push(parseFloat(d[1]), parseFloat(d[2]), parseFloat(d[3]));
                                    break;
                                case "vt":
                                    o.uvs.push(parseFloat(d[1]), parseFloat(d[2]))
                            }
                        } else if ("f" === c) {
                    for (var v = s.substr(1).trim().split(/\s+/), p = [], m = 0, g = v.length; m < g; m++) {
                        var y = v[m];
                        if (y.length > 0) {
                            var x = y.split("/");
                            p.push(x)
                        }
                    }
                    var b = p[0];
                    for (m = 1, g = p.length - 1; m < g; m++) {
                        var w = p[m],
                            _ = p[m + 1];
                        o.addFace(b[0], w[0], _[0], b[1], w[1], _[1], b[2], w[2], _[2])
                    }
                } else if ("l" === c) {
                    var M = s.substring(1).trim().split(" "),
                        S = [],
                        E = [];
                    if (-1 === s.indexOf("/")) S = M;
                    else
                        for (var T = 0, P = M.length; T < P; T++) {
                            var L = M[T].split("/");
                            "" !== L[0] && S.push(L[0]), "" !== L[1] && E.push(L[1])
                        }
                    o.addLineGeometry(S, E)
                } else if (null !== (u = t.exec(s))) {
                    var A = (" " + u[0].substr(1).trim()).substr(1);
                    o.startObject(A)
                } else if (n.test(s)) o.object.startMaterial(s.substring(7).trim(), o.materialLibraries);
                else if (e.test(s)) o.materialLibraries.push(s.substring(7).trim());
                else {
                    if ("s" !== c) {
                        if ("\0" === s) continue;
                        throw new Error('THREE.OBJLoader: Unexpected line: "' + s + '"')
                    }
                    if ((u = s.split(" ")).length > 1) {
                        var z = u[1].trim().toLowerCase();
                        o.object.smooth = "0" !== z && "off" !== z
                    } else o.object.smooth = !0;
                    (G = o.object.currentMaterial()) && (G.smooth = o.object.smooth)
                }
                o.finalize();
                var C = new r.Group;
                C.materialLibraries = [].concat(o.materialLibraries);
                for (h = 0, f = o.objects.length; h < f; h++) {
                    var R = o.objects[h],
                        I = R.geometry,
                        D = R.materials,
                        O = "Line" === I.type;
                    if (0 !== I.vertices.length) {
                        var F = new r.BufferGeometry;
                        F.addAttribute("position", new r.Float32BufferAttribute(I.vertices, 3)), I.normals.length > 0 ? F.addAttribute("normal", new r.Float32BufferAttribute(I.normals, 3)) : F.computeVertexNormals(), I.colors.length > 0 && F.addAttribute("color", new r.Float32BufferAttribute(I.colors, 3)), I.uvs.length > 0 && F.addAttribute("uv", new r.Float32BufferAttribute(I.uvs, 2));
                        for (var j, k = [], U = 0, B = D.length; U < B; U++) {
                            var N = D[U],
                                G = void 0;
                            if (null !== this.materials && (G = this.materials.create(N.name), O && G && !(G instanceof r.LineBasicMaterial))) {
                                var H = new r.LineBasicMaterial;
                                H.copy(G), G = H
                            }
                            G || ((G = O ? new r.LineBasicMaterial : new r.MeshPhongMaterial).name = N.name), G.flatShading = !N.smooth, k.push(G)
                        }
                        if (k.length > 1) {
                            for (U = 0, B = D.length; U < B; U++) {
                                N = D[U];
                                F.addGroup(N.groupStart, N.groupCount, U)
                            }
                            j = O ? new r.LineSegments(F, k) : new r.Mesh(F, k)
                        } else j = O ? new r.LineSegments(F, k[0]) : new r.Mesh(F, k[0]);
                        j.name = R.name, C.add(j)
                    }
                }
                return console.timeEnd("OBJLoader"), C
            }
        }, i
    }()
}, function(t, e) {
    t.exports = '#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform mat3 normalMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1_0(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1_0(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1_1(vec4 x)\n{\n  return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_1_3(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_1_4(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_1_0(Pi0);\n  Pi1 = mod289_1_0(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_1_1(permute_1_1(ix) + iy);\n  vec4 ixy0 = permute_1_1(ixy + iz0);\n  vec4 ixy1 = permute_1_1(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_1_2(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_1_2(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_1_3(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\n\n\nvoid main(void) {\n  //\n  float noise = cnoise_1_4(position * 0.8 + time * 0.4) * (sin(position.y - time * 0.8) * 1.4 + sin(position.y - time * 2.0) * 0.6) / 2.0;\n  vec3 noisePosition = normalize(position * vec3(1.0, 0.0, 1.0)) * pow(noise, 2.0) * 0.8;\n\n  // coordinate transformation\n  vec4 mvPosition = viewMatrix * modelMatrix * vec4(position + noisePosition, 1.0);\n\n  vPosition = (modelMatrix * vec4(position + noisePosition, 0.0)).xyz;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n'
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D tex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main() {\n  // Flat Shading\n  vec3 light = normalize(vec3(0.5, 0.5, 1.0));\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float d = (dot(normal, light) + 1.0) / 2.0;\n  float glow = smoothstep(0.85, 1.0, d);\n  float shadow = d;\n\n  // define colors.\n  vec3 hsv = vec3(0.13, 1.0 - glow * 0.8, (shadow + glow * 6.0) / 8.0);\n  vec3 rgb = convertHsvToRgb_1_0(hsv);\n\n  vec4 texColor = texture2D(tex, vUv);\n  gl_FragColor = vec4(rgb, 1.0) * texColor;\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e, n, r, i, o, a) {
        try {
            var s = t[o](a),
                c = s.value
        } catch (t) {
            return void n(t)
        }
        s.done ? e(c) : Promise.resolve(c).then(r, i)
    }

    function i(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return x
    });
    var o = n(0),
        a = n(2),
        s = n(131).default,
        c = 4,
        u = void 0,
        l = void 0,
        h = void 0,
        f = void 0,
        d = void 0,
        v = void 0,
        p = void 0,
        m = 0,
        g = 0,
        y = 0,
        x = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    texHannyaShingyo: {
                        type: "t",
                        value: void 0
                    },
                    unitUv: {
                        type: "f",
                        value: 0
                    },
                    duration: {
                        type: "f",
                        value: c
                    }
                }, this.obj = void 0
            }
            return function(t, e, n) {
                e && i(t.prototype, e), n && i(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = function(t) {
                        return function() {
                            var e = this,
                                n = arguments;
                            return new Promise(function(i, o) {
                                var a = t.apply(e, n);

                                function s(t) {
                                    r(a, i, o, s, c, "next", t)
                                }

                                function c(t) {
                                    r(a, i, o, s, c, "throw", t)
                                }
                                s(void 0)
                            })
                        }
                    }(regeneratorRuntime.mark(function t() {
                        var e, r, i, c, g, y, x, b, w;
                        return regeneratorRuntime.wrap(function(t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    for (e = "観自在菩薩行深般若波羅蜜多時照見五蘊皆空度一切苦厄舎利子色不異空空不異色色即是空空即是色受想行識亦復如是舎利子是諸法空相不生不滅不垢不浄不増不減是故空中無色無受想行識無眼耳鼻舌身意無色声香味触法無眼界乃至無意識界無無明亦無無明尽乃至無老死亦無老死尽無苦集滅道無智亦無得以無所得故菩提薩埵依般若波羅蜜多故心無罣礙無罣礙故無有恐怖遠離一切顛倒夢想究竟涅槃三世諸仏依般若波羅蜜多故得阿耨多羅三藐三菩提故知般若波羅蜜多是大神呪是大明呪是無上呪是無等等呪能除一切苦真実不虚故説般若波羅蜜多呪即説呪日羯諦羯諦波羅羯諦波羅僧羯諦菩提薩婆訶般若心経", r = 2048, i = Math.ceil(Math.sqrt(e.length)), r / i, c = new o.InstancedBufferGeometry, g = new o.PlaneBufferGeometry(6, 6), c.copy(g), m = e.length, u = new o.InstancedBufferAttribute(new Float32Array(3 * m), 3), l = new o.InstancedBufferAttribute(new Float32Array(2 * m), 2), h = new o.InstancedBufferAttribute(new Float32Array(m), 1), f = new o.InstancedBufferAttribute(new Float32Array(m), 1), d = new o.InstancedBufferAttribute(new Float32Array(m), 1), v = new o.InstancedBufferAttribute(new Float32Array(m), 1), p = new o.InstancedBufferAttribute(new Float32Array(m), 1), y = 0; y < i; y++)
                                        for (x = 0; x < i; x++) b = y * i + x, a.radians(360 * Math.random()), 20 * Math.random() + 5, l.setXY(b, x / i, (i - y - 1) / i), h.setX(b, b);
                                    return c.addAttribute("iPosition", u), c.addAttribute("iUv", l), c.addAttribute("iId", h), c.addAttribute("iTime", f), c.addAttribute("iIsAnimated", d), c.addAttribute("iScale", v), c.addAttribute("iMove", p), w = new o.RawShaderMaterial({
                                        uniforms: this.uniforms,
                                        vertexShader: n(346),
                                        fragmentShader: n(347),
                                        transparent: !0,
                                        depthWrite: !1
                                    }), t.next = 26, s("/sketch-threejs/img/sketch/buddha/hannya_text.png");
                                case 26:
                                    this.uniforms.texHannyaShingyo.value = t.sent, this.uniforms.unitUv.value = 1 / i, this.obj = new o.Mesh(c, w), this.obj.position.y = 0, this.obj.frustumCulled = !1;
                                case 31:
                                case "end":
                                    return t.stop()
                            }
                        }, t, this)
                    }));
                    return function() {
                        return t.apply(this, arguments)
                    }
                }()
            }, {
                key: "render",
                value: function(t) {
                    if (this.uniforms.time.value += t, (y += t) > .5) {
                        var e = a.radians(270 * Math.random() - 45),
                            n = 12 * Math.random() + 12;
                        u.setXYZ(g, Math.cos(e) * n, 0, Math.sin(e) * n), d.setX(g, 1), v.setX(g, .1 * (Math.random() + Math.random() - 1) + 1), p.setX(g, 5 * (Math.random() + Math.random() - 1) + 30), u.needsUpdate = !0, d.needsUpdate = !0, v.needsUpdate = !0, p.needsUpdate = !0, y = 0, g = g >= m - 1 ? 0 : g + 1
                    }
                    for (var r = 0; r < m; r++)
                        if (0 !== d.getX(r)) {
                            var i = f.getX(r);
                            i > c ? (d.setX(r, 0), f.setX(r, 0)) : f.setX(r, i + t)
                        }
                    d.needsUpdate = !0, f.needsUpdate = !0
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 iPosition;\nattribute vec2 iUv;\nattribute float iId;\nattribute float iTime;\nattribute float iIsAnimated;\nattribute float iScale;\nattribute float iMove;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float unitUv;\nuniform float duration;\n\nvarying vec3 vPositionNoise;\nvarying vec2 vUv;\nvarying vec2 vUvBase;\nvarying float vOpacity;\nvarying float vStep;\n\nmat4 calcScaleMat4_2_0(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4X_3_1(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Y_4_2(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Z_5_3(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n\nmat4 calcRotateMat4_1_4(vec3 radian) {\n  return calcRotateMat4X_3_1(radian.x) * calcRotateMat4Y_4_2(radian.y) * calcRotateMat4Z_5_3(radian.z);\n}\n\n\n\nvoid main(void) {\n  vec3 move = vec3(0.0, iTime / duration * iMove, 0.0);\n  mat4 scaleMat = calcScaleMat4_2_0(vec3(iScale));\n  mat4 rotateMat = calcRotateMat4_1_4(vec3(\n    radians(sin(time * 0.3 + iId * 30.0) * 30.0),\n    radians(cos(time * 0.3 + iId * 30.0) * 45.0),\n    radians(cos(time * 0.3 + iId * 30.0) * 30.0)\n  ));\n  vec3 updatePosition = (rotateMat * scaleMat * vec4(position, 1.0)).xyz;\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(iPosition + move + updatePosition, 1.0);\n\n  vPositionNoise = position + iId;\n  vUv = uv * unitUv + iUv;\n  vUvBase = uv;\n  vOpacity = iIsAnimated;\n  vStep = iTime / duration;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = 'precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D texHannyaShingyo;\n\nvarying vec3 vPositionNoise;\nvarying vec2 vUv;\nvarying vec2 vUvBase;\nvarying float vOpacity;\nvarying float vStep;\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1_0(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1_0(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1_1(vec4 x)\n{\n  return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_1_3(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_1_4(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_1_0(Pi0);\n  Pi1 = mod289_1_0(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_1_1(permute_1_1(ix) + iy);\n  vec4 ixy0 = permute_1_1(ixy + iz0);\n  vec4 ixy1 = permute_1_1(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_1_2(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_1_2(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_1_3(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\n\nvec3 convertHsvToRgb_2_5(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main() {\n  // coordinate tex color.\n  vec4 texColor = texture2D(texHannyaShingyo, vUv);\n\n  // coordinate cross fade alpha value with delay.\n  float dRange = 0.1;\n  float crossFadeDelay = vUvBase.y * dRange;\n  float crossFade = smoothstep(crossFadeDelay, crossFadeDelay + 0.3, vStep)\n    * (1.0 - smoothstep(crossFadeDelay + 0.7 - dRange, crossFadeDelay + 1.0 - dRange, vStep));\n\n  // dissolve effect.\n  float noise1 = cnoise_1_4(vec3(vPositionNoise * 0.7));\n  float noise2 = cnoise_1_4(vec3(vPositionNoise * 1.8));\n  float noiseAll = (noise1 * 2.0 + noise2 * 0.4) / 2.4;\n  float noise = (noiseAll * 0.5 + 0.5) + (crossFade * 2.0 - 1.0);\n  float disolveMask = smoothstep(0.28, 0.3, noise);\n  vec4 disolve = vec4(convertHsvToRgb_2_5(vec3(0.13, 0.9, 0.75)), 1.0) * disolveMask;\n  float disolveEdgeMask = smoothstep(0.0, 0.02, noise) * (1.0 - smoothstep(0.28, 0.3, noise));\n  vec4 disolveEdge = vec4(convertHsvToRgb_2_5(vec3(0.13, 0.4, 1.0)), 1.0) * disolveEdgeMask;\n\n  // glow\n  float glow = cnoise_1_4(vPositionNoise * 0.25 + time) * 0.5;\n\n  gl_FragColor = (disolve + disolveEdge + vec4(vec3(glow), 0.0)) * vOpacity * texColor.a;\n}\n'
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(2),
        a = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.PlaneBufferGeometry(70, 70, 512, 512),
                        e = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(349),
                            fragmentShader: n(350),
                            transparent: !0,
                            flatShading: !0
                        });
                    this.obj = new i.Mesh(t, e), this.obj.rotation.set(o.radians(-90), 0, 0)
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform mat3 normalMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\nvoid main(void) {\n  vec2 p = uv * 2.0 - 1.0;\n\n  // wave motion.\n  float force = pow(smoothstep(0.0, 0.5, length(p)) * (1.0 - smoothstep(0.5, 1.0, length(p))), 2.0) * 1.8;\n  vec3 wave = vec3(0.0, 0.0, (sin(-time * 4.0 + length(p.xy) * 24.0) * 0.5 + 0.5) * force);\n\n  // coordinate transformation\n  vec3 updatePosition = position + wave;\n  vec4 mvPosition = viewMatrix * modelMatrix * vec4(updatePosition, 1.0);\n\n  vPosition = updatePosition;\n  vUv = uv;\n  vOpacity = 1.0 - smoothstep(0.9, 1.0, length(p));\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main() {\n  // Flat Shading\n  vec3 light = normalize(vec3(0.5, 0.5, 1.0));\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = (dot(normal, light) + 1.0) / 2.0;\n  float glow = smoothstep(0.9, 1.0, diff);\n\n  vec3 hsv = vec3(0.13, 1.0 - glow * 0.8, 0.05 + glow * 0.95);\n  vec3 rgb = convertHsvToRgb_1_0(hsv);\n\n  gl_FragColor = vec4(rgb, vOpacity);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(2),
        a = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    for (var t = new i.BufferGeometry, e = [], r = [], a = [], s = 0; s < 1800; s += 3) {
                        var c = Math.random() * Math.random() * 60 + 20,
                            u = o.radians(360 * Math.random());
                        e[s + 0] = Math.cos(u) * c, e[s + 1] = 0, e[s + 2] = Math.sin(u) * c, r[s / 3] = 120 * Math.random(), a[s / 3] = 120 * Math.random()
                    }
                    var l = new i.BufferAttribute(new Float32Array(e), 3),
                        h = new i.BufferAttribute(new Float32Array(r), 1),
                        f = new i.BufferAttribute(new Float32Array(a), 1);
                    t.addAttribute("position", l), t.addAttribute("delay1", h), t.addAttribute("delay2", f);
                    var d = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(352),
                        fragmentShader: n(353),
                        transparent: !0,
                        depthWrite: !1,
                        blending: i.AdditiveBlending
                    });
                    this.obj = new i.Points(t, d)
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute float delay1;\nattribute float delay2;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nconst float duration = 120.0;\n\nvoid main() {\n  // Loop animation\n  float interval = mod(time + delay1, duration) / duration;\n  vec3 move = vec3(\n    cos(time * 0.5 + delay1) * 2.0,\n    interval * 100.0,\n    sin(time * 0.5 + delay2) * 2.0\n    );\n\n  // calculate gradation with position.y\n  vec3 hsv = vec3(0.14, 0.65, 0.85);\n  vec3 rgb = convertHsvToRgb_1_0(hsv);\n\n  // calculate opacity.\n  float fadeIn = smoothstep(0.0, 10.0, move.y);\n  float blink = sin(time * 0.1 + delay2);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position + move, 1.0);\n  float distanceFromCamera = 1000.0 / length(mvPosition.xyz);\n\n  vColor = rgb;\n  vOpacity = fadeIn * blink;\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = distanceFromCamera;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main() {\n  // Convert PointCoord to a range from -1.0 to 1.0\n  vec2 p = gl_PointCoord * 2.0 - 1.0;\n\n  // Draw double circle\n  float radius = length(p);\n  float opacity = (1.0 - smoothstep(0.2, 1.0, radius)) * vOpacity;\n\n  gl_FragColor = vec4(vColor, opacity);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = (n(2), function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.SphereBufferGeometry(100, 128, 128),
                        e = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(355),
                            fragmentShader: n(356),
                            side: i.BackSide
                        });
                    this.obj = new i.Mesh(t, e), this.obj.position.y = 16
                }
            }, {
                key: "render",
                value: function(t, e) {
                    this.uniforms.force.value = e, this.uniforms.time.value += t * (1.2 * e)
                }
            }]), t
        }())
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vColor;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main(void) {\n  vec2 p = uv * 2.0 - 1.0;\n  // calculate gradation\n  vec3 hsv = vec3(0.13, 0.8, p.y * 0.8 + 0.04);\n  vec3 rgb = convertHsvToRgb_1_0(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(2),
        a = function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.resolution = e, this.vTouchStart = new i.Vector2, this.vPrev = new i.Vector2, this.v = new i.Vector2, this.a = new i.Vector2, this.anchor = new i.Vector2, this.isTouched = !1
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "touchStart",
                value: function(t) {
                    t.touches || t.preventDefault(), this.vPrev.copy(this.v), this.a.set(0, 0), this.vTouchStart.set(t.touches ? t.touches[0].clientX : t.clientX, t.touches ? t.touches[0].clientY : t.clientY), this.isTouched = !0
                }
            }, {
                key: "touchMove",
                value: function(t) {
                    var e = t.touches ? t.touches[0].clientX : t.clientX,
                        n = t.touches ? t.touches[0].clientY : t.clientY;
                    !1 !== this.isTouched && (this.anchor.set((e - this.vTouchStart.x) / (this.resolution.x / 200) + this.vPrev.x, o.clamp((n - this.vTouchStart.y) / (this.resolution.y / 200) + this.vPrev.y, -90, 90)), t.touches && t.preventDefault())
                }
            }, {
                key: "touchEnd",
                value: function(t) {
                    this.isTouched = !1, this.isDraging = !1
                }
            }, {
                key: "render",
                value: function() {
                    this.a.set((this.anchor.x - this.v.x) / 10, (this.anchor.y - this.v.y) / 10), this.v.add(this.a)
                }
            }]), t
        }()
}, function(t, e, n) {
    "use strict";

    function r(t, e, n, r, i, o, a) {
        try {
            var s = t[o](a),
                c = s.value
        } catch (t) {
            return void n(t)
        }
        s.done ? e(c) : Promise.resolve(c).then(r, i)
    }
    n.r(e);
    var i = n(0),
        o = n(3),
        a = n(2),
        s = n(359).default,
        c = n(362).default,
        u = n(365).default,
        l = n(368).default,
        h = n(371).default;

    function f() {
        return (f = function(t) {
            return function() {
                var e = this,
                    n = arguments;
                return new Promise(function(i, o) {
                    var a = t.apply(e, n);

                    function s(t) {
                        r(a, i, o, s, c, "next", t)
                    }

                    function c(t) {
                        r(a, i, o, s, c, "throw", t)
                    }
                    s(void 0)
                })
            }
        }(regeneratorRuntime.mark(function t() {
            var e, n, r, f, d, v, p, m, g, y, x, b, w, _, M, S, E;
            return regeneratorRuntime.wrap(function(t) {
                for (;;) switch (t.prev = t.next) {
                    case 0:
                        return e = new i.Vector2, n = document.getElementById("canvas-webgl"), r = new i.WebGLRenderer({
                                alpha: !0,
                                antialias: !0,
                                canvas: n
                            }), f = new i.Scene, d = new i.PerspectiveCamera, v = new i.Clock({
                                autoStart: !1
                            }), p = Math.random(), m = new s(p), g = new c(p), y = new u, x = new l(p), b = new i.Group, w = new h(e), _ = function() {
                                var t = v.getDelta();
                                w.render(e), b.rotation.set(a.radians(w.v.y), a.radians(w.v.x), 0), m.render(t), g.render(t), y.render(t), x.render(t), r.render(f, d)
                            }, M = function t() {
                                _(), requestAnimationFrame(t)
                            }, S = function() {
                                d.aspect = e.x / e.y, d.updateProjectionMatrix(), d.setFocalLength(15 * a.step(1, e.y / e.x) + 35)
                            }, E = function() {
                                e.set(document.body.clientWidth, window.innerHeight), n.width = e.x, n.height = e.y, S(), r.setSize(e.x, e.y)
                            },
                            function() {
                                var t = function(t) {
                                        w.touchStart(t)
                                    },
                                    e = function(t) {
                                        w.touchMove(t)
                                    },
                                    r = function(t) {
                                        w.touchEnd(t)
                                    };
                                n.addEventListener("mousedown", t, {
                                    passive: !1
                                }), window.addEventListener("mousemove", e, {
                                    passive: !1
                                }), window.addEventListener("mouseup", r), n.addEventListener("touchstart", t, {
                                    passive: !1
                                }), window.addEventListener("touchmove", e, {
                                    passive: !1
                                }), window.addEventListener("touchend", r), window.addEventListener("resize", o(E, 1e3))
                            }(), E(), r.setClearColor(0, 1), d.far = 1e3, d.setFocalLength(15 * a.step(1, e.y / e.x) + 35), d.position.set(0, 0, 300), d.lookAt(new i.Vector3(0, 0, 0)), m.createObj(), g.createObj(), y.createObj(), x.createObj(), b.add(m.obj), b.add(g.obj), b.add(y.obj), f.add(b), f.add(x.obj), v.start(), M(), t.abrupt("return");
                    case 37:
                    case "end":
                        return t.stop()
                }
            }, t, this)
        }))).apply(this, arguments)
    }
    e.default = function() {
        return f.apply(this, arguments)
    }
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return s
    });
    var i = n(0),
        o = n(2),
        a = n(132),
        s = function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    addH1: {
                        type: "f",
                        value: e
                    },
                    addH2: {
                        type: "f",
                        value: e - .5
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    for (var t = new a(Math.random), e = new i.OctahedronBufferGeometry(50, 5), r = 0; r < e.attributes.position.count; r++) {
                        var s = new i.Vector3(e.attributes.position.getX(r), e.attributes.position.getY(r), e.attributes.position.getZ(r)),
                            c = t.noise4D(s.x / 72, s.y / 64, s.z / 72, 1),
                            u = t.noise4D(s.x / 28, s.y / 24, s.z / 28, 1),
                            l = t.noise4D(s.x / 4, s.y / 4, s.z / 4, 1),
                            h = (2 * o.smoothstep(-.05, .05, c + u) - 1) * (2 + 2 * o.smoothstep(.1, .2, Math.pow(c + u, 2)) + 6 * o.smoothstep(.6, .7, Math.pow(c + u, 2)) + .2 * l);
                        s.add(s.clone().normalize().multiplyScalar(h)), e.attributes.position.setXYZ(r, s.x, s.y, s.z)
                    }
                    var f = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(360),
                        fragmentShader: n(361),
                        flatShading: !0
                    });
                    this.obj = new i.Mesh(e, f)
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec3 vMPosition;\nvarying float vHeight;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position, 1.0);\n\n  vHeight = length(position);\n  vMPosition = mPosition.xyz;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float addH1;\nuniform float addH2;\n\nvarying vec3 vMPosition;\nvarying float vHeight;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nconst float edge1 = 56.0;\nconst float edge2 = 52.0;\nconst float edge3 = 50.0;\nconst float range = 2.0;\n\nvoid main() {\n  // Flat Shading\n  vec3 light = normalize(vec3(-1.0, 1.0, 1.0));\n  vec3 normal = normalize(cross(dFdx(vMPosition), dFdy(vMPosition)));\n  float diff = (dot(normal, light) + 1.0) / 2.0;\n\n  float stepTop     = smoothstep(edge1, edge1 + range, vHeight);\n  float stepMiddle1 = smoothstep(edge2, edge2 + range, vHeight) * (1.0 - smoothstep(edge1, edge1 + range, vHeight));\n  float stepMiddle2 = smoothstep(edge3, edge3 + range, vHeight) * (1.0 - smoothstep(edge2, edge2 + range, vHeight));\n  float stepBottom  = 1.0 - smoothstep(edge3, edge3 + range, vHeight);\n\n  vec4 colorTop     = vec4(convertHsvToRgb_1_0(vec3(0.25 + addH1, 0.05, 1.0)), 1.0) * stepTop;\n  vec4 colorMiddle1 = vec4(convertHsvToRgb_1_0(vec3(0.25 + addH2, 0.05, 1.0)), 1.0) * stepMiddle1;\n  vec4 colorMiddle2 = vec4(convertHsvToRgb_1_0(vec3(0.25 + addH2, 0.1, 0.9)), 1.0) * stepMiddle2;\n  vec4 colorBottom  = vec4(convertHsvToRgb_1_0(vec3(0.25 + addH1, 0.1, 0.9)), 1.0) * stepBottom;\n\n  vec4 colorAll = (colorTop + colorMiddle1 + colorMiddle2 + colorBottom) * diff;\n\n  gl_FragColor = colorAll;\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = (n(2), function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    addH: {
                        type: "f",
                        value: e
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.OctahedronBufferGeometry(50, 5),
                        e = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(363),
                            fragmentShader: n(364),
                            flatShading: !0,
                            transparent: !0
                        });
                    this.obj = new i.Mesh(t, e)
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }())
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying float vSinAll;\n\nmat4 calcTranslateMat4_1_0(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\n\n\nvoid main(void) {\n  float sin1 = sin(time + position.x / 16.0);\n  float sin2 = sin(time + position.y / 8.0);\n  float sin3 = sin(time - length(position.xy + 50.0) / 4.0);\n  float sinAll = (sin1 + sin2 * 0.5 + sin3 * 0.2) / 1.7;\n  mat4 waveMat = calcTranslateMat4_1_0(vec3(0.0, 0.0, sinAll * 1.5));\n\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * waveMat * vec4(position, 1.0);\n\n  vPosition = mPosition.xyz;\n  vSinAll = sinAll;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float addH;\n\nvarying vec3 vPosition;\nvarying float vSinAll;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main() {\n  // Flat Shading\n  vec3 light = normalize(vec3(-1.0, 1.0, 1.0));\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = (dot(normal, light) + 1.0) / 2.0;\n\n  vec4 color = vec4(convertHsvToRgb_1_0(vec3(0.2 + vSinAll * 0.08 + addH, 0.4, 1.0)), 0.8);\n\n  gl_FragColor = color * vec4(vec3(diff), 1.0);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(2),
        a = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.num = 40, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.InstancedBufferGeometry,
                        e = new i.BoxBufferGeometry(2, 2, 20, 2, 2, 6);
                    t.copy(e);
                    for (var r = new i.InstancedBufferAttribute(new Float32Array(3 * this.num), 3), a = new i.InstancedBufferAttribute(new Float32Array(3 * this.num), 3), s = new i.InstancedBufferAttribute(new Float32Array(3 * this.num), 3), c = new i.InstancedBufferAttribute(new Float32Array(this.num), 1), u = 0, l = this.num; u < l; u++) {
                        var h = o.radians(30 * (2 * Math.random() - 1)),
                            f = o.radians(180 * (2 * Math.random() - 1)),
                            d = o.spherical(h, f, 12 * Math.random() + 65);
                        r.setXYZ(u, d[0], d[1], d[2]), a.setXYZ(u, 0, f, -h), s.setXYZ(u, 1, .2 * Math.random() + 1, .4 * Math.random() + .8), c.setXYZ(u, .05 * Math.random() + .01)
                    }
                    t.addAttribute("instancePosition", r), t.addAttribute("instanceRotate", a), t.addAttribute("instanceScale", s), t.addAttribute("speed", c);
                    var v = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(366),
                        fragmentShader: n(367),
                        flatShading: !0
                    });
                    this.obj = new i.Mesh(t, v), this.obj.frustumCulled = !1
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 instancePosition;\nattribute vec3 instanceRotate;\nattribute vec3 instanceScale;\nattribute float speed;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\n\nmat4 calcTranslateMat4_4_0(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4X_6_1(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Y_7_2(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Z_8_3(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n\nmat4 calcRotateMat4_3_4(vec3 radian) {\n  return calcRotateMat4X_6_1(radian.x) * calcRotateMat4Y_7_2(radian.y) * calcRotateMat4Z_8_3(radian.z);\n}\n\n\nmat4 calcScaleMat4_1_5(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_2_6(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_2_6(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_2_7(vec4 x) {\n     return mod289_2_6(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_2_8(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_2_9(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_2_10 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_2_11 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_2_11;\n  vec3 i1 = min( g_2_11.xyz, l.zxy );\n  vec3 i2 = max( g_2_11.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_2_10.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_2_6(i);\n  vec4 p = permute_2_7( permute_2_7( permute_2_7(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_2_10.wyz - D_2_10.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_2_12 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_2_13 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_2_12.xy,h.z);\n  vec3 p3 = vec3(a1_2_12.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_2_8(vec4(dot(p0_2_13,p0_2_13), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_2_13 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_2_13,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\nfloat exponentialOut_5_14(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\n\n\n\nvoid main(void) {\n  // added Noise to form like a cloud.\n  float noise = snoise_2_9(position + instancePosition);\n  vec3 noiseEasePos = normalize(vec3(position.x, position.y, 0.01)) * exponentialOut_5_14(1.0 - abs(position.z / 10.0)) * vec3(0.4, 1.0, 1.0);\n  vec3 noisePosition = (noise + 1.0) / 2.0 * noiseEasePos * 3.0 + noiseEasePos * 1.0;\n\n  // coordinate transformation\n  mat4 translateMat = calcTranslateMat4_4_0(instancePosition);\n  mat4 rotateMat = calcRotateMat4_3_4(instanceRotate);\n  mat4 scaleMat = calcScaleMat4_1_5(instanceScale);\n  mat4 worldRotateMat = calcRotateMat4_3_4(vec3(0.0, -time * speed, 0.0));\n  vec4 mvPosition = modelViewMatrix * worldRotateMat * translateMat * rotateMat * scaleMat * vec4(position + noisePosition, 1.0);\n\n  vPosition = mvPosition.xyz;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPosition;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main() {\n  // Flat Shading\n  vec3 light = normalize(vec3(-1.0, 1.0, 1.0));\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = (dot(normal, light) + 1.0) / 2.0;\n\n  vec3 hsv = vec3(0.0, 0.0, 0.8 + diff * 0.2);\n  vec3 rgb = convertHsvToRgb_1_0(hsv);\n\n  gl_FragColor = vec4(rgb, 1.0);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = (n(2), function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    addH: {
                        type: "f",
                        value: e + .3
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.SphereBufferGeometry(200, 128, 128),
                        e = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(369),
                            fragmentShader: n(370),
                            side: i.BackSide
                        });
                    this.obj = new i.Mesh(t, e)
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }())
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float addH;\n\nvarying vec3 vColor;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main(void) {\n  // calculate gradation with position.y\n  vec3 hsv1 = vec3(addH + 0.22, 0.12, 0.96);\n  vec3 hsv2 = vec3(addH - 0.22, 0.12, 0.96);\n  vec3 rgb = convertHsvToRgb_1_0(mix(hsv1, hsv2, (normalize(position).y + 1.0) / 2.0));\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D tex;\n\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(2),
        a = function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.resolution = e, this.vTouchStart = new i.Vector2, this.vPrev = new i.Vector2, this.v = new i.Vector2, this.a = new i.Vector2, this.anchor = new i.Vector2, this.isTouched = !1
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "touchStart",
                value: function(t) {
                    t.touches || t.preventDefault(), this.vPrev.copy(this.v), this.a.set(0, 0), this.vTouchStart.set(t.touches ? t.touches[0].clientX : t.clientX, t.touches ? t.touches[0].clientY : t.clientY), this.isTouched = !0
                }
            }, {
                key: "touchMove",
                value: function(t) {
                    var e = t.touches ? t.touches[0].clientX : t.clientX,
                        n = t.touches ? t.touches[0].clientY : t.clientY;
                    !1 !== this.isTouched && (this.anchor.set((e - this.vTouchStart.x) / (this.resolution.x / 200) + this.vPrev.x, o.clamp((n - this.vTouchStart.y) / (this.resolution.y / 200) + this.vPrev.y, -90, 90)), t.touches && t.preventDefault())
                }
            }, {
                key: "touchEnd",
                value: function(t) {
                    this.isTouched = !1, this.isDraging = !1
                }
            }, {
                key: "render",
                value: function() {
                    this.a.set((this.anchor.x - this.v.x) / 10, (this.anchor.y - this.v.y) / 10), this.v.add(this.a)
                }
            }]), t
        }()
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(2),
        a = n(373).default,
        s = n(376).default,
        c = n(379).default;
    e.default = function() {
        var t = new r.Vector2,
            e = document.getElementById("canvas-webgl"),
            n = new r.WebGLRenderer({
                alpha: !0,
                antialias: !0,
                canvas: e
            }),
            u = new r.Scene,
            l = new r.PerspectiveCamera,
            h = new r.Clock({
                autoStart: !1
            });
        l.far = 1e3, l.setFocalLength(50);
        var f = Math.random(),
            d = new a(f),
            v = new s(f),
            p = new r.Group,
            m = new c,
            g = function() {
                t.set(document.body.clientWidth, window.innerHeight), e.width = t.x, e.height = t.y, l.aspect = t.x / t.y, l.updateProjectionMatrix(), n.setSize(t.x, t.y)
            };
        n.setClearColor(0,0), l.position.set(0, 0, 300), l.lookAt(new r.Vector3(0, 0, 0)), d.createObj(), v.createObj(), p.add(d.obj), p.add(v.obj), u.add(p),
            function() {
                var t = function(t) {
                        m.touchStart(t)
                    },
                    n = function(t) {
                        m.touchMove(t)
                    },
                    r = function(t) {
                        m.touchEnd(t)
                    };
                e.addEventListener("mousedown", t, {
                    passive: !1
                }), window.addEventListener("mousemove", n, {
                    passive: !1
                }), window.addEventListener("mouseup", r), e.addEventListener("touchstart", t, {
                    passive: !1
                }), window.addEventListener("touchmove", n, {
                    passive: !1
                }), window.addEventListener("touchend", r), window.addEventListener("resize", i(g, 1e3))
            }(), g(), h.start(),
            function e() {
                ! function() {
                    var e = h.getDelta();
                    m.render(t), p.rotation.set(o.radians(m.v.y / t.x * 1e3 + 45), o.radians(m.v.x / t.y * 1e3 - 30), 0), d.render(e), v.render(e), n.render(u, l)
                }(), requestAnimationFrame(e)
            }()
    }
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return s
    });
    var i = n(0),
        o = n(2),
        a = n(132),
        s = function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    addH1: {
                        type: "f",
                        value: e - .5
                    },
                    addH2: {
                        type: "f",
                        value: e
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    for (var t = new a(Math.random), e = new i.BoxBufferGeometry(100, 5, 100, 60, 1, 60), r = 0; r < e.attributes.position.count; r++) {
                        var s = e.attributes.position.getX(r),
                            c = e.attributes.position.getY(r),
                            u = e.attributes.position.getZ(r),
                            l = 48 * (.75 * t.noise4D(s / 80, c / 80, u / 80, 1) + .25) + 18 * t.noise4D(s / 48, c / 32, u / 32, 1) + 1.2 * t.noise4D(s / 6, c / 6, u / 6, 1) + .6 * t.noise4D(s / 2, c / 2, u / 2, 1),
                            h = function(t, e, n) {
                                if (!(t >= e)) {
                                    var r = o.clamp((n - t) / (e - t), 0, 1);
                                    return r * r * (3 - 2 * r)
                                }
                            }(0, 5, l),
                            f = function(t, e) {
                                return e >= t ? 1 : 0
                            }(0, c);
                        e.attributes.position.setY(r, (c + l * h) * f)
                    }
                    var d = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(374),
                        fragmentShader: n(375),
                        flatShading: !0
                    });
                    this.obj = new i.Mesh(e, d)
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec3 vPosition;\nvarying vec3 vMPosition;\nvarying vec2 vUv;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vMPosition = mPosition.xyz;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float addH1;\nuniform float addH2;\n\nvarying vec3 vPosition;\nvarying vec3 vMPosition;\nvarying vec2 vUv;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nconst float edge1 = 48.0;\nconst float edge2 = 24.0;\nconst float edge3 = 8.0;\nconst float range = 14.0;\n\nvoid main() {\n  // Flat Shading\n  vec3 light = normalize(vec3(-1.0, 1.0, 1.0));\n  vec3 normal = normalize(cross(dFdx(vMPosition), dFdy(vMPosition)));\n  float diff = (dot(normal, light) + 1.0) / 2.0;\n\n  float stepTop     = smoothstep(edge1, edge1 + range, vPosition.y);\n  float stepMiddle1 = smoothstep(edge2, edge2 + range, vPosition.y) * (1.0 - smoothstep(edge1, edge1 + range, vPosition.y));\n  float stepMiddle2 = smoothstep(edge3, edge3 + range, vPosition.y) * (1.0 - smoothstep(edge2, edge2 + range, vPosition.y));\n  float stepBottom  = 1.0 - smoothstep(edge3, edge3 + range, vPosition.y);\n\n  vec4 colorTop     = vec4(convertHsvToRgb_1_0(vec3( 0.1 + addH1, 0.1, 0.8)), 1.0) * stepTop;\n  vec4 colorMiddle1 = vec4(convertHsvToRgb_1_0(vec3(0.25 + addH2, 0.4, 0.6)), 1.0) * stepMiddle1;\n  vec4 colorMiddle2 = vec4(convertHsvToRgb_1_0(vec3(0.25 + addH2, 0.25, 0.8)), 1.0) * stepMiddle2;\n  vec4 colorBottom  = vec4(convertHsvToRgb_1_0(vec3( 0.1 + addH1, 0.4, 0.3)), 1.0) * stepBottom;\n\n  vec4 colorAll = (colorTop + colorMiddle1 + colorMiddle2 + colorBottom) * diff;\n\n  gl_FragColor = colorAll;\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(2),
        a = function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    addH: {
                        type: "f",
                        value: e - .5
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.PlaneBufferGeometry(100, 100, 60, 60),
                        e = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(377),
                            fragmentShader: n(378),
                            flatShading: !0,
                            transparent: !0
                        });
                    this.obj = new i.Mesh(t, e), this.obj.translateY(8), this.obj.rotation.set(o.radians(-90), 0, 0)
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vSinAll;\n\nmat4 calcTranslateMat4_1_0(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\n\n\nvoid main(void) {\n  float sin1 = sin(time + position.x / 16.0);\n  float sin2 = sin(time + position.y / 8.0);\n  float sin3 = sin(time - length(position.xy + 50.0) / 4.0);\n  float sinAll = (sin1 + sin2 * 0.5 + sin3 * 0.2) / 1.7;\n  mat4 waveMat = calcTranslateMat4_1_0(vec3(0.0, 0.0, sinAll * 1.5));\n\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * waveMat * vec4(position, 1.0);\n\n  vPosition = mPosition.xyz;\n  vUv = uv;\n  vSinAll = sinAll;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float addH;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vSinAll;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main() {\n  // Flat Shading\n  vec3 light = normalize(vec3(-1.0, 1.0, 1.0));\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = dot(normal, light);\n\n  vec4 color = vec4(convertHsvToRgb_1_0(vec3(0.2 + vSinAll * 0.15 + addH, 0.2, 1.0)), 0.4);\n\n  gl_FragColor = color * vec4(vec3(diff), 1.0);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.vTouchStart = new i.Vector2, this.vPrev = new i.Vector2, this.v = new i.Vector2, this.a = new i.Vector2, this.anchor = new i.Vector2, this.isTouched = !1
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "touchStart",
                value: function(t) {
                    t.touches || t.preventDefault(), this.vPrev.copy(this.v), this.a.set(0, 0), this.vTouchStart.set(t.touches ? t.touches[0].clientX : t.clientX, t.touches ? t.touches[0].clientY : t.clientY), this.isTouched = !0
                }
            }, {
                key: "touchMove",
                value: function(t) {
                    var e = t.touches ? t.touches[0].clientX : t.clientX,
                        n = t.touches ? t.touches[0].clientY : t.clientY;
                    !1 !== this.isTouched && (this.anchor.set((e - this.vTouchStart.x) / 10 + this.vPrev.x, (n - this.vTouchStart.y) / 10 + this.vPrev.y), t.touches && t.preventDefault())
                }
            }, {
                key: "touchEnd",
                value: function(t) {
                    this.isTouched = !1, this.isDraging = !1
                }
            }, {
                key: "render",
                value: function() {
                    this.a.set((this.anchor.x - this.v.x) / 10, (this.anchor.y - this.v.y) / 10), this.v.add(this.a)
                }
            }]), t
        }()
}, function(t, e, n) {
    "use strict";

    function r(t, e, n, r, i, o, a) {
        try {
            var s = t[o](a),
                c = s.value
        } catch (t) {
            return void n(t)
        }
        s.done ? e(c) : Promise.resolve(c).then(r, i)
    }

    function i(t) {
        return function() {
            var e = this,
                n = arguments;
            return new Promise(function(i, o) {
                var a = t.apply(e, n);

                function s(t) {
                    r(a, i, o, s, c, "next", t)
                }

                function c(t) {
                    r(a, i, o, s, c, "throw", t)
                }
                s(void 0)
            })
        }
    }
    n.r(e);
    var o = n(0),
        a = n(3),
        s = n(2),
        c = n(381).default,
        u = n(383).default,
        l = n(386).default,
        h = n(389).default,
        f = n(392).default,
        d = n(395).default;

    function v() {
        return (v = i(regeneratorRuntime.mark(function t() {
            var e, n, r, v, p, m, g, y, x, b, w, _, M, S, E, T, P, L;
            return regeneratorRuntime.wrap(function(t) {
                for (;;) switch (t.prev = t.next) {
                    case 0:
                        return e = new o.Vector2, n = document.getElementById("canvas-webgl"), r = new o.WebGLRenderer({
                            alpha: !0,
                            antialias: !0,
                            canvas: n
                        }), v = new o.Scene, p = new o.PerspectiveCamera, m = new o.Clock({
                            autoStart: !1
                        }), g = new c, y = new u, x = new l, b = new h, w = new f, _ = new d(0), M = new clm.tracker, S = function() {
                            var t = i(regeneratorRuntime.mark(function t() {
                                var e, n, i;
                                return regeneratorRuntime.wrap(function(t) {
                                    for (;;) switch (t.prev = t.next) {
                                        case 0:
                                            return e = m.getDelta(), n = M.getCurrentPosition(), i = M.getScore(), g.render(n, i), y.render(e, g.force.v), x.render(e, g.force.v), b.render(e, g.force.v), w.render(e, n, i, g), _.render(e, g.force.v), r.render(v, p), t.abrupt("return");
                                        case 11:
                                        case "end":
                                            return t.stop()
                                    }
                                }, t, this)
                            }));
                            return function() {
                                return t.apply(this, arguments)
                            }
                        }(), E = function() {
                            var t = i(regeneratorRuntime.mark(function t() {
                                return regeneratorRuntime.wrap(function(t) {
                                    for (;;) switch (t.prev = t.next) {
                                        case 0:
                                            return t.next = 2, S();
                                        case 2:
                                            return requestAnimationFrame(E), t.abrupt("return");
                                        case 4:
                                        case "end":
                                            return t.stop()
                                    }
                                }, t, this)
                            }));
                            return function() {
                                return t.apply(this, arguments)
                            }
                        }(), T = function() {
                            p.aspect = e.x / e.y, p.updateProjectionMatrix(), p.setFocalLength(15 * s.step(1, e.y / e.x) + 35)
                        }, P = function() {
                            var t = i(regeneratorRuntime.mark(function t() {
                                return regeneratorRuntime.wrap(function(t) {
                                    for (;;) switch (t.prev = t.next) {
                                        case 0:
                                            return e.set(document.body.clientWidth, window.innerHeight), n.width = e.x, n.height = e.y, T(), r.setSize(e.x, e.y), t.next = 7, g.init();
                                        case 7:
                                        case "end":
                                            return t.stop()
                                    }
                                }, t, this)
                            }));
                            return function() {
                                return t.apply(this, arguments)
                            }
                        }(), L = function() {
                            window.addEventListener("resize", a(function() {
                                P().then(function() {
                                    y.resize(g)
                                })
                            }, 500))
                        }, r.setClearColor(0, 1), p.far = 1e3, p.position.set(0, 0, 100), p.lookAt(new o.Vector3), m.start(), L(), t.next = 26, P();
                    case 26:
                        y.createObj(g), x.createObj(), b.createObj(), w.createObj(), _.createObj(), y.obj.renderOrder = 10, x.obj.renderOrder = 2, b.obj.renderOrder = 1, w.obj.renderOrder = 20, v.add(y.obj), v.add(x.obj), v.add(b.obj), v.add(w.obj), v.add(_.obj), M.init(pModel), M.start(g.video), E();
                    case 43:
                    case "end":
                        return t.stop()
                }
            }, t, this)
        }))).apply(this, arguments)
    }
    e.default = function() {
        return v.apply(this, arguments)
    }
}, function(t, e, n) {
    "use strict";

    function r(t, e, n, r, i, o, a) {
        try {
            var s = t[o](a),
                c = s.value
        } catch (t) {
            return void n(t)
        }
        s.done ? e(c) : Promise.resolve(c).then(r, i)
    }

    function i(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return s
    });
    var o = n(0),
        a = n(382),
        s = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.video = document.createElement("video"), this.facingMode = void 0, this.resolution = {
                    x: 0,
                    y: 0
                }, this.mouth = [new o.Vector2, new o.Vector2, new o.Vector2, new o.Vector2], this.force = {
                    a: 0,
                    v: 1
                }
            }
            return function(t, e, n) {
                e && i(t.prototype, e), n && i(t, n)
            }(t, [{
                key: "init",
                value: function() {
                    var t = function(t) {
                        return function() {
                            var e = this,
                                n = arguments;
                            return new Promise(function(i, o) {
                                var a = t.apply(e, n);

                                function s(t) {
                                    r(a, i, o, s, c, "next", t)
                                }

                                function c(t) {
                                    r(a, i, o, s, c, "throw", t)
                                }
                                s(void 0)
                            })
                        }
                    }(regeneratorRuntime.mark(function t() {
                        var e = this;
                        return regeneratorRuntime.wrap(function(t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    if (navigator.mediaDevices) {
                                        t.next = 2;
                                        break
                                    }
                                    return t.abrupt("return");
                                case 2:
                                    return this.facingMode = "user", t.next = 5, navigator.mediaDevices.getUserMedia({
                                        audio: !1,
                                        video: {
                                            facingMode: this.facingMode
                                        }
                                    }).then(function(t) {
                                        e.video.srcObject = t
                                    }).catch(function(t) {
                                        window.alert("It wasn't allowed to use WebCam.")
                                    });
                                case 5:
                                    return this.video.setAttribute("playsinline", !0), this.video.setAttribute("controls", !0), this.video.play(), t.next = 10, a(1e3);
                                case 10:
                                    return this.resolution.x = this.video.width = this.video.videoWidth, this.resolution.y = this.video.height = this.video.videoHeight, t.abrupt("return");
                                case 13:
                                case "end":
                                    return t.stop()
                            }
                        }, t, this)
                    }));
                    return function() {
                        return t.apply(this, arguments)
                    }
                }()
            }, {
                key: "render",
                value: function(t, e) {
                    var n = 0;
                    if (e >= .3 && !1 !== t) {
                        this.mouth[0].set(t[47][0], t[47][1]), this.mouth[1].set(t[60][0], t[60][1]), this.mouth[2].set(t[57][0], t[57][1]), this.mouth[3].set(t[53][0], t[53][1]);
                        var r = this.mouth[0].distanceTo(this.mouth[1]),
                            i = this.mouth[1].distanceTo(this.mouth[2]),
                            o = this.mouth[2].distanceTo(this.mouth[3]);
                        n = Math.max(i / (r + o) - 1, 0)
                    }
                    var a = .01 * (1 - this.force.v),
                        s = .16 * -this.force.a,
                        c = .1 * n;
                    this.force.a += a + s + c, this.force.v = this.force.v + this.force.a
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = function(t) {
        return new Promise(function(e) {
            setTimeout(e, t)
        })
    }
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = (n(2), function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    texVideo: {
                        type: "t",
                        value: null
                    },
                    facing: {
                        type: "f",
                        value: 0
                    },
                    resolution: {
                        type: "v2",
                        value: new i.Vector2
                    },
                    force: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function(t) {
                    var e = new i.PlaneBufferGeometry(50, 50, 2, 2),
                        r = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(384),
                            fragmentShader: n(385),
                            transparent: !0
                        }),
                        o = new i.VideoTexture(t.video);
                    o.minFilter = i.LinearFilter, o.magFilter = i.LinearFilter, o.format = i.RGBFormat, this.uniforms.texVideo.value = o, this.uniforms.facing.value = "user" === t.facingMode ? 1 : 0, this.uniforms.resolution.value.set(t.resolution.x, t.resolution.y), this.obj = new i.Mesh(e, r)
                }
            }, {
                key: "resize",
                value: function(t) {
                    this.uniforms.resolution.value.set(t.resolution.x, t.resolution.y)
                }
            }, {
                key: "render",
                value: function(t, e) {
                    var n = .008 * e + 1;
                    this.uniforms.force.value = e, this.uniforms.time.value += t * (1.2 * e), this.obj.scale.set(n, n, n)
                }
            }]), t
        }())
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = 'precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D texVideo;\nuniform float facing;\nuniform vec2 resolution;\nuniform float force;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_2_0(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_2_0(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_2_1(vec4 x)\n{\n  return mod289_2_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_2_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_2_3(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_2_4(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_2_0(Pi0);\n  Pi1 = mod289_2_0(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_2_1(permute_2_1(ix) + iy);\n  vec4 ixy0 = permute_2_1(ixy + iz0);\n  vec4 ixy1 = permute_2_1(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_2_2(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_2_2(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_2_3(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\n\nvec3 convertHsvToRgb_1_5(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main() {\n  vec2 p = (vUv * 2.0 - 1.0);\n  float grad = 1.0 - smoothstep(0.5, 1.0, length(p));\n  float noise1 = cnoise_2_4(vec3(p * (1.4 + force * 0.5), time * 0.4)) * (0.15 + smoothstep(0.5, 0.75, length(p)) * (1.0 - smoothstep(0.75, 1.0, length(p))));\n  float noise2 = cnoise_2_4(vec3(p * (5.4 + force * 0.3), time * 0.4)) * (0.15 + smoothstep(0.3, 0.4, length(p)) * (1.0 - smoothstep(0.9, 1.0, length(p))));\n  float noiseSum = (noise1 + noise2) / 2.0;\n\n  vec2 adjustUv = vec2(\n    min(resolution.y / resolution.x, 1.0) * (1.0 + force * 0.03),\n    min(resolution.x / resolution.y, 1.0) * (1.0 + force * 0.03)\n    );\n  vec2 updateUv = vec2(\n    abs(vUv.x - facing) * adjustUv.x + (1.0 - adjustUv.x) * 0.5,\n                  vUv.y * adjustUv.y + (1.0 - adjustUv.y) * 0.5\n                  );\n  vec4 texColor1 = texture2D(texVideo, updateUv - vec2(noise1 * noise2 - abs(p.x) / 50.0));\n  vec4 texColor2 = texture2D(texVideo, updateUv - vec2(noise1 * noise2));\n  vec4 texColor3 = texture2D(texVideo, updateUv - vec2(noise1 * noise2 + abs(p.x) / 50.0));\n  vec3 texColorSum = vec3(texColor1.r, texColor2.g, texColor3.b);\n\n  vec3 addColor = convertHsvToRgb_1_5(vec3((grad + noiseSum + updateUv.x * 0.5) / 2.0 + time * 0.1, 0.8, 0.6));\n\n  float mask1 = smoothstep(0.19, 0.2, grad + noiseSum);\n  vec4 color1 = vec4(texColorSum * vec3(1.2) + addColor * 0.24, 1.0) * mask1;\n\n  float mask2 = smoothstep(0.15, 0.16, grad + noiseSum) * (1.0 - smoothstep(0.7, 0.71, grad + noiseSum));\n  vec4 color2 = vec4(texColorSum * 0.1 + addColor * 0.7, 1.0) * mask2;\n\n  gl_FragColor = color1 + color2;\n}\n'
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(2),
        a = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    force: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    for (var t = new i.BufferGeometry, e = [], r = [], a = 0; a < 600; a += 3) {
                        var s = Math.random() * Math.random() * 60 + 20,
                            c = o.radians(360 * Math.random());
                        e[a + 0] = Math.cos(c) * s, e[a + 1] = Math.sin(c) * s, e[a + 2] = 0, r[a / 3] = 8 * Math.random()
                    }
                    var u = new i.BufferAttribute(new Float32Array(e), 3),
                        l = new i.BufferAttribute(new Float32Array(r), 1);
                    t.addAttribute("position", u), t.addAttribute("delay", l);
                    var h = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(387),
                        fragmentShader: n(388),
                        transparent: !0,
                        depthWrite: !1
                    });
                    this.obj = new i.Points(t, h)
                }
            }, {
                key: "render",
                value: function(t, e) {
                    this.uniforms.force.value = e, this.uniforms.time.value += t * (1.2 * e)
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute float delay;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float force;\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nconst float duration = 8.0;\n\nvoid main() {\n  // Loop animation\n  float interval = mod(time + delay, duration) / duration;\n  vec3 move = vec3(0.0, 0.0, (interval * 2.0 - 1.0) * 100.0);\n\n  // calculate gradation with position.y\n  vec3 hsv = vec3(0.3 + time * 0.1, 0.65 - force * 0.01, 0.85 + force * 0.01);\n  vec3 rgb = convertHsvToRgb_1_0(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position + move, 1.0);\n  float distanceFromCamera = 1000.0 / length(mvPosition.xyz);\n\n  vColor = rgb;\n  vOpacity = smoothstep(-100.0, 100.0, move.z);\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = distanceFromCamera;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main() {\n  // convert PointCoord to range from -1.0 to 1.0\n  vec2 p = gl_PointCoord * 2.0 - 1.0;\n\n  // draw double circle\n  float radius = length(p);\n  float opacity = (1.0 - smoothstep(0.9, 1.0, radius)) * vOpacity;\n\n  gl_FragColor = vec4(vColor, opacity);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(2),
        a = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    force: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.InstancedBufferGeometry,
                        e = new i.BoxBufferGeometry(1.2, 1.2, 18);
                    t.copy(e);
                    for (var r = new i.InstancedBufferAttribute(new Float32Array(360), 3), a = new i.InstancedBufferAttribute(new Float32Array(120), 1), s = 0; s < 120; s++) {
                        var c = Math.random() * Math.random() * 40 + 40,
                            u = o.radians(360 * Math.random());
                        r.setXYZ(s, Math.cos(u) * c, Math.sin(u) * c, 0), a.setX(s, 8 * Math.random())
                    }
                    t.addAttribute("iPosition", r), t.addAttribute("iDelay", a);
                    var l = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(390),
                        fragmentShader: n(391),
                        flatShading: !0,
                        transparent: !0,
                        depthWrite: !1
                    });
                    this.obj = new i.Mesh(t, l), this.obj.frustumCulled = !1
                }
            }, {
                key: "render",
                value: function(t, e) {
                    this.uniforms.force.value = e, this.uniforms.time.value += t * (1.2 * e)
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 iPosition;\nattribute float iDelay;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\nuniform float force;\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\nvarying float vOpacity;\n\nmat4 calcTranslateMat4_2_0(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\n\nvec3 convertHsvToRgb_1_1(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nconst float duration = 8.0;\n\nvoid main(void) {\n  // Loop animation\n  float interval = mod(time + iDelay, duration) / duration;\n  vec3 move = vec3(0.0, 0.0, (interval * 2.0 - 1.0) * 100.0);\n\n  // calculate gradation with position.y\n  vec3 hsv = vec3(0.3 + time * 0.1, 0.3 - force * 0.01, 0.85 + force * 0.01);\n  vec3 rgb = convertHsvToRgb_1_1(hsv);\n\n  // coordinate transformation\n  mat4 translateMat = calcTranslateMat4_2_0(iPosition);\n  vec4 mPosition = modelMatrix * translateMat * vec4(position + move, 1.0);\n  vec4 mvPosition = viewMatrix * mPosition;\n\n  vPosition = mPosition.xyz;\n  vColor = rgb;\n  vOpacity = smoothstep(-100.0, 0.0, move.z);\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main() {\n  // Flat Shading\n  vec3 light = normalize(vec3(0.0, 1.0, 0.5));\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = (dot(normal, light) + 1.0) / 2.0;\n\n  vec3 color = vColor + diff * 0.1;\n\n  gl_FragColor = vec4(color, vOpacity);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = (n(2), function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.positions = void 0, this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.BufferGeometry;
                    this.positions = new i.BufferAttribute(new Float32Array(204), 3), t.addAttribute("position", this.positions);
                    var e = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(393),
                        fragmentShader: n(394),
                        transparent: !0,
                        depthWrite: !1,
                        blending: i.AdditiveBlending
                    });
                    this.obj = new i.Points(t, e)
                }
            }, {
                key: "setPositions",
                value: function(t, e, n) {
                    var r = "user" === n.facingMode ? -1 : 1;
                    if (this.obj.visible = e >= .3, !1 !== t) {
                        for (var i = 0; i < this.positions.count; i++) this.positions.setXYZ(i, 25 * (t[i][0] / n.resolution.x * 2 - 1) * r, -25 * (t[i][1] / n.resolution.y * 2 - 1), 10);
                        this.positions.needsUpdate = !0
                    }
                }
            }, {
                key: "render",
                value: function(t, e, n, r) {
                    this.uniforms.time.value += t * (1.2 * r.force.v), this.setPositions(e, n, r)
                }
            }]), t
        }())
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vColor;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nconst float duration = 3.0;\n\nvoid main() {\n  // calculate colors\n  vec3 hsv = vec3(0.45 + time * 0.1, 0.6, 1.0);\n  vec3 rgb = convertHsvToRgb_1_0(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = 7.0;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\n\nvoid main() {\n  // convert PointCoord to range from -1.0 to 1.0\n  vec2 p = gl_PointCoord * 2.0 - 1.0;\n\n  float r = 1.0 - smoothstep(0.5, 1.0, length(p));\n\n  gl_FragColor = vec4(vColor, r);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(2),
        a = function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    force: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.SphereBufferGeometry(150, 128, 128, 0, 6.3, 0, 1.6),
                        e = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(396),
                            fragmentShader: n(397),
                            side: i.BackSide
                        });
                    this.obj = new i.Mesh(t, e), this.obj.rotation.set(o.radians(-90), 0, 0)
                }
            }, {
                key: "render",
                value: function(t, e) {
                    this.uniforms.force.value = e, this.uniforms.time.value += t * (1.2 * e)
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float force;\n\nvarying vec3 vColor;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main(void) {\n  // calculate gradation\n  vec3 hsv = vec3(0.1 + sin(radians(uv.y * 180.0 * 4.0)) * 0.12 - time * 0.1, 0.12 + force * 0.03, 0.96 - force * 0.03);\n  vec3 rgb = convertHsvToRgb_1_0(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n"
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(96).default,
        a = n(399).default;
    e.default = function() {
        var t = new r.Vector2,
            e = document.getElementById("canvas-webgl"),
            n = new r.WebGLRenderer({
                alpha: !0,
                antialias: !0,
                canvas: e
            }),
            s = new r.Scene,
            c = new r.PerspectiveCamera,
            u = new r.Clock;
        c.far = 5e4, c.setFocalLength(24);
        var l = {
                fog: "../img/sketch/fog/fog.png"
            },
            h = new a,
            f = function t() {
                ! function() {
                    var t = u.getDelta();
                    h.render(t), n.render(s, c)
                }(), requestAnimationFrame(t)
            },
            d = function() {
                t.set(document.body.clientWidth, window.innerHeight), e.width = t.x, e.height = t.y, c.aspect = t.x / t.y, c.updateProjectionMatrix(), n.setSize(t.x, t.y)
            };
        o(l, function(t) {
            h.createObj(t.fog), s.add(h.obj), n.setClearColor(0, 1), c.position.set(0, 0, 1e3), c.lookAt(new r.Vector3), u.start(), window.addEventListener("resize", i(d, 1e3)), d(), f()
        })
    }
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = (n(2), function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    tex: {
                        type: "t",
                        value: null
                    }
                }, this.num = 200, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function(t) {
                    var e = new i.InstancedBufferGeometry,
                        r = new i.PlaneBufferGeometry(1100, 1100, 20, 20);
                    e.copy(r);
                    for (var o = new i.InstancedBufferAttribute(new Float32Array(3 * this.num), 3), a = new i.InstancedBufferAttribute(new Float32Array(this.num), 1), s = new i.InstancedBufferAttribute(new Float32Array(this.num), 1), c = 0, u = this.num; c < u; c++) o.setXYZ(c, 850 * (2 * Math.random() - 1), 0, 300 * (2 * Math.random() - 1)), a.setXYZ(c, Math.random()), s.setXYZ(c, 2 * Math.random() + 1);
                    e.addAttribute("instancePosition", o), e.addAttribute("delay", a), e.addAttribute("rotate", s);
                    var l = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(400),
                        fragmentShader: n(401),
                        transparent: !0,
                        depthWrite: !1,
                        blending: i.AdditiveBlending
                    });
                    this.uniforms.tex.value = t, this.obj = new i.Mesh(e, l)
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }())
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 instancePosition;\nattribute float delay;\nattribute float rotate;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvarying float vBlink;\n\nconst float duration = 200.0;\n\nmat4 calcRotateMat4Z_2_0(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nvec3 convertHsvToRgb_1_1(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main(void) {\n  float now = mod(time + delay * duration, duration) / duration;\n\n  mat4 rotateMat = calcRotateMat4Z_2_0(radians(rotate * 360.0) + time * 0.1);\n  vec3 rotatePosition = (rotateMat * vec4(position, 1.0)).xyz;\n\n  vec3 moveRise = vec3(\n    (now * 2.0 - 1.0) * (2500.0 - (delay * 2.0 - 1.0) * 2000.0),\n    (now * 2.0 - 1.0) * 2000.0,\n    sin(radians(time * 50.0 + delay + length(position))) * 30.0\n    );\n  vec3 updatePosition = instancePosition + moveRise + rotatePosition;\n\n  vec3 hsv = vec3(time * 0.1 + delay * 0.2 + length(instancePosition) * 100.0, 0.5 , 0.8);\n  vec3 rgb = convertHsvToRgb_1_1(hsv);\n  float blink = (sin(radians(now * 360.0 * 20.0)) + 1.0) * 0.88;\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(updatePosition, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n  vColor = rgb;\n  vBlink = blink;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D tex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvarying float vBlink;\n\nvoid main() {\n  vec2 p = vUv * 2.0 - 1.0;\n\n  vec4 texColor = texture2D(tex, vUv);\n  vec3 color = (texColor.rgb - vBlink * length(p) * 0.8) * vColor;\n  float opacity = texColor.a * 0.36;\n\n  gl_FragColor = vec4(color, opacity);\n}\n"
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(403).default,
        a = n(408).default;
    e.default = function() {
        var t = new r.Vector2,
            e = document.getElementById("canvas-webgl"),
            n = new r.WebGLRenderer({
                alpha: !0,
                antialias: !0,
                canvas: e
            }),
            s = new r.Scene,
            c = new r.PerspectiveCamera,
            u = new r.Clock,
            l = new r.FontLoader;
        c.far = 5e4, c.setFocalLength(24);
        var h = new o,
            f = new a,
            d = function t() {
                ! function() {
                    var t = u.getDelta();
                    h.render(t), n.render(s, c)
                }(), requestAnimationFrame(t)
            },
            v = function() {
                t.set(document.body.clientWidth, window.innerHeight), e.width = t.x, e.height = t.y, c.aspect = t.x / t.y, c.updateProjectionMatrix(), n.setSize(t.x, t.y)
            };
        l.load("https://threejs.org/examples/fonts/helvetiker_bold.typeface.json", function(t) {
            h.createObj(t), f.createObj(), s.add(h.objWire), s.add(h.objPoints), s.add(f.obj), n.setClearColor(0, 1), c.position.set(0, 0, 1e3), c.lookAt(new r.Vector3), u.start(), window.addEventListener("resize", i(v, 1e3)), window.addEventListener("click", function() {
            console.log("gege");
                h.transform()
            }), v(), d()
        })
    }
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(2),
        a = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.durationTransform = .8, this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    timeTransform: {
                        type: "f",
                        value: this.durationTransform
                    },
                    durationTransform: {
                        type: "f",
                        value: this.durationTransform
                    },
                    prevIndex: {
                        type: "f",
                        value: 1
                    },
                    nextIndex: {
                        type: "f",
                        value: 0
                    }
                }, this.isTransform = !1, this.obj, this.objWire = null, this.objPoints = null
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function(t) {
                    var e = {
                            font: t,
                            size: 300,
                            height: 0,
                            curveSegments: 1
                        },
                        r = [new i.TextBufferGeometry("HELLO", e), new i.TextBufferGeometry("WORLD", e)],
                        o = new i.BufferGeometry,
                        a = 0;
                    r.map(function(t, e) {
                        t.center(), t.attributes.position.count > a && (a = t.attributes.position.count)
                    }), r.map(function(t, e) {
                        var n = e > 0 ? e + 1 : "";
                        if (t.attributes.position.count < a) {
                            for (var r = t.attributes.position.array, s = [], c = [], u = 0; u < 3 * a; u += 3)
                                if (u < (3 * a - r.length) / 2) s[u] = 700 * (2 * Math.random() - 1), s[u + 1] = 250 * (2 * Math.random() - 1), s[u + 2] = 250 * (2 * Math.random() - 1), c[u / 3] = 0;
                                else if (u >= r.length + (3 * a - r.length) / 2) s[u] = 700 * (2 * Math.random() - 1), s[u + 1] = 250 * (2 * Math.random() - 1), s[u + 2] = 250 * (2 * Math.random() - 1), c[u / 3] = 0;
                            else {
                                var l = u - (3 * a - r.length) / 2;
                                s[u] = t.attributes.position.array[l], s[u + 1] = t.attributes.position.array[l + 1], s[u + 2] = t.attributes.position.array[l + 2], c[u / 3] = 1
                            }
                            o.addAttribute("position".concat(n), new i.Float32BufferAttribute(s, 3, 1)), o.addAttribute("opacity".concat(n), new i.Float32BufferAttribute(c, 1, 1))
                        } else {
                            var h = [];
                            for (u = 0; u < a; u++) h[u] = 1;
                            o.addAttribute("position".concat(n), t.attributes.position), o.addAttribute("opacity".concat(n), new i.Float32BufferAttribute(h, 1, 1)), o.addAttribute("normal", t.attributes.normal), o.addAttribute("uv", t.attributes.uv), o.setIndex(t.index)
                        }
                    });
                    var s = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(133),
                            fragmentShader: n(404),
                            depthWrite: !1,
                            transparent: !0,
                            flatShading: !0
                        }),
                        c = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(133),
                            fragmentShader: n(405),
                            depthWrite: !1,
                            transparent: !0,
                            wireframe: !0
                        }),
                        u = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(406),
                            fragmentShader: n(407),
                            depthWrite: !1,
                            transparent: !0
                        });
                    this.obj = new i.Mesh(o, s), this.objWire = new i.Mesh(o, c), this.objPoints = new i.Points(o, u)
                }
            }, {
                key: "transform",
                value: function() {
                    this.isTransform = !0, this.uniforms.timeTransform.value = 0, this.uniforms.prevIndex.value = this.uniforms.prevIndex.value < 1 ? this.uniforms.prevIndex.value + 1 : 0, this.uniforms.nextIndex.value = this.uniforms.nextIndex.value < 1 ? this.uniforms.nextIndex.value + 1 : 0
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t, this.isTransform && (this.uniforms.timeTransform.value = o.clamp(this.uniforms.timeTransform.value + t, 0, this.durationTransform)), this.uniforms.timeTransform.value === this.durationTransform && (this.isTransform = !1)
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\nvoid main() {\n  gl_FragColor = vec4(vec3(1.0), vOpacity);\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\nvoid main() {\n  gl_FragColor = vec4(vec3(1.0), vOpacity);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 position2;\nattribute float opacity;\nattribute float opacity2;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float timeTransform;\nuniform float durationTransform;\nuniform float prevIndex;\nuniform float nextIndex;\n\nvarying float vOpacity;\n\nfloat exponentialOut_2_0(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\n\n\nmat4 calcRotateMat4X_5_1(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Y_4_2(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Z_3_3(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n\nmat4 calcRotateMat4_1_4(vec3 radian) {\n  return calcRotateMat4X_5_1(radian.x) * calcRotateMat4Y_4_2(radian.y) * calcRotateMat4Z_3_3(radian.z);\n}\n\n\n\nvoid main() {\n  // transform\n  vec3 prevPosition =\n    position * (1.0 - step(1.0, prevIndex))\n    + position2 * step(1.0, prevIndex) * (1.0 - step(2.0, prevIndex));\n  vec3 nextPosition =\n    position * (1.0 - step(1.0, nextIndex))\n    + position2 * step(1.0, nextIndex) * (1.0 - step(2.0, nextIndex));\n  float prevOpacity =\n    opacity * (1.0 - step(1.0, prevIndex))\n    + opacity2 * step(1.0, prevIndex) * (1.0 - step(2.0, prevIndex));\n  float nextOpacity =\n    opacity * (1.0 - step(1.0, nextIndex))\n    + opacity2 * step(1.0, nextIndex) * (1.0 - step(2.0, nextIndex));\n  float ease = exponentialOut_2_0(min(timeTransform / 1.0, durationTransform) / durationTransform);\n  vec3 mixPosition = mix(prevPosition, nextPosition, ease);\n  float mixOpacity = mix(prevOpacity, nextOpacity, ease);\n\n  // calculate shake moving.\n  float now = time * 10.0 + length(mixPosition);\n  mat4 rotateMat = calcRotateMat4_1_4(vec3(now));\n  vec3 shake = (rotateMat * vec4(vec3(0.0, sin(now) * 5.0, 0.0), 1.0)).xyz;\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(mixPosition + shake, 1.0);\n\n  vOpacity = mixOpacity;\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = 8.0;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nvarying float vOpacity;\n\nvoid main() {\n  // Round the point\n  vec3 n;\n  n.xy = gl_PointCoord * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n\n  gl_FragColor = vec4(vec3(1.0), vOpacity);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = (n(2), function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.SphereBufferGeometry(1e4, 128, 128),
                        e = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(409),
                            fragmentShader: n(410),
                            side: i.BackSide
                        });
                    this.obj = new i.Mesh(t, e)
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }())
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nconst vec3 hsv1 = vec3(0.0, 0.6, 0.4);\nconst vec3 hsv2 = vec3(0.24, 0.6, 0.4);\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main(void) {\n  // calculate gradation with position.y\n  vec3 rgb = convertHsvToRgb_1_0(mix(hsv1, hsv2, (normalize(position).y + 1.0) / 2.0));\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D tex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nfloat random_1_0(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n\nvoid main() {\n  float noise = random_1_0(vUv) * 0.08;\n\n  gl_FragColor = vec4(vColor + noise, 1.0);\n}\n"
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(96).default,
        a = n(412).default;
    e.default = function() {
        var t = new r.Vector2,
            e = new r.Vector2,
            n = document.getElementById("canvas-webgl"),
            s = new r.WebGLRenderer({
                alpha: !0,
                antialias: !0,
                canvas: n
            }),
            c = new r.Scene,
            u = new r.PerspectiveCamera,
            l = new r.Clock;
        u.far = 5e4, u.setFocalLength(24);
        var h = {
                points: "elephant.png"
            },
            f = new a,
            d = function t() {
                ! function() {
                    var t = l.getDelta();
                    f.render(t, u, e), s.render(c, u)
                }(), requestAnimationFrame(t)
            },
            v = function() {
                t.set(document.body.clientWidth, window.innerHeight), n.width = t.x, n.height = t.y, u.aspect = t.x / t.y, u.updateProjectionMatrix(), s.setSize(t.x, t.y)
            },
            p = function(n) {
                e.set(n.clientX / t.x * 2 - 1, -n.clientY / t.y * 2 + 1)
            };
        o(h, function(t) {
            s.setClearColor(0, 1), u.position.set(0, 0, 1e3), u.lookAt(0, 0, 0), l.start(), f.createObj(t.points), c.add(f.obj), window.addEventListener("resize", i(v, 1e3)), window.addEventListener("mousemove", p), v(), d()
        })
    }
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = (n(2), function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    tex: {
                        type: "t",
                        value: null
                    },
                    mouse: {
                        type: "v3",
                        value: new i.Vector3
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function(t) {
                    var e = new i.PlaneBufferGeometry(800, 800, 200, 200),
                        r = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(413),
                            fragmentShader: n(414),
                            transparent: !0
                        });
                    this.uniforms.tex.value = t, this.obj = new i.Points(e, r)
                }
            }, {
                key: "render",
                value: function(t, e, n) {
                    this.uniforms.time.value += t;
                    var r = new i.Vector3;
                    r.set(n.x, n.y, -1), r.unproject(e);
                    var o = r.sub(e.position).normalize(),
                        a = -e.position.z / o.z,
                        s = e.position.clone().add(o.multiplyScalar(a));
                    this.uniforms.mouse.value.copy(s)
                }
            }]), t
        }())
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform vec3 mouse;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec2 vUv;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main() {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position, 1.0);\n  vec3 subPosition = mouse - mPosition.xyz;\n  float force = (1000.0 - clamp(length(subPosition), 0.0, 1000.0)) / 4.0;\n  mPosition = vec4(mPosition.xyz + force * normalize(-subPosition), 1.0);\n\n  vUv = uv;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n  gl_PointSize = 3.0;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D tex;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 texColor = texture2D(tex, vUv);\n  gl_FragColor = texColor;\n}\n"
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(2),
        a = n(94),
        s = n(95),
        c = n(97).default,
        u = n(416).default,
        l = n(417).default,
        h = n(420).default,
        f = n(423).default,
        d = n(426).default;
    e.default = function() {
        var t = new r.Vector2,
            e = new r.Vector2,
            n = document.getElementById("canvas-webgl"),
            v = new r.WebGLRenderer({
                alpha: !0,
                antialias: !0,
                canvas: n
            }),
            p = new r.Scene,
            m = new c,
            g = new u(m),
            y = new r.Clock;
        m.far = 5e4, m.setFocalLength(35);
        var x = new l,
            b = new h,
            w = new f,
            _ = new d,
            M = function t() {
                ! function() {
                    var t = y.getDelta();
                    x.render(t), b.render(t), w.render(t), _.render(t), g.render(t, e), v.render(p, m)
                }(), requestAnimationFrame(t)
            },
            S = function() {
                t.set(document.body.clientWidth, window.innerHeight), n.width = t.x, n.height = t.y, m.aspect = t.x / t.y, m.updateProjectionMatrix(), v.setSize(t.x, t.y)
            };
        x.createObj(), b.createObj(), w.createObj(), _.createObj(), p.add(x.obj), p.add(b.obj), p.add(w.obj), p.add(_.obj), v.setClearColor(0, 1), g.init([0, 1500, 3e3], [0, -100, 0]), y.start(), window.addEventListener("resize", i(S, 1e3)), a() || s() ? window.addEventListener("deviceorientation", function(n) {
            t.x / t.y < 1 ? e.set(n.gamma / 60, -.02 * o.clamp(Math.abs(n.beta) - 90, -90, 90)) : e.set(0, 0)
        }) : (window.addEventListener("mousemove", function(n) {
            e.set(n.clientX / t.x * 2 - 1, -(n.clientY / t.y * 2 - 1))
        }), window.addEventListener("mouseout", function(t) {
            e.set(0, 0)
        })), S(), M()
    }
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    n(0);
    var i = n(68),
        o = (n(2), function() {
            function t(e, n) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.camera = e, this.anchorTilt = [0, 0, 0]
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "init",
                value: function(t, e) {
                    for (var n = 0; n < t.length; n++) this.camera.anchor[n] = this.camera.velocity[n] = t[n], this.camera.lookAnchor[n] = this.camera.lookVelocity[n] = e[n]
                }
            }, {
                key: "tilt",
                value: function(t) {
                    this.anchorTilt = [-200 * t.x, 200 * t.y, 0]
                }
            }, {
                key: "move",
                value: function(t, e, n) {
                    for (var r = 0; r < t.length; r++) this.camera.anchor[r] = t[r], this.camera.lookAnchor[r] = e[r];
                    n > 0 && this.focalLength.next !== n && (this.focalLength.prev = this.focalLength.next, this.focalLength.next = n, this.focalLength.time = 0)
                }
            }, {
                key: "render",
                value: function(t, e) {
                    this.tilt(e), i.vec3.add(this.camera.velocity, this.camera.velocity, this.anchorTilt), this.camera.render()
                }
            }]), t
        }())
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = (n(2), function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.OctahedronBufferGeometry(450, 3),
                        e = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(418),
                            fragmentShader: n(419),
                            flatShading: !0
                        });
                    this.obj = new i.Mesh(t, e)
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }())
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvoid main(void) {\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nconst vec3 light = vec3(0.0, 1.0, 0.0);\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main() {\n  // Flat Shading\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = (dot(normal, light) + 1.0) / 2.0;\n\n  vec3 hsv = vec3(0.88 + diff * 0.2, 1.0 - diff * 0.4, pow(diff, 3.0) * 0.88 + 0.12);\n  vec3 rgb = convertHsvToRgb_1_0(hsv);\n\n  gl_FragColor = vec4(rgb, 1.0);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = (n(2), function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.PlaneBufferGeometry(1e3, 3e3, 128, 128),
                        e = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(421),
                            fragmentShader: n(422),
                            transparent: !0,
                            depthWrite: !1,
                            side: i.DoubleSide,
                            blending: i.AdditiveBlending
                        });
                    this.obj = new i.Mesh(t, e)
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }())
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1_1(vec4 x) {\n     return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_1_3(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_1_4 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_1_5 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_1_5;\n  vec3 i1 = min( g_1_5.xyz, l.zxy );\n  vec3 i2 = max( g_1_5.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_1_4.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_1_0(i);\n  vec4 p = permute_1_1( permute_1_1( permute_1_1(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_1_4.wyz - D_1_4.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_1_6 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_1_7 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_1_6.xy,h.z);\n  vec3 p3 = vec3(a1_1_6.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_1_2(vec4(dot(p0_1_7,p0_1_7), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_1_7 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_1_7,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\n\nvoid main(void) {\n  float roundRadius = (1.0 - smoothstep(0.1, 1.0, uv.y)* 1.2) * 480.0;\n  vec3 roundPosition = vec3(\n    sin(radians(uv.x * 360.0)) * roundRadius,\n    position.y + 900.0,\n    cos(radians(uv.x * 360.0)) * roundRadius\n    );\n\n  float noise = (snoise_1_3(roundPosition * vec3(0.01, 0.0001, 0.01) + time * 0.8) + 0.5);\n  float noiseRadius = noise * smoothstep(0.2, 0.3, uv.y) * 70.0;\n  vec3 noisePosition = vec3(\n    sin(radians(uv.x * 360.0)) * noiseRadius,\n    0.0,\n    cos(radians(uv.x * 360.0)) * noiseRadius\n    );\n\n  vec4 mvPosition = modelViewMatrix * vec4(roundPosition + noisePosition, 1.0);\n\n  vPosition = roundPosition;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_2_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_2_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_2_1(vec4 x) {\n     return mod289_2_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_2_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_2_3(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_2_4 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_2_5 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_2_5;\n  vec3 i1 = min( g_2_5.xyz, l.zxy );\n  vec3 i2 = max( g_2_5.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_2_4.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_2_0(i);\n  vec4 p = permute_2_1( permute_2_1( permute_2_1(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_2_4.wyz - D_2_4.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_2_6 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_2_7 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_2_6.xy,h.z);\n  vec3 p3 = vec3(a1_2_6.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_2_2(vec4(dot(p0_2_7,p0_2_7), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_2_7 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_2_7,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\nvec3 convertHsvToRgb_1_8(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main() {\n  float noise = snoise_2_3(\n    vPosition * vec3(0.005, 0.002, 0.004) + vec3(time * 2.6, -time * 3.6, time * 2.6)\n    );\n  float opacity = smoothstep(0.3, 0.8, (noise + 1.0) / 2.0 - (1.0 - smoothstep(0.0, 0.3, vUv.y) * (1.0 - smoothstep(0.3, 1.0, vUv.y))));\n  vec3 hsv = vec3(0.98 + opacity * 0.2, 1.0 - opacity * 0.6, 1.0);\n  vec3 rgb = convertHsvToRgb_1_8(hsv);\n\n  gl_FragColor = vec4(rgb, opacity);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(2),
        a = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.num = 5e3, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.InstancedBufferGeometry,
                        e = new i.BoxBufferGeometry(16, 800, 200);
                    t.copy(e);
                    for (var r = new i.InstancedBufferAttribute(new Float32Array(3 * this.num), 3), a = new i.InstancedBufferAttribute(new Float32Array(this.num), 1), s = new i.InstancedBufferAttribute(new Float32Array(this.num), 1), c = new i.InstancedBufferAttribute(new Float32Array(this.num), 1), u = 0, l = this.num; u < l; u++) {
                        o.radians(o.randomArbitrary(0, 360));
                        var h = o.randomArbitrary(1e3, 7e3),
                            f = (7e3 - h) / 7e3 * .75 + .25,
                            d = o.randomArbitrary(.1, .4);
                        r.setXYZ(u, h, o.randomArbitrary(-1e4, -100), 0), a.setXYZ(u, f), s.setXYZ(u, u), c.setXYZ(u, d)
                    }
                    t.addAttribute("instancePosition", r), t.addAttribute("scale", a), t.addAttribute("rotate", s), t.addAttribute("speed", c);
                    var v = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(424),
                        fragmentShader: n(425),
                        flatShading: !0
                    });
                    this.obj = new i.Mesh(t, v)
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 instancePosition;\nattribute float scale;\nattribute float rotate;\nattribute float speed;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vDistance;\n\nmat4 calcRotateMat4X_3_0(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Y_4_1(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Z_5_2(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n\nmat4 calcRotateMat4_2_3(vec3 radian) {\n  return calcRotateMat4X_3_0(radian.x) * calcRotateMat4Y_4_1(radian.y) * calcRotateMat4Z_5_2(radian.z);\n}\n\n\nmat4 calcScaleMat4_1_4(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n\nvoid main(void) {\n  mat4 scaleMat = calcScaleMat4_1_4(vec3(scale));\n  mat4 rotateMatWorld = calcRotateMat4_2_3(vec3(0.0, rotate + time * speed * 0.2, 0.0));\n  vec3 updatePosition = (scaleMat * vec4(position, 1.0)).xyz;\n  vec4 mvPosition = modelViewMatrix * rotateMatWorld * vec4(updatePosition + instancePosition, 1.0);\n  float distanceFromCenter = 1.0 - clamp(length(instancePosition) / 6000.0, 0.0, 0.8);\n\n  vPosition = updatePosition + instancePosition;\n  vUv = uv;\n  vDistance = distanceFromCenter;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vDistance;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main() {\n  // Flat Shading\n  vec3 light = normalize(-vPosition);\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = (dot(normal, light) + 1.0) / 2.0;\n\n  vec3 hsv = vec3(\n    0.86 + diff * 0.24,\n    1.0 - diff * 0.4,\n    (diff * 0.88 + 0.12) * vDistance\n    );\n  vec3 rgb = convertHsvToRgb_1_0(hsv);\n\n  gl_FragColor = vec4(rgb, 1.0);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = (n(2), function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.SphereBufferGeometry(1e4, 128, 128),
                        e = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(427),
                            fragmentShader: n(428),
                            side: i.BackSide
                        });
                    this.obj = new i.Mesh(t, e)
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }())
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nconst vec3 hsv1 = vec3(0.98, 0.9, 0.05);\nconst vec3 hsv2 = vec3(1.13, 0.9, 0.8);\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main(void) {\n  // calculate gradation with position.y\n  vec3 rgb = convertHsvToRgb_1_0(mix(hsv1, hsv2, (normalize(position).y + 1.0) / 2.0));\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D tex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nfloat random_1_0(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n\nvoid main() {\n  float noise = random_1_0(vUv) * 0.08;\n\n  gl_FragColor = vec4(vColor + noise, 1.0);\n}\n"
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(2),
        a = n(94),
        s = n(95),
        c = n(97).default,
        u = n(96).default,
        l = n(430).default,
        h = n(431).default,
        f = n(434).default,
        d = n(437).default,
        v = n(442).default,
        p = n(445).default,
        m = n(448).default;
    e.default = function() {
        var t = new r.Vector2,
            e = new r.Vector2,
            n = document.getElementById("canvas-webgl"),
            g = new r.WebGLRenderer({
                alpha: !0,
                antialias: !0,
                canvas: n
            }),
            y = new r.Scene,
            x = new c,
            b = new l(x),
            w = new r.Clock;
        x.far = 5e4, x.setFocalLength(24);
        var _ = new h,
            M = new f,
            S = new d,
            E = new v,
            T = new p,
            P = new m,
            L = new m,
            A = function t() {
                ! function() {
                    var t = w.getDelta();
                    _.render(t), M.render(t), S.render(t), E.render(t), T.render(t), P.render(t, .1, .1, .3), L.render(t, -.2, .02, -.8), b.render(t, e), g.render(y, x)
                }(), requestAnimationFrame(t)
            },
            z = function() {
                t.set(document.body.clientWidth, window.innerHeight), n.width = t.x, n.height = t.y, x.aspect = t.x / t.y, x.updateProjectionMatrix(), g.setSize(t.x, t.y)
            };
        u({
            gui1: "../img/sketch/cyberspace/tex_gui01.png",
            gui2: "../img/sketch/cyberspace/tex_gui02.png",
            gui3: "../img/sketch/cyberspace/tex_gui03.png"
        }, function(n) {
            _.createObj([n.gui1, n.gui2, n.gui3]), M.createObj(), S.createObj(), E.createObj(), T.createObj(), P.createObj(1200, 284.1, 398.6, 601.2, 828.4), L.createObj(2400, 222.6, 412.4, 683.9, 961.2), y.add(_.obj), y.add(M.obj), y.add(S.obj), y.add(S.objWire), y.add(S.objPoints), y.add(E.obj), y.add(T.obj), y.add(P.obj), y.add(L.obj), T.obj.position.set(0, 0, -2e3), g.setClearColor(0, 1), b.init([0, 0, 1e3], [0, 0, 0]), w.start(), window.addEventListener("resize", i(z, 1e3)), a() || s() ? window.addEventListener("deviceorientation", function(n) {
                t.x / t.y < 1 ? e.set(n.gamma / 60, o.clamp(Math.abs(n.beta) - 90, -90, 90) / -30) : e.set(0, 0)
            }) : (window.addEventListener("mousemove", function(n) {
                e.set(n.clientX / t.x * 2 - 1, -(n.clientY / t.y * 2 - 1))
            }), window.addEventListener("mouseout", function(t) {
                e.set(0, 0)
            })), z(), A()
        })
    }
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    n(0);
    var i = n(68),
        o = (n(2), function() {
            function t(e, n) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.camera = e, this.anchorTilt = [0, 0, 0]
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "init",
                value: function(t, e) {
                    for (var n = 0; n < t.length; n++) this.camera.anchor[n] = this.camera.velocity[n] = t[n], this.camera.lookAnchor[n] = this.camera.lookVelocity[n] = e[n]
                }
            }, {
                key: "tilt",
                value: function(t) {
                    this.anchorTilt = [-50 * t.x, 25 * t.y, 0]
                }
            }, {
                key: "move",
                value: function(t, e, n) {
                    for (var r = 0; r < t.length; r++) this.camera.anchor[r] = t[r], this.camera.lookAnchor[r] = e[r];
                    n > 0 && this.focalLength.next !== n && (this.focalLength.prev = this.focalLength.next, this.focalLength.next = n, this.focalLength.time = 0)
                }
            }, {
                key: "render",
                value: function(t, e) {
                    this.tilt(e), i.vec3.add(this.camera.velocity, this.camera.velocity, this.anchorTilt), this.camera.render()
                }
            }]), t
        }())
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = (n(2), function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    texture1: {
                        type: "t",
                        value: null
                    },
                    texture2: {
                        type: "t",
                        value: null
                    },
                    texture3: {
                        type: "t",
                        value: null
                    }
                }, this.num = 6, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function(t) {
                    var e = new i.InstancedBufferGeometry,
                        r = new i.PlaneBufferGeometry(1200, 1200, 2, 2);
                    e.copy(r);
                    for (var o = new i.InstancedBufferAttribute(new Float32Array(3 * this.num), 3), a = new i.InstancedBufferAttribute(new Float32Array(this.num), 1), s = new i.InstancedBufferAttribute(new Float32Array(this.num), 1), c = new i.InstancedBufferAttribute(new Float32Array(this.num), 1), u = new i.InstancedBufferAttribute(new Float32Array(this.num), 1), l = 0, h = this.num; l < h; l++) o.setXYZ(l, 0, 0, -150 * (this.num - l)), a.setXYZ(l, 2 * Math.random() - 1), s.setXYZ(l, 2 * Math.random() - 1), c.setXYZ(l, 2 * Math.random() - 1), u.setXYZ(l, .15 * (2 * Math.random() - 1));
                    e.addAttribute("instancePosition", o), e.addAttribute("rotate1", a), e.addAttribute("rotate2", s), e.addAttribute("rotate3", c), e.addAttribute("h", u);
                    var f = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(432),
                        fragmentShader: n(433),
                        transparent: !0,
                        blending: i.AdditiveBlending
                    });
                    this.uniforms.texture1.value = t[0], this.uniforms.texture2.value = t[1], this.uniforms.texture3.value = t[2], this.obj = new i.Mesh(e, f)
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }())
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nattribute vec3 instancePosition;\nattribute float rotate1;\nattribute float rotate2;\nattribute float rotate3;\nattribute float h;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvarying float vRotate1;\nvarying float vRotate2;\nvarying float vRotate3;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main(void) {\n  // calculate colors\n  vec3 hsv = vec3(h + time * 0.1 + 0.5, 0.4, 1.0);\n  vec3 rgb = convertHsvToRgb_1_0(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position + instancePosition, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n  vColor = rgb;\n  vRotate1 = rotate1;\n  vRotate2 = rotate2;\n  vRotate3 = rotate3;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D texture1;\nuniform sampler2D texture2;\nuniform sampler2D texture3;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvarying float vRotate1;\nvarying float vRotate2;\nvarying float vRotate3;\n\nmat3 rotateMat3(float radian) {\n  return mat3(\n    cos(radian), -sin(radian), 0.0,\n    sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 1.0\n  );\n}\n\nvoid main() {\n  // rotate textures\n  vec2 uv1 = ((vec3(vUv - 0.5, 1.0) * rotateMat3(time * vRotate1)).xy + 0.5);\n  vec2 uv2 = ((vec3(vUv - 0.5, 1.0) * rotateMat3(time * vRotate2)).xy + 0.5);\n  vec2 uv3 = ((vec3(vUv - 0.5, 1.0) * rotateMat3(time * vRotate3)).xy + 0.5);\n  vec4 texColor1 = texture2D(texture1, uv1);\n  vec4 texColor2 = texture2D(texture2, uv2);\n  vec4 texColor3 = texture2D(texture3, uv3);\n  vec4 color = texColor1 + texColor2 + texColor3;\n\n  // discard low alpha value\n  if (color.a <= 0.1) discard;\n\n  gl_FragColor = vec4(vColor, color.a * 0.35);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(2),
        a = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.instances = 2e3, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.InstancedBufferGeometry,
                        e = new i.BoxBufferGeometry(100, 4e3, 2, 2, 2);
                    t.copy(e);
                    for (var r = new i.InstancedBufferAttribute(new Float32Array(3 * this.instances), 3), a = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), s = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), c = 0, u = this.instances; c < u; c++) r.setXYZ(c, o.randomArbitrary(-5e3, 5e3), 0, o.randomArbitrary(-500, 500) + 700 * (2 * o.randomInt(0, 1) - 1)), a.setXYZ(c, 2 * Math.random()), s.setXYZ(c, .3 * Math.random());
                    t.addAttribute("instancePosition", r), t.addAttribute("delay", a), t.addAttribute("h", s);
                    var l = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(435),
                        fragmentShader: n(436),
                        depthWrite: !1,
                        transparent: !0,
                        side: i.DoubleSide,
                        blending: i.AdditiveBlending
                    });
                    this.obj = new i.Mesh(t, l)
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 instancePosition;\nattribute float delay;\nattribute float h;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vDelay;\nvarying vec3 vColor;\n\nmat4 calcRotateMat4X_3_0(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Y_4_1(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Z_5_2(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n\nmat4 calcRotateMat4_2_3(vec3 radian) {\n  return calcRotateMat4X_3_0(radian.x) * calcRotateMat4Y_4_1(radian.y) * calcRotateMat4Z_5_2(radian.z);\n}\n\n\nvec3 convertHsvToRgb_1_4(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main(void) {\n  // update positions\n  vec3 updatePosition = position + instancePosition;\n  mat4 rotateMat = calcRotateMat4_2_3(vec3(radians(90.0), 0.0, radians(180.0)));\n\n  // calculate colors\n  vec3 hsv = vec3(h + time * 0.1, 0.35, 0.6);\n  vec3 rgb = convertHsvToRgb_1_4(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * rotateMat * vec4(updatePosition, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n  vDelay = delay;\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vDelay;\nvarying vec3 vColor;\n\nconst float duration = 10.0;\n\nvoid main() {\n  // calculate interval time from 0 to 1\n  float now = mod(time + vDelay * duration, duration) / duration;\n\n  float opacityBothEnds = smoothstep(-2000.0, -1800.0, vPosition.y) * (1.0 - smoothstep(1800.0, 2000.0, vPosition.y));\n  float opacity = smoothstep(0.85, 1.0, mod(vUv.y - now, 1.0));\n\n  gl_FragColor = vec4(vColor, opacity * opacityBothEnds * 0.08);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(2),
        a = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj, this.objWire = null, this.objPoints = null
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.RingBufferGeometry(1550, 1600, 36, 2, o.radians(135), o.radians(270)),
                        e = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(134),
                            fragmentShader: n(438),
                            depthWrite: !1,
                            transparent: !0,
                            blending: i.AdditiveBlending,
                            flatShading: !0
                        }),
                        r = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(134),
                            fragmentShader: n(439),
                            depthWrite: !1,
                            transparent: !0,
                            blending: i.AdditiveBlending,
                            wireframe: !0
                        }),
                        a = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(440),
                            fragmentShader: n(441),
                            depthWrite: !1,
                            transparent: !0,
                            blending: i.AdditiveBlending
                        });
                    this.obj = new i.Mesh(t, e), this.objWire = new i.Mesh(t, r), this.objPoints = new i.Points(t, a), this.obj.position.set(0, 0, -1200), this.objWire.position.set(0, 0, -1200), this.objPoints.position.set(0, 0, -1200)
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t;
                    var e = [o.radians(20 * Math.sin(.1 * this.uniforms.time.value) + 90), o.radians(20 * Math.sin(.05 * this.uniforms.time.value)), 0];
                    this.obj.rotation.set(e[0], e[1], e[2]), this.objWire.rotation.set(e[0], e[1], e[2]), this.objPoints.rotation.set(e[0], e[1], e[2])
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\n\nvoid main() {\n  // flat shading\n  vec3 light = normalize(vec3(0.0, 1.0, 1.0));\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = pow((dot(normal, light) + 1.0) / 2.0, 10.0);\n\n  gl_FragColor = vec4(vColor, diff * 0.4 + 0.03);\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 0.15);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float timeShow;\nuniform float durationShow;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nmat4 calcRotateMat4X_3_1(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Y_4_2(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Z_5_3(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n\nmat4 calcRotateMat4_2_4(vec3 radian) {\n  return calcRotateMat4X_3_1(radian.x) * calcRotateMat4Y_4_2(radian.y) * calcRotateMat4Z_5_3(radian.z);\n}\n\n\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\n\nvoid main() {\n  // convert uv to range from -1.0 to 1.0\n  vec2 p = uv * 2.0 - 1.0;\n\n  // update rotation\n  float rotateX = p.x * 100.0 + time / 2.0;\n  float rotateY = p.y * 200.0 + time / 2.0;\n  float rotateZ = length(p.xy) * 150.0 + time / 2.0;\n  mat4 rotateMat = calcRotateMat4_2_4(vec3(rotateX, rotateY, rotateZ));\n  vec3 rotatePosition = (rotateMat * vec4(vec3(sin(time * 0.1 + p.x * 10.0) * 150.0), 1.0)).xyz;\n\n  // update position\n  vec3 wavePosition = vec3(0.0, 0.0, sin(time * 0.1 + (p.x + p.y) * 5.6) * 300.0);\n  vec3 updatePosition = position + rotatePosition + wavePosition;\n\n  // update size\n  float size = (pow(sin(rotateX * 10.0), 3.0) + 1.0) * 2.0 + 3.0;\n\n  // calculate colors\n  vec3 hsv = vec3(time * 0.1, 0.35, 0.6);\n  vec3 rgb = convertHsvToRgb_1_0(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(updatePosition, 1.0);\n\n  vPosition = updatePosition;\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = size;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\n\nvoid main() {\n  // make round\n  vec2 p = gl_PointCoord * 2.0 - 1.0;\n  float radius = length(p);\n  float r = 1.0 - smoothstep(0.95, 1.0, radius);\n\n  gl_FragColor = vec4(vColor, r * 0.1);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(2),
        a = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.num = 2e3, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    for (var t = new i.BufferGeometry, e = new i.BufferAttribute(new Float32Array(3 * this.num), 3, 1), r = new i.BufferAttribute(new Float32Array(this.num), 1, 1), a = new i.BufferAttribute(new Float32Array(this.num), 1, 1), s = 0, c = this.num; s < c; s++) {
                        var u = o.radians(o.randomArbitrary(0, 150) - 75),
                            l = o.radians(o.randomArbitrary(0, 360)),
                            h = o.randomArbitrary(600, 2500),
                            f = o.spherical(u, l, h);
                        e.setXYZ(s, f[0], f[1], f[2]), r.setXYZ(s, Math.random()), a.setXYZ(s, o.randomArbitrary(5, 10) * (2 * o.randomInt(0, 1) - 1))
                    }
                    t.addAttribute("position", e), t.addAttribute("delay", r), t.addAttribute("speed", a);
                    var d = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(443),
                        fragmentShader: n(444),
                        transparent: !0,
                        depthWrite: !1,
                        blending: i.AdditiveBlending
                    });
                    this.obj = new i.Points(t, d)
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute float delay;\nattribute float speed;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vColor1;\nvarying vec3 vColor2;\nvarying float vOpacity;\n\nvec3 convertHsvToRgb_2_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nmat4 calcRotateMat4X_3_1(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Y_4_2(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Z_5_3(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n\nmat4 calcRotateMat4_1_4(vec3 radian) {\n  return calcRotateMat4X_3_1(radian.x) * calcRotateMat4Y_4_2(radian.y) * calcRotateMat4Z_5_3(radian.z);\n}\n\n\n\nconst float duration = 3.0;\n\nvoid main() {\n  // calculate interval time from 0 to 1\n  float interval = mod(time + delay * duration, duration) / duration;\n\n  // update position and size\n  float size = 10.0 * sin(interval * 4.0);\n  float blink = max(sin(interval * 4.0) * 2.0 - 1.0, 0.0);\n  mat4 rotateMat = calcRotateMat4_1_4(vec3(\n    radians(time * speed * 0.3),\n    radians(time * speed),\n    radians(time * speed * 0.3)\n    ));\n\n  // calculate colors\n  vec3 hsv1 = vec3(time * 0.1, 0.6, 1.0);\n  vec3 rgb1 = convertHsvToRgb_2_0(hsv1);\n  vec3 hsv2 = vec3(time * 0.1 + 0.2, 0.6, 1.0);\n  vec3 rgb2 = convertHsvToRgb_2_0(hsv2);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * rotateMat * vec4(position, 1.0);\n  float distanceFromCamera = 1000.0 / length(mvPosition.xyz);\n\n  vColor1 = rgb1;\n  vColor2 = rgb2;\n  vOpacity = blink * clamp(distanceFromCamera, 0.1, 0.8);\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = distanceFromCamera * size;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\n\nvarying vec3 vColor1;\nvarying vec3 vColor2;\nvarying float vOpacity;\n\nvoid main() {\n  // convert PointCoord to range from -1.0 to 1.0\n  vec2 p = gl_PointCoord * 2.0 - 1.0;\n\n  // draw double circle\n  float radius = length(p);\n  float r1 = (1.0 - smoothstep(0.95, 1.0, radius));\n  float r2 = (1.0 - smoothstep(0.45, 0.5, radius));\n  vec3 color1 = vColor1 * (r1 - r2);\n  vec3 color2 = vColor2 * r2;\n  vec3 color = color1 + color2;\n  float opacity = ((r1 - r2) * 0.25 + r2 * 0.5) * vOpacity;\n\n  gl_FragColor = vec4(color, opacity);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = (n(2), function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.isShown = !1, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.SphereBufferGeometry(1e4, 32, 32),
                        e = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(446),
                            fragmentShader: n(447),
                            side: i.BackSide
                        });
                    this.obj = new i.Mesh(t, e)
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }())
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nvarying vec3 vPosition;\n\nvoid main() {\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vPosition;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main() {\n  // calculate colors\n  vec3 hsv = vec3(time * 0.1 + 0.5, 1.0, (1.0 - abs(vPosition.y / 10000.0)) * 0.08);\n  vec3 rgb = convertHsvToRgb_1_0(hsv);\n\n  gl_FragColor = vec4(rgb, 1.0);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = (n(2), function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    wave1: {
                        type: "f",
                        value: 0
                    },
                    wave2: {
                        type: "f",
                        value: 0
                    },
                    wave3: {
                        type: "f",
                        value: 0
                    },
                    wave4: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function(t, e, r, o, a) {
                    var s = new i.SphereBufferGeometry(t, 64, 64),
                        c = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(449),
                            fragmentShader: n(450),
                            transparent: !0,
                            depthWrite: !1,
                            side: i.BackSide,
                            blending: i.AdditiveBlending
                        });
                    this.uniforms.wave1.value = e, this.uniforms.wave2.value = r, this.uniforms.wave3.value = o, this.uniforms.wave4.value = a, this.obj = new i.Mesh(s, c)
                }
            }, {
                key: "render",
                value: function(t, e, n, r) {
                    this.uniforms.time.value += t, this.obj.rotation.set(e, this.uniforms.time.value * n, r)
                }
            }]), t
        }())
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float wave1;\nuniform float wave2;\nuniform float wave3;\nuniform float wave4;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvoid main() {\n  // draw lines\n  float v1 = sin(vUv.y * wave1 + time * 0.2);\n  float v2 = sin(vUv.y * wave2 + time * 0.2);\n  float v3 = sin(vUv.y * wave3 + time * 0.2);\n  float v4 = sin(vUv.y * wave4 + time * 0.2);\n  float v = smoothstep(0.65, 0.7, (v1 + v2 + v3 + v4) / 4.0);\n  vec3 color = vec3(v);\n\n  gl_FragColor = vec4(color, v * 0.08);\n}\n"
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(452).default;
    e.default = function() {
        var t = new r.Vector2,
            e = document.getElementById("canvas-webgl"),
            n = new r.WebGLRenderer({
                antialias: !0,
                canvas: e
            }),
            a = new r.Scene,
            s = new r.PerspectiveCamera(120, 1, 1, 1e4),
            c = new r.Clock,
            u = new r.Vector2,
            l = new r.Vector2,
            h = new r.Vector2,
            f = new o,
            d = function t() {
                ! function() {
                    var t = c.getDelta();
                    f.render(t), n.render(a, s)
                }(), requestAnimationFrame(t)
            },
            v = function() {
                t.set(document.body.clientWidth, window.innerHeight), e.width = t.x, e.height = t.y, s.aspect = t.x / t.y, s.updateProjectionMatrix(), n.setSize(t.x, t.y)
            },
            p = function(t) {
                !0
            },
            m = function(t) {
                !1
            };
        window.addEventListener("resize", i(v, 1e3)), e.addEventListener("mousedown", function(t) {
            t.preventDefault(), u.set(t.clientX, t.clientY), p()
        }), document.addEventListener("mousemove", function(t) {
            t.preventDefault(), l.set(t.clientX, t.clientY)
        }), document.addEventListener("mouseup", function(t) {
            t.preventDefault(), h.set(t.clientX, t.clientY), m()
        }), e.addEventListener("touchstart", function(t) {
            t.preventDefault(), u.set(t.touches[0].clientX, t.touches[0].clientY), p()
        }), e.addEventListener("touchmove", function(t) {
            t.preventDefault(), l.set(t.touches[0].clientX, t.touches[0].clientY)
        }), e.addEventListener("touchend", function(t) {
            t.preventDefault(), h.set(t.changedTouches[0].clientX, t.changedTouches[0].clientY), m()
        }), v(), f.createObj(), a.add(f.obj), n.setClearColor(0, 1), s.position.set(0, 0, 100), s.lookAt(new r.Vector3(0, 0, 0)), d()
    }
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(2),
        a = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.instances = 500, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.InstancedBufferGeometry,
                        e = new i.BoxBufferGeometry(1, 1e3, 1, 2, 128);
                    t.copy(e);
                    for (var r = new i.InstancedBufferAttribute(new Float32Array(3 * this.instances), 3), a = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), s = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), c = 0, u = this.instances; c < u; c++) r.setXYZ(c, 300 * ((Math.random() + Math.random() + Math.random()) / 3 * 2 - 1), 0, 150 * ((Math.random() + Math.random() + Math.random()) / 3 * 2 - 1)), a.setXYZ(c, 90 * (2 * o.randomInt(0, 1) - 1) + 60 * (2 * Math.random() - 1)), s.setXYZ(c, 2 * Math.random());
                    t.addAttribute("instancePosition", r), t.addAttribute("rotate", a), t.addAttribute("delay", s);
                    var l = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(453),
                        fragmentShader: n(454),
                        depthWrite: !1,
                        transparent: !0,
                        side: i.DoubleSide,
                        blending: i.AdditiveBlending
                    });
                    this.obj = new i.Mesh(t, l)
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = '#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 instancePosition;\nattribute float rotate;\nattribute float delay;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vDelay;\nvarying vec3 vColor;\n\nmat4 calcRotateMat4X_6_0(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Y_4_1(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Z_5_2(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n\nmat4 calcRotateMat4_1_3(vec3 radian) {\n  return calcRotateMat4X_6_0(radian.x) * calcRotateMat4Y_4_1(radian.y) * calcRotateMat4Z_5_2(radian.z);\n}\n\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_3_4(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_3_4(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_3_5(vec4 x)\n{\n  return mod289_3_4(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_3_6(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_3_7(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_3_8(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_3_4(Pi0);\n  Pi1 = mod289_3_4(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_3_5(permute_3_5(ix) + iy);\n  vec4 ixy0 = permute_3_5(ixy + iz0);\n  vec4 ixy1 = permute_3_5(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_3_6(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_3_6(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_3_7(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\n\nvec3 convertHsvToRgb_2_9(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main(void) {\n  // calculate posiitons of instances.\n  vec3 wavePosition = vec3(0.0, 0.0, sin(radians(position.y / 3.6) + time * 0.1 + delay * 9.0) * 50.0);\n  vec3 updatePosition = position + instancePosition + wavePosition;\n  mat4 rotateMat = calcRotateMat4_1_3(vec3(radians(90.0), 0.0, radians(rotate)));\n  vec4 mvPosition = modelViewMatrix * rotateMat * vec4(updatePosition, 1.0);\n\n  // calculate interval for uv animation and setting color.\n  float noise = cnoise_3_8(updatePosition / 100.0) * 0.5 + time * 0.1;\n  vec3 hsv = vec3(noise, 0.45, 1.0);\n  vec3 rgb = convertHsvToRgb_2_9(hsv);\n\n  vPosition = position;\n  vUv = uv;\n  vDelay = delay;\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n'
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vDelay;\nvarying vec3 vColor;\n\nconst float duration = 3.0;\n\nvoid main() {\n  float now = mod(time + vDelay * duration, duration) / duration;\n  float opacityBothEnds = smoothstep(-500.0, -400.0, vPosition.y) * (1.0 - smoothstep(400.0, 500.0, vPosition.y));\n  float opacity = smoothstep(0.95, 1.0, mod(vUv.y - now, 1.0));\n\n  gl_FragColor = vec4(vColor, opacity * opacityBothEnds * 0.9);\n}\n"
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(456).default;
    e.default = function() {
        var t = new r.Vector2,
            e = document.getElementById("canvas-webgl"),
            n = new r.WebGLRenderer({
                antialias: !1,
                canvas: e
            }),
            a = new r.Scene,
            s = new r.PerspectiveCamera(90, 1, 1, 1e4),
            c = new r.Clock,
            u = new r.Vector2,
            l = new r.Vector2,
            h = new r.Vector2,
            f = new o,
            d = function t() {
                ! function() {
                    var t = c.getDelta();
                    f.render(t), n.render(a, s)
                }(), requestAnimationFrame(t)
            },
            v = function() {
                t.set(document.body.clientWidth, window.innerHeight), e.width = t.x, e.height = t.y, s.aspect = t.x / t.y, s.updateProjectionMatrix(), n.setSize(t.x, t.y)
            },
            p = function(t) {
                !0
            },
            m = function(t) {
                !1
            };
        window.addEventListener("resize", i(v, 1e3)), e.addEventListener("mousedown", function(t) {
            t.preventDefault(), u.set(t.clientX, t.clientY), p()
        }), document.addEventListener("mousemove", function(t) {
            t.preventDefault(), l.set(t.clientX, t.clientY)
        }), document.addEventListener("mouseup", function(t) {
            t.preventDefault(), h.set(t.clientX, t.clientY), m()
        }), e.addEventListener("touchstart", function(t) {
            t.preventDefault(), u.set(t.touches[0].clientX, t.touches[0].clientY), p()
        }), e.addEventListener("touchmove", function(t) {
            t.preventDefault(), l.set(t.touches[0].clientX, t.touches[0].clientY)
        }), e.addEventListener("touchend", function(t) {
            t.preventDefault(), h.set(t.changedTouches[0].clientX, t.changedTouches[0].clientY), m()
        }), v(), f.createObj(), a.add(f.obj), n.setClearColor(0, 1), s.position.set(10, 10, 50), s.lookAt(new r.Vector3), d()
    }
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    for (var t = new i.BufferGeometry, e = [], r = 0; r < 50; r++)
                        for (var o = 0; o < 50; o++)
                            for (var a = 0; a < 50; a++) {
                                var s = 70 * (a / 50 * 2 - 1),
                                    c = 70 * (o / 50 * 2 - 1),
                                    u = 70 * (r / 50 * 2 - 1);
                                e.push(s, c, u)
                            }
                    var l = new i.BufferAttribute(new Float32Array(e), 3);
                    t.addAttribute("position", l);
                    var h = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(457),
                        fragmentShader: n(458),
                        transparent: !0,
                        depthWrite: !1
                    });
                    this.obj = new i.Points(t, h)
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t, this.obj.rotation.set(.005 * this.uniforms.time.value, .02 * this.uniforms.time.value, .004 * this.uniforms.time.value)
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\n\nuniform vec3 cameraPosition;\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1_1(vec4 x) {\n     return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_1_3(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_1_4 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_1_5 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_1_5;\n  vec3 i1 = min( g_1_5.xyz, l.zxy );\n  vec3 i2 = max( g_1_5.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_1_4.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_1_0(i);\n  vec4 p = permute_1_1( permute_1_1( permute_1_1(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_1_4.wyz - D_1_4.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_1_6 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_1_7 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_1_6.xy,h.z);\n  vec3 p3 = vec3(a1_1_6.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_1_2(vec4(dot(p0_1_7,p0_1_7), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_1_7 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_1_7,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\nvec3 convertHsvToRgb_2_8(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main() {\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  float noise1 = snoise_1_3(mvPosition.xyz * 0.046 + vec3(-time, time, time) * 0.3);\n  float noise2 = snoise_1_3(mvPosition.xyz * 0.0012 + vec3(time, -time, time) * 0.01);\n\n  vec3 hsv = vec3(noise2 * 0.2 + time * 0.1, 1.0, 0.6);\n  vec3 rgb = convertHsvToRgb_2_8(hsv);\n\n  vColor = rgb;\n  vOpacity = pow(40.0 / length(mvPosition.xyz) * noise1, 2.0);\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = 600.0 / length(mvPosition.xyz) * noise1;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main() {\n  // to round.\n  vec3 n;\n  n.xy = gl_PointCoord * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n\n  gl_FragColor = vec4(vColor, vOpacity);\n}\n"
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(13).default,
        a = n(460).default,
        s = n(463).default,
        c = n(466).default,
        u = n(470).default,
        l = n(135).default,
        h = n(472).default;
    e.default = function() {
        var t = {
                x: 0,
                y: 0
            },
            e = document.getElementById("canvas-webgl"),
            n = new r.WebGLRenderer({
                antialias: !0,
                canvas: e,
                alpha: !0
            }),
            f = new r.WebGLRenderTarget(0, 0),
            d = new r.WebGLRenderTarget(0, 0),
            v = new r.WebGLRenderTarget(0, 0),
            p = new r.Scene,
            m = new r.Scene,
            g = new r.OrthographicCamera(-1, 1, 1, -1, 0, 1),
            y = new r.PerspectiveCamera(30, 1, 1, 15e3),
            x = new r.Clock,
            b = new r.TextureLoader,
            w = new r.Vector2,
            _ = new r.Vector2,
            M = new r.Vector2,
            S = [],
            E = new s(32),
            T = new c(t),
            P = new u(.7, f.texture),
            L = new l(d.texture, 1, 0, 1),
            A = new l(v.texture, 0, 1, 1),
            z = new h(.7, f.texture, d.texture),
            C = ["/sketch-threejs/img/sketch/transform/tex.png", "/sketch-threejs/img/sketch/transform/flower.jpg"],
            R = [],
            I = function() {
                t.x = document.body.clientWidth, t.y = window.innerHeight, e.width = t.x, e.height = t.y, y.aspect = t.x / t.y, y.updateProjectionMatrix(), T.resize(t), L.resize(t), A.resize(t), f.setSize(t.x, t.y), d.setSize(t.x, t.y), v.setSize(t.x, t.y), n.setSize(t.x, t.y)
            },
            D = function t() {
                ! function() {
                    for (var t = x.getDelta(), e = 0; e < S.length; e++) S[e].render(n, t);
                    E.render(t), T.render(n, p, m, g, t), n.render(m, y, f), P.render(n, p, g, d), L.render(n, p, g, v), A.render(n, p, g, d), z.render(n, p, g)
                }(), requestAnimationFrame(t)
            },
            O = function(t) {
                !0, S[0].isTransform = !S[0].isTransform
            },
            F = function(t) {
                !1
            },
            j = function() {
                window.addEventListener("resize", i(I), 1e3), e.addEventListener("mousedown", function(t) {
                    t.preventDefault(), w.set(t.clientX, t.clientY), o(w), O()
                }), e.addEventListener("mousemove", function(t) {
                    t.preventDefault(), _.set(t.clientX, t.clientY), o(_)
                }), e.addEventListener("mouseup", function(t) {
                    t.preventDefault(), M.set(t.clientX, t.clientY), o(M), F()
                }), e.addEventListener("touchstart", function(t) {
                    t.preventDefault(), w.set(t.touches[0].clientX, t.touches[0].clientY), o(w), O(t.touches[0].clientX, t.touches[0].clientY)
                }), e.addEventListener("touchmove", function(t) {
                    t.preventDefault(), _.set(t.touches[0].clientX, t.touches[0].clientY), o(_)
                }), e.addEventListener("touchend", function(t) {
                    t.preventDefault(), M.set(t.changedTouches[0].clientX, t.changedTouches[0].clientY), o(M), F()
                }), window.addEventListener("mouseout", function() {
                    event.preventDefault(), M.set(0, 0), !1
                })
            };
        ! function() {
            I(), j(), n.setClearColor(0, 1), y.position.set(400.1, 60, -400), T.mirrorCamera.position.set(y.position.x, -1 * y.position.y, y.position.z), y.lookAt(new r.Vector3(0, 60, 0)), T.mirrorCamera.lookAt(new r.Vector3(0, -60, 0));
            for (var t = 0, e = function() {
                    var e = i;
                    b.load(C[i], function(n) {
                        if (n.magFilter = r.NearestFilter, n.minFilter = r.NearestFilter, n.repeat = r.RepeatWrapping, R[e] = n, ++t >= C.length) {
                            for (var i = 0; i < 1; i++) S[i] = new a(i, R[0], R[1]), m.add(S[i].obj);
                            E.addButterflies(S), m.add(E.obj), T.add(p, m), p.add(P.obj), p.add(L.obj), p.add(A.obj), p.add(z.obj), D()
                        }
                    })
                }, i = 0; i < C.length; i++) e()
        }()
    }
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t(e, n, r) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.size = 280, this.interval = 1.2, this.uniforms = {
                    index: {
                        type: "f",
                        value: e
                    },
                    time: {
                        type: "f",
                        value: 0
                    },
                    timeTransform: {
                        type: "f",
                        value: 0
                    },
                    interval: {
                        type: "f",
                        value: this.interval
                    },
                    size: {
                        type: "f",
                        value: this.size
                    },
                    texButterfly: {
                        type: "t",
                        value: n
                    },
                    texPicture: {
                        type: "t",
                        value: r
                    },
                    colorH: {
                        type: "f",
                        value: .08
                    }
                }, this.obj, this.isTransform = !1, this.createObj()
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.PlaneBufferGeometry(this.size, this.size / 2, 64, 32),
                        e = new i.SphereBufferGeometry(.1 * this.size, 64, 32, -.5 * Math.PI, 2 * Math.PI),
                        r = new i.PlaneBufferGeometry(1.1 * this.size, .55 * this.size, 64, 32);
                    t.addAttribute("spherePosition", e.attributes.position), t.addAttribute("squarePosition", r.attributes.position);
                    var o = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(461),
                        fragmentShader: n(462),
                        side: i.DoubleSide,
                        transparent: !0
                    });
                    this.obj = new i.Mesh(t, o), this.obj.position.y = .3 * this.size, this.obj.renderOrder = 10
                }
            }, {
                key: "render",
                value: function(t, e) {
                    this.uniforms.time.value += e, this.uniforms.timeTransform.value < this.interval && !0 === this.isTransform ? this.uniforms.timeTransform.value = Math.min(this.uniforms.timeTransform.value + e, this.interval) : this.uniforms.timeTransform.value > 0 && !1 === this.isTransform && (this.uniforms.timeTransform.value = Math.max(this.uniforms.timeTransform.value - e, 0))
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = '#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 spherePosition;\nattribute vec3 squarePosition;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float index;\nuniform float time;\nuniform float timeTransform;\nuniform float interval;\nuniform float size;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\nvarying float vStep1;\nvarying float vStep2;\nvarying float vStep3;\n\nfloat exponentialInOut_2_0(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\n\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1_1(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1_1(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1_2(vec4 x)\n{\n  return mod289_1_1(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_3(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_1_4(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_1_5(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_1_1(Pi0);\n  Pi1 = mod289_1_1(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_1_2(permute_1_2(ix) + iy);\n  vec4 ixy0 = permute_1_2(ixy + iz0);\n  vec4 ixy1 = permute_1_2(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_1_3(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_1_3(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_1_4(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\n\nmat4 calcRotateMat4X_5_6(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Y_4_7(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Z_6_8(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n\nmat4 calcRotateMat4_3_9(vec3 radian) {\n  return calcRotateMat4X_5_6(radian.x) * calcRotateMat4Y_4_7(radian.y) * calcRotateMat4Z_6_8(radian.z);\n}\n\n\n\nvoid main() {\n  // Calcurate time of tranforming\n  float t = timeTransform / interval;\n  float transformTime1 = max((1.0 - t) * 2.0 - 1.0, 0.0);\n  float transformTime2 = min((t) * 2.0, 1.0) * min((1.0 - t) * 2.0, 1.0);\n  float transformTime3 = max((t) * 2.0 - 1.0, 0.0);\n\n  // Position of Butterfly\n  float flapTime = radians(sin(time * 4.0 - length(position.xy) / size * 2.0 + index * 2.0) * 45.0 + 30.0);\n  vec3 flapPosition = vec3(\n    cos(flapTime) * position.x,\n    position.y + sin(time) * 10.0,\n    sin(flapTime) * abs(position.x) + sin(time) * 10.0\n  );\n  mat4 flapRotateMat = calcRotateMat4_3_9(vec3(radians(45.0), 0.0, 0.0));\n  vec3 position1 = (flapRotateMat * vec4(flapPosition, 1.0)).xyz;\n\n  // Position of Sphere on transforming\n  float sphereNoise = cnoise_1_5(spherePosition * 0.02 + time * 2.4);\n  vec3 sphereNoisePosition = normalize(spherePosition) * sphereNoise * 30.0;\n  mat4 sphereRotateMat = calcRotateMat4_3_9(vec3(t * 4.0, 0.0, 0.0));\n  vec3 position2 = (sphereRotateMat * vec4(spherePosition + sphereNoisePosition, 1.0)).xyz;\n\n  // Position of Picture\n  mat4 pictureRotateMat = calcRotateMat4_3_9(vec3(0.0, radians(45.0), 0.0));\n  vec3 position3 = (pictureRotateMat * vec4(squarePosition, 1.0)).xyz;;\n\n  // Total of All Position\n  vec3 updatePosition = position1 * exponentialInOut_2_0(transformTime1) + position2 * exponentialInOut_2_0(transformTime2) + position3 * exponentialInOut_2_0(transformTime3);\n\n  // varying\n  vPosition = updatePosition;\n  vUv = uv;\n  vStep1 = clamp((1.0 - t) * 6.0 - 2.0, 0.0, 1.0);\n  vStep2 = clamp((t) * 6.0 - 1.0, 0.0, 1.0) * clamp((1.0 - t) * 6.0 - 1.0, 0.0, 1.0);\n  vStep3 = clamp((t) * 6.0 - 3.0, 0.0, 1.0);\n\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(updatePosition, 1.0);\n}\n'
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float size;\nuniform sampler2D texButterfly;\nuniform sampler2D texPicture;\nuniform float colorH;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\nvarying float vStep1;\nvarying float vStep2;\nvarying float vStep3;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1_1(vec4 x) {\n     return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_1_3(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_1_4 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_1_5 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_1_5;\n  vec3 i1 = min( g_1_5.xyz, l.zxy );\n  vec3 i2 = max( g_1_5.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_1_4.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_1_0(i);\n  vec4 p = permute_1_1( permute_1_1( permute_1_1(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_1_4.wyz - D_1_4.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_1_6 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_1_7 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_1_6.xy,h.z);\n  vec3 p3 = vec3(a1_1_6.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_1_2(vec4(dot(p0_1_7,p0_1_7), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_1_7 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_1_7,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\nfloat random_2_8(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec3 convertHsvToRgb_3_9(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nconst float rgbDiff = 0.01;\n\nvoid main() {\n  // Glitch Noise.\n  float bnStrength = sin(time) * 0.05;\n  float bnTime = floor(time * 18.0) * 200.0;\n  float noiseX = step(0.87 + bnStrength, (snoise_1_3(vec3(0.0, vUv.x * 1.8, bnTime)) + 1.0) / 2.0);\n  float noiseY = step(0.87 + bnStrength, (snoise_1_3(vec3(0.0, vUv.y * 4.2, bnTime)) + 1.0) / 2.0);\n  float bnMask = noiseX * noiseY;\n  float bnUvX = mod(vUv.x + sin(bnTime) + rgbDiff, 1.0);\n  vec4 bnDiff = (1.0 - texture2D(texPicture, vec2(bnUvX, vUv.y))) * bnMask;\n\n  // White Noise.\n  float whiteNoise = (random_2_8(vUv + mod(time, 10.0)) * 2.0 - 1.0) * 0.15;\n  vec4 wnColor = vec4(vec3(whiteNoise), 0.0);\n\n  // Color Noise for BUterfly.\n  float noise = snoise_1_3(vPosition / vec3(size * 0.25) + vec3(0.0, 0.0, time));\n  vec3 hsv = vec3(colorH + noise * 0.2, 0.4, 1.0);\n  vec3 rgb = convertHsvToRgb_3_9(hsv);\n\n  // Butterly Color.\n  vec4 texButterflyColor = texture2D(texButterfly, vUv);\n  vec4 color1 = vec4(rgb, 1.0) * texButterflyColor;\n\n  // Sphere color on transforming.\n  vec4 color2 = vec4(rgb, 1.0) * vec4((1.0 - texButterflyColor.rgb * 0.5), texButterflyColor.a) + wnColor;\n\n  // Picture Color.\n  vec2 pictUv = vUv * 1.1 - 0.05;\n  vec4 texPictureColor = texture2D(texPicture, pictUv);\n  float pictAlpha = step(0.0, pictUv.x) * (1.0 - step(1.0, pictUv.x)) * step(0.0, pictUv.y) * (1.0 - step(1.0, pictUv.y));\n  vec4 pictColor = texPictureColor * (1.0 - bnMask) * vec4(vec3(1.0), pictAlpha);\n  vec4 bnColor = vec4(bnDiff.rgb * 1.2, bnMask);\n  vec4 color3 = pictColor + bnColor + wnColor;\n\n  // total of colors.\n  vec4 color = (color1 * vStep1 + color2 * vStep2) + color3 * vStep3;\n\n  if (color.a < 0.5) discard;\n\n  gl_FragColor = color;\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(2),
        a = function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.interval = 4, this.attr = {
                    position: new i.BufferAttribute(new Float32Array(3 * e), 3),
                    colorH: new i.BufferAttribute(new Float32Array(e), 1),
                    index: new i.BufferAttribute(new Float32Array(e), 1),
                    opacity: new i.BufferAttribute(new Float32Array(e), 1),
                    valid: new i.BufferAttribute(new Float32Array(e), 1)
                }, this.uniforms = {
                    size: {
                        type: "f",
                        value: e
                    },
                    interval: {
                        type: "f",
                        value: this.interval
                    },
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.butterflies = null, this.butterfliesLengh = 0, this.obj, this.createObj()
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    for (var t = new i.BufferGeometry, e = 0; e < this.uniforms.size.value; e++) this.attr.index.setX(e, e);
                    t.addAttribute("position", this.attr.position), t.addAttribute("colorH", this.attr.colorH), t.addAttribute("i", this.attr.index), t.addAttribute("opacity", this.attr.opacity), t.addAttribute("valid", this.attr.valid);
                    var r = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(464),
                        fragmentShader: n(465),
                        depthWrite: !1,
                        transparent: !0
                    });
                    this.obj = new i.Points(t, r), this.obj.renderOrder = 20
                }
            }, {
                key: "addButterflies",
                value: function(t) {
                    this.butterflies = t, this.butterfliesLengh = t.length
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t;
                    for (var e = 0; e < this.uniforms.size.value; e++) {
                        var n = (this.uniforms.time.value + this.attr.index.getX(e) / this.uniforms.size.value * this.interval) % this.interval,
                            r = this.attr.valid.getX(e);
                        if (n >= .9 * this.interval && 1 == r) this.attr.valid.setX(e, 0);
                        else if (n <= .9 * this.interval && 0 == r) {
                            var i = Math.floor(Math.random() * this.butterfliesLengh),
                                a = this.butterflies[i],
                                s = (-90 * Math.random() - 90) * Math.PI / 180,
                                c = -180 * Math.random() * Math.PI / 180,
                                u = Math.random() * a.uniforms.size.value / 4 + a.uniforms.size.value / 8,
                                l = o.spherical(s, c, u),
                                h = a.uniforms.timeTransform.value > 0 ? 0 : 1;
                            this.attr.position.setXYZ(e, l[0] + a.obj.position.x, .2 * l[1] + a.obj.position.y + 20 * Math.sin(a.uniforms.time.value), .5 * l[2] + a.obj.position.z), this.attr.colorH.setX(e, a.uniforms.colorH.value), this.attr.opacity.setX(e, h), this.attr.valid.setX(e, 1)
                        }
                    }
                    this.attr.position.needsUpdate = !0, this.attr.colorH.needsUpdate = !0, this.attr.opacity.needsUpdate = !0, this.attr.valid.needsUpdate = !0
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute float colorH;\nattribute float i;\nattribute float opacity;\nattribute float valid;\n\nuniform vec3 cameraPosition;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float size;\nuniform float interval;\nuniform float time;\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1_1(vec4 x) {\n     return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_1_3(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_1_4 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_1_5 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_1_5;\n  vec3 i1 = min( g_1_5.xyz, l.zxy );\n  vec3 i2 = max( g_1_5.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_1_4.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_1_0(i);\n  vec4 p = permute_1_1( permute_1_1( permute_1_1(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_1_4.wyz - D_1_4.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_1_6 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_1_7 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_1_6.xy,h.z);\n  vec3 p3 = vec3(a1_1_6.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_1_2(vec4(dot(p0_1_7,p0_1_7), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_1_7 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_1_7,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\nvec3 convertHsvToRgb_2_8(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main() {\n  float thisTime = mod(time + i / size * interval, interval);\n\n  vec3 updatePosition = position + vec3(\n    cos(thisTime * 3.0 + i) * 3.0,\n    thisTime * -20.0,\n    sin(thisTime * 3.0 + i) * 3.0\n  );\n  vec4 mvPosition = viewMatrix * modelMatrix * vec4(updatePosition, 1.0);\n\n  vec3 hsv = vec3(colorH + sin(i) * 0.075, 0.8, 1.0);\n\n  vColor = convertHsvToRgb_2_8(hsv);\n  vOpacity = (\n    smoothstep(interval * 0.0, interval * 0.1, thisTime)\n    * (1.0 - smoothstep(interval * 0.2, interval * 0.9, thisTime))\n  ) * opacity;\n\n  gl_PointSize = 5000.0 / length(mvPosition.xyz);\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main() {\n  // to round.\n  vec3 n;\n  n.xy = gl_PointCoord * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n\n  gl_FragColor = vec4(vColor, vOpacity * 0.5);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(135).default,
        a = function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.mirrorCamera = new i.PerspectiveCamera(30, e.x / e.y, 1, 15e3), this.mirrorRender = new i.WebGLRenderTarget(e.x, e.y), this.textureMatrix = new i.Matrix4, this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    texture: {
                        type: "t",
                        value: this.mirrorRender.texture
                    },
                    textureMatrix: {
                        type: "m4",
                        value: this.textureMatrix
                    }
                }, this.renderBack1 = new i.WebGLRenderTarget(e.x, e.y), this.renderBack2 = new i.WebGLRenderTarget(e.x, e.y), this.postEffectBlurX = new o(this.renderBack1.texture, 1, 0, 4), this.postEffectBlurY = new o(this.renderBack2.texture, 0, 1, 4), this.mirrorCamera.up.set(0, -1, 0), this.obj, this.createObj()
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "add",
                value: function(t, e) {
                    e.add(this.obj), t.add(this.postEffectBlurX.obj), t.add(this.postEffectBlurY.obj)
                }
            }, {
                key: "createObj",
                value: function() {
                    var t = new i.PlaneBufferGeometry(4e3, 4e3),
                        e = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(468),
                            fragmentShader: n(469),
                            transparent: !0
                        });
                    this.obj = new i.Mesh(t, e), this.obj.rotation.set(-.5 * Math.PI, 0, 0)
                }
            }, {
                key: "updateTextureMatrix",
                value: function() {
                    this.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, 1, 0, 0, 0, 0, 1), this.textureMatrix.multiply(this.mirrorCamera.projectionMatrix), this.textureMatrix.multiply(this.mirrorCamera.matrixWorldInverse)
                }
            }, {
                key: "render",
                value: function(t, e, n, r, i) {
                    this.uniforms.time.value += i, this.updateTextureMatrix(), this.obj.visible = !1, t.render(n, this.mirrorCamera, this.renderBack1), this.obj.visible = !0, this.postEffectBlurX.render(t, e, r, this.renderBack2), this.postEffectBlurY.render(t, e, r, this.mirrorRender)
                }
            }, {
                key: "resize",
                value: function(t) {
                    this.mirrorCamera.aspect = t.x / t.y, this.mirrorCamera.updateProjectionMatrix(), this.mirrorRender.setSize(t.x, t.y), this.renderBack1.setSize(t.x, t.y), this.renderBack2.setSize(t.x, t.y), this.postEffectBlurX.resize(t), this.postEffectBlurY.resize(t)
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform vec2 direction;\nuniform float radius;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvec4 gaussianBlur(sampler2D texture, vec2 uv, float radius, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 step = radius / resolution * direction;\n  color += texture2D(texture, uv - 4.0 * step) * 0.02699548325659403;\n  color += texture2D(texture, uv - 3.0 * step) * 0.06475879783294587;\n  color += texture2D(texture, uv - 2.0 * step) * 0.12098536225957168;\n  color += texture2D(texture, uv - 1.0 * step) * 0.17603266338214976;\n  color += texture2D(texture, uv) * 0.19947114020071635;\n  color += texture2D(texture, uv + 1.0 * step) * 0.17603266338214976;\n  color += texture2D(texture, uv + 2.0 * step) * 0.12098536225957168;\n  color += texture2D(texture, uv + 3.0 * step) * 0.06475879783294587;\n  color += texture2D(texture, uv + 4.0 * step) * 0.02699548325659403;\n  return color;\n}\n\nvoid main() {\n  vec4 color = gaussianBlur(texture, vUv, radius, resolution, direction);\n  gl_FragColor = color;\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 textureMatrix;\n\nvarying vec3 vPosition;\nvarying vec4 vUv;\n\nvoid main(void) {\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n\n  vPosition = worldPosition.xyz;\n  vUv = textureMatrix * worldPosition;\n\n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec3 cameraPosition;\nuniform sampler2D texture;\n\nvarying vec3 vPosition;\nvarying vec4 vUv;\n\nconst float mirrorOpacity = 0.2;\n\nvoid main() {\n  float opacity = 1.0 - length(vPosition - cameraPosition) / 700.0;\n\n  vec4 mirrorColor = vec4(vec3(0.9), 1.0) * (1.0 - mirrorOpacity);\n\n  vec4 projectorColor = texture2DProj(texture, vUv) * mirrorOpacity;\n\n  gl_FragColor = (mirrorColor + projectorColor) * vec4(vec3(1.0), opacity);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t(e, n) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    brightMin: {
                        type: "f",
                        value: e
                    },
                    texture: {
                        type: "t",
                        value: n
                    }
                }, this.obj, this.createObj()
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.PlaneBufferGeometry(2, 2),
                        e = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(98),
                            fragmentShader: n(471)
                        });
                    this.obj = new i.Mesh(t, e), this.obj.visible = !1
                }
            }, {
                key: "render",
                value: function(t, e, n, r) {
                    this.obj.visible = !0, t.render(e, n, r), this.obj.visible = !1
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float brightMin;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 bright = max(vec4(0.0), (texture2D(texture, vUv) - brightMin));\n  gl_FragColor = bright;\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t(e, n, r) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    brightMin: {
                        type: "f",
                        value: e
                    },
                    texture1: {
                        type: "t",
                        value: n
                    },
                    texture2: {
                        type: "t",
                        value: r
                    }
                }, this.obj, this.createObj()
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.PlaneBufferGeometry(2, 2),
                        e = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(98),
                            fragmentShader: n(473)
                        });
                    this.obj = new i.Mesh(t, e), this.obj.visible = !1
                }
            }, {
                key: "render",
                value: function(t, e, n, r) {
                    this.obj.visible = !0, t.render(e, n, r), this.obj.visible = !1
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float brightMin;\nuniform sampler2D texture1;\nuniform sampler2D texture2;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 color1 = texture2D(texture1, vUv);\n  vec4 color2 = texture2D(texture2, vUv);\n  gl_FragColor = color1 * brightMin + color2;\n}\n"
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(475).default;
    e.default = function() {
        var t = {
                x: 0,
                y: 0
            },
            e = document.getElementById("canvas-webgl"),
            n = new r.WebGLRenderer({
                antialias: !1,
                canvas: e
            }),
            a = new r.Scene,
            s = new r.OrthographicCamera(-1, 1, 1, -1, 1, 1e4),
            c = new r.Clock,
            u = new r.Vector2,
            l = new r.Vector2,
            h = new r.Vector2,
            f = new o,
            d = function t() {
                ! function() {
                    var t = c.getDelta();
                    f.render(t), n.render(a, s)
                }(), requestAnimationFrame(t)
            },
            v = function() {
                t.x = document.body.clientWidth, t.y = window.innerHeight, e.width = t.x, e.height = t.y,
                    function() {
                        var e = 640 * Math.min(t.x / t.y / (640 / 480), 1),
                            n = 480 * Math.min(t.y / t.x / .75, 1);
                        s.left = -.5 * e, s.right = .5 * e, s.top = .5 * n, s.bottom = -.5 * n, s.updateProjectionMatrix()
                    }(), n.setSize(t.x, t.y)
            },
            p = function(t) {
                !0
            },
            m = function(t) {
                !1
            };
        window.addEventListener("resize", i(v, 1e3)), e.addEventListener("mousedown", function(t) {
            t.preventDefault(), u.set(t.clientX, t.clientY), p()
        }), document.addEventListener("mousemove", function(t) {
            t.preventDefault(), l.set(t.clientX, t.clientY)
        }), document.addEventListener("mouseup", function(t) {
            t.preventDefault(), h.set(t.clientX, t.clientY), m()
        }), e.addEventListener("touchstart", function(t) {
            t.preventDefault(), u.set(t.touches[0].clientX, t.touches[0].clientY), p()
        }), e.addEventListener("touchmove", function(t) {
            t.preventDefault(), l.set(t.touches[0].clientX, t.touches[0].clientY)
        }), e.addEventListener("touchend", function(t) {
            t.preventDefault(), h.set(t.changedTouches[0].clientX, t.changedTouches[0].clientY), m()
        }), v(), n.setClearColor(0, 1), s.position.set(0, 0, 100), s.lookAt(new r.Vector3), a.add(f.obj), d()
    }
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    noiseRange: {
                        type: "f",
                        value: 3 * Math.random()
                    },
                    speed: {
                        type: "f",
                        value: .08
                    },
                    circleOutStepMin: {
                        type: "f",
                        value: .1
                    },
                    circleOutStepMax: {
                        type: "f",
                        value: 1
                    },
                    circleInStepMin: {
                        type: "f",
                        value: 0
                    },
                    circleInStepMax: {
                        type: "f",
                        value: .3
                    },
                    noisePosition: {
                        type: "f",
                        value: .8
                    },
                    noiseSize: {
                        type: "f",
                        value: .5
                    }
                }, this.obj = this.createObj()
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.Mesh(new i.PlaneBufferGeometry(640, 640), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(476),
                        fragmentShader: n(477),
                        transparent: !0
                    }));
                    return t.position.set(80, 0, 0), t
                }
            }, {
                key: "render",
                value: function(t) {
                    this.obj.visible && (this.uniforms.time.value += t)
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvoid main() {\n  vPosition = position;\n  vUv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec3 cameraPosition;\nuniform float time;\nuniform float noiseRange;\nuniform sampler2D texEgg1;\nuniform sampler2D texEgg2;\nuniform sampler2D texDiffSpace;\n\nuniform float speed;\nuniform float circleOutStepMin;\nuniform float circleOutStepMax;\nuniform float circleInStepMin;\nuniform float circleInStepMax;\nuniform float noisePosition;\nuniform float noiseSize;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_2_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_2_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_2_1(vec4 x) {\n     return mod289_2_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_2_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_2_3(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_2_4 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_2_5 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_2_5;\n  vec3 i1 = min( g_2_5.xyz, l.zxy );\n  vec3 i2 = max( g_2_5.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_2_4.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_2_0(i);\n  vec4 p = permute_2_1( permute_2_1( permute_2_1(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_2_4.wyz - D_2_4.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_2_6 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_2_7 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_2_6.xy,h.z);\n  vec3 p3 = vec3(a1_2_6.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_2_2(vec4(dot(p0_2_7,p0_2_7), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_2_7 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_2_7,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\nvec3 convertHsvToRgb_1_8(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat exponentialOut_3_9(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\n\n\n\nvoid main() {\n  float t1 = exponentialOut_3_9(min(time, 2.0) / 2.0);\n  float t2 = (1.0 - exponentialOut_3_9(min(time, 2.0) / 2.0)) * 3.0;\n  vec2 pos = vUv * 2.0 - vec2(1.0);\n\n  float circleOut = smoothstep(circleOutStepMin, circleOutStepMax, t1 - length(pos));\n  float circleIn = smoothstep(circleInStepMin, circleInStepMax, t1 * 0.5 - length(pos)) * 0.5;\n  float circleLight = smoothstep(0.0, 0.1, (t1 - t2) * 0.3 - length(pos)) * smoothstep(0.0, 0.1, (t1 - t2) * 0.2 - length(pos + vec2(0.2, -0.2)));\n\n  float noiseTime = time * speed + t2;\n  float noise = (\n    snoise_2_3(\n      vec3(pos * (noisePosition + noiseRange * 0.1) + vec2(sin(noiseTime),\n      cos(noiseTime)),\n      noiseTime + noiseRange * 100.0\n      )\n    ) + 1.0) / 2.0 * noiseSize;\n\n  float mask = circleOut * noise + circleIn;\n  float maskHighLight = circleLight * (noise + 0.12);\n  float mask0 = 1.0 - step(maskHighLight, 0.13);\n  float mask1 = (1.0 - step(mask, 0.6)) * step(maskHighLight, 0.13);\n  float mask2 = (1.0 - step(mask, 0.28)) * step(mask, 0.6) * step(maskHighLight, 0.23);\n  float mask3 = (1.0 - step(mask, 0.014)) * step(mask, 0.28);\n  float mask4 = (1.0 - step(mask, 0.01)) * step(mask, 0.014);\n\n  vec4 rgba0 = vec4(convertHsvToRgb_1_8(vec3(0.125, 0.2, 1.0)), 1.0) * mask0;\n  vec4 rgba1 = vec4(convertHsvToRgb_1_8(vec3(0.125, 0.76, 1.0)), 1.0) * mask1;\n  vec4 rgba2 = vec4(convertHsvToRgb_1_8(vec3(0.108, 0.91, 1.0)), 1.0) * mask2;\n  vec4 rgba3 = vec4(convertHsvToRgb_1_8(vec3(0.1, 0.02, 0.99)), 1.0) * mask3;\n  vec4 rgba4 = vec4(convertHsvToRgb_1_8(vec3(0.1, 0.2, 0.9)), 1.0) * mask4;\n\n  float patternNoise1 = step(0.0, snoise_2_3(vPosition * 0.015 + vec3(0.0, 0.0, time * 0.1))) * 0.05;\n  float patternNoise2 = step(0.2, snoise_2_3(vPosition * 0.025 + vec3(0.0, 1.0, time * 0.3))) * 0.03;\n  vec4 patternColor = vec4(vec3(patternNoise1), 1.0) * mask1 + vec4(vec3(patternNoise2), 1.0) * mask2;\n\n  vec4 eggColor = rgba0 + rgba1 + rgba2 + rgba3 + rgba4 + patternColor;\n\n  gl_FragColor = eggColor;\n}\n"
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(13).default,
        a = n(479).default,
        s = n(482).default,
        c = n(485).default,
        u = n(489).default,
        l = n(136).default,
        h = n(491).default;
    e.default = function() {
        var t = {
                x: 0,
                y: 0
            },
            e = document.getElementById("canvas-webgl"),
            n = new r.WebGLRenderer({
                antialias: !1,
                canvas: e,
                alpha: !0
            }),
            f = new r.WebGLRenderTarget(0, 0),
            d = new r.WebGLRenderTarget(0, 0),
            v = new r.WebGLRenderTarget(0, 0),
            p = new r.Scene,
            m = new r.Scene,
            g = new r.OrthographicCamera(-1, 1, 1, -1, 0, 1),
            y = new r.PerspectiveCamera(30, 1, 1, 15e3),
            x = new r.Clock,
            b = new r.TextureLoader,
            w = new r.Vector2,
            _ = new r.Vector2,
            M = new r.Vector2,
            S = [],
            E = new s(720),
            T = new c(t),
            P = new u(f.texture),
            L = new l(d.texture, 1, 0, 1),
            A = new l(v.texture, 0, 1, 1),
            z = new h(f.texture, d.texture),
            C = function() {
                t.x = document.body.clientWidth, t.y = window.innerHeight, e.width = t.x, e.height = t.y, y.aspect = t.x / t.y, y.updateProjectionMatrix(), T.resize(t), L.resize(t), A.resize(t), f.setSize(t.x, t.y), d.setSize(t.x, t.y), v.setSize(t.x, t.y), n.setSize(t.x, t.y)
            },
            R = function t() {
                ! function() {
                    for (var t = x.getDelta(), e = 0; e < S.length; e++) S[e].render(n, t);
                    E.render(t), T.render(n, p, m, g, t), n.render(m, y, f), P.render(n, p, g, d), L.render(n, p, g, v), A.render(n, p, g, d), z.render(n, p, g)
                }(), requestAnimationFrame(t)
            },
            I = function(t) {
                !0
            },
            D = function(t) {
                !1
            },
            O = function() {
                window.addEventListener("resize", i(C, 1e3)), e.addEventListener("mousedown", function(t) {
                    t.preventDefault(), w.set(t.clientX, t.clientY), o(w), I()
                }), e.addEventListener("mousemove", function(t) {
                    t.preventDefault(), _.set(t.clientX, t.clientY), o(_)
                }), e.addEventListener("mouseup", function(t) {
                    t.preventDefault(), M.set(t.clientX, t.clientY), o(M), D()
                }), e.addEventListener("touchstart", function(t) {
                    t.preventDefault(), w.set(t.touches[0].clientX, t.touches[0].clientY), o(w), I(t.touches[0].clientX, t.touches[0].clientY)
                }), e.addEventListener("touchmove", function(t) {
                    t.preventDefault(), _.set(t.touches[0].clientX, t.touches[0].clientY), o(_)
                }), e.addEventListener("touchend", function(t) {
                    t.preventDefault(), M.set(t.changedTouches[0].clientX, t.changedTouches[0].clientY), o(M), D()
                }), window.addEventListener("mouseout", function() {
                    event.preventDefault(), M.set(0, 0), !1
                })
            };
        C(), O(), n.setClearColor(0, 1), y.position.set(400, 500, 800), T.mirrorCamera.position.set(y.position.x, -1 * y.position.y, y.position.z), y.lookAt(new r.Vector3(0, 100, 0)), T.mirrorCamera.lookAt(new r.Vector3(0, -100, 0)), b.load("/sketch-threejs/img/sketch/butterfly/tex.png", function(t) {
            t.magFilter = r.NearestFilter, t.minFilter = r.NearestFilter;
            for (var e = 0; e < 12; e++) S[e] = new a(e, t), S[e].obj.position.x = 280 * (2 * Math.random() - 1), S[e].obj.position.z = 150 * e, m.add(S[e].obj);
            E.addButterflies(S), m.add(E.obj), T.add(p, m), p.add(P.obj), p.add(L.obj), p.add(A.obj), p.add(z.obj), R()
        })
    }
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = 280,
        a = function() {
            function t(e, n) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    index: {
                        type: "f",
                        value: e
                    },
                    time: {
                        type: "f",
                        value: 0
                    },
                    size: {
                        type: "f",
                        value: o
                    },
                    texture: {
                        type: "t",
                        value: n
                    },
                    colorH: {
                        type: "f",
                        value: Math.random()
                    }
                }, this.obj = this.createObj(), this.obj.renderOrder = 10
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.PlaneBufferGeometry(o, o / 2, 24, 12),
                        e = new i.Mesh(t, new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(480),
                            fragmentShader: n(481),
                            side: i.DoubleSide,
                            transparent: !0
                        }));
                    return e.position.y = .5 * o + (2 * Math.random() - 1) * o * .1, e.rotation.set(-45 * Math.PI / 180, 0, 0), e
                }
            }, {
                key: "render",
                value: function(t, e) {
                    this.uniforms.time.value += e, this.obj.position.z -= 4, this.obj.position.z < -900 && (this.obj.position.x = 280 * (2 * Math.random() - 1), this.obj.position.z = 900, this.uniforms.colorH.value = Math.random())
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float index;\nuniform float time;\nuniform float size;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\nvoid main() {\n  float flapTime = radians(sin(time * 4.0 - length(position.xy) / size * 2.0 + index * 2.0) * 45.0 + 30.0);\n  float hovering = cos(time * 2.0 + index * 3.0) * size / 16.0;\n  vec3 updatePosition = vec3(\n    cos(flapTime) * position.x,\n    position.y + hovering,\n    sin(flapTime) * abs(position.x) + hovering\n  );\n\n  vPosition = position;\n  vUv = uv;\n  vOpacity = (1.0 - smoothstep(0.75, 1.0, abs((modelMatrix * vec4(updatePosition, 1.0)).z) / 900.0)) * 0.85;\n\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(updatePosition, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float size;\nuniform sampler2D texture;\nuniform float colorH;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1_1(vec4 x) {\n     return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_1_3(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_1_4 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_1_5 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_1_5;\n  vec3 i1 = min( g_1_5.xyz, l.zxy );\n  vec3 i2 = max( g_1_5.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_1_4.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_1_0(i);\n  vec4 p = permute_1_1( permute_1_1( permute_1_1(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_1_4.wyz - D_1_4.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_1_6 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_1_7 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_1_6.xy,h.z);\n  vec3 p3 = vec3(a1_1_6.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_1_2(vec4(dot(p0_1_7,p0_1_7), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_1_7 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_1_7,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\nvec3 convertHsvToRgb_2_8(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main() {\n  vec4 texColor = texture2D(texture, vUv);\n\n  float noise = snoise_1_3(vPosition / vec3(size * 0.25) + vec3(0.0, 0.0, time));\n  vec3 hsv = vec3(colorH + noise * 0.2, 0.4, 1.0);\n  vec3 rgb = convertHsvToRgb_2_8(hsv);\n\n  if (texColor.a < 0.5) discard;\n\n  gl_FragColor = vec4(rgb, vOpacity) * texColor;\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(2),
        a = function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.interval = 4, this.attr = {
                    position: new i.BufferAttribute(new Float32Array(3 * e), 3),
                    colorH: new i.BufferAttribute(new Float32Array(e), 1),
                    index: new i.BufferAttribute(new Float32Array(e), 1),
                    valid: new i.BufferAttribute(new Float32Array(e), 1)
                }, this.geometry = new i.BufferGeometry, this.uniforms = {
                    size: {
                        type: "f",
                        value: e
                    },
                    interval: {
                        type: "f",
                        value: this.interval
                    },
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.butterflies = null, this.butterfliesLengh = 0, this.obj = this.createObj(), this.obj.renderOrder = 20
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    for (var t = 0; t < this.uniforms.size.value; t++) this.attr.index.setX(t, t);
                    return this.geometry.addAttribute("position", this.attr.position), this.geometry.addAttribute("colorH", this.attr.colorH), this.geometry.addAttribute("i", this.attr.index), this.geometry.addAttribute("valid", this.attr.valid), new i.Points(this.geometry, new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(483),
                        fragmentShader: n(484),
                        depthWrite: !1,
                        transparent: !0
                    }))
                }
            }, {
                key: "addButterflies",
                value: function(t) {
                    this.butterflies = t, this.butterfliesLengh = t.length
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t;
                    for (var e = 0; e < this.uniforms.size.value; e++) {
                        var n = (this.uniforms.time.value + this.attr.index.getX(e) / this.uniforms.size.value * this.interval) % this.interval,
                            r = this.attr.valid.getX(e);
                        if (n >= .9 * this.interval && 1 == r) this.attr.valid.setX(e, 0);
                        else if (n <= .9 * this.interval && 0 == r) {
                            var i = Math.floor(Math.random() * this.butterfliesLengh),
                                a = this.butterflies[i],
                                s = (-90 * Math.random() - 90) * Math.PI / 180,
                                c = -180 * Math.random() * Math.PI / 180,
                                u = Math.random() * a.uniforms.size.value / 4 + a.uniforms.size.value / 8,
                                l = o.spherical(s, c, u);
                            this.attr.position.setXYZ(e, l[0] + a.obj.position.x, .2 * l[1] + a.obj.position.y + 20 * Math.sin(a.uniforms.time.value), .5 * l[2] + a.obj.position.z), this.attr.colorH.setX(e, a.uniforms.colorH.value), this.attr.valid.setX(e, 1)
                        }
                    }
                    this.attr.position.needsUpdate = !0, this.attr.colorH.needsUpdate = !0
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute float colorH;\nattribute float i;\nattribute float valid;\n\nuniform vec3 cameraPosition;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float size;\nuniform float interval;\nuniform float time;\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main() {\n  float thisTime = mod(time + i / size * interval, interval);\n\n  vec3 updatePosition = position + vec3(\n    cos(thisTime * 3.0 + i) * 3.0,\n    thisTime * -16.0,\n    sin(thisTime * 3.0 + i) * 3.0\n  );\n  vec4 mvPosition = viewMatrix * modelMatrix * vec4(updatePosition, 1.0);\n\n  vec3 hsv = vec3(colorH + sin(i) * 0.075, 0.8, 1.0);\n\n  vColor = convertHsvToRgb_1_0(hsv);\n  vOpacity = smoothstep(interval * 0.0, interval * 0.1, thisTime)\n    * (1.0 - smoothstep(interval * 0.2, interval * 0.9, thisTime));\n\n  gl_PointSize = 12000.0 / length(mvPosition.xyz);\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main() {\n  // to round.\n  vec3 n;\n  n.xy = gl_PointCoord * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n\n  gl_FragColor = vec4(vColor, vOpacity * 0.5);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(136).default,
        a = function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.mirrorCamera = new i.PerspectiveCamera(30, e.x / e.y, 1, 15e3), this.mirrorRender = new i.WebGLRenderTarget(e.x, e.y), this.textureMatrix = new i.Matrix4, this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    texture: {
                        type: "t",
                        value: this.mirrorRender.texture
                    },
                    textureMatrix: {
                        type: "m4",
                        value: this.textureMatrix
                    }
                }, this.renderBack1 = new i.WebGLRenderTarget(e.x, e.y), this.renderBack2 = new i.WebGLRenderTarget(e.x, e.y), this.postEffectBlurX = new o(this.renderBack1.texture, 1, 0, 4), this.postEffectBlurY = new o(this.renderBack2.texture, 0, 1, 4), this.mirrorCamera.up.set(0, -1, 0), this.obj = this.createObj()
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "add",
                value: function(t, e) {
                    e.add(this.obj), t.add(this.postEffectBlurX.obj), t.add(this.postEffectBlurY.obj)
                }
            }, {
                key: "createObj",
                value: function() {
                    var t = new i.Mesh(new i.PlaneBufferGeometry(1e3, 2e3), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(487),
                        fragmentShader: n(488),
                        transparent: !0
                    }));
                    return t.rotation.set(-.5 * Math.PI, 0, 0), t
                }
            }, {
                key: "updateTextureMatrix",
                value: function() {
                    this.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, 1, 0, 0, 0, 0, 1), this.textureMatrix.multiply(this.mirrorCamera.projectionMatrix), this.textureMatrix.multiply(this.mirrorCamera.matrixWorldInverse)
                }
            }, {
                key: "render",
                value: function(t, e, n, r, i) {
                    this.uniforms.time.value += i, this.updateTextureMatrix(), this.obj.visible = !1, t.render(n, this.mirrorCamera, this.renderBack1), this.obj.visible = !0, this.postEffectBlurX.render(t, e, r, this.renderBack2), this.postEffectBlurY.render(t, e, r, this.mirrorRender)
                }
            }, {
                key: "resize",
                value: function(t) {
                    this.mirrorCamera.aspect = t.x / t.y, this.mirrorCamera.updateProjectionMatrix(), this.mirrorRender.setSize(t.x, t.y), this.renderBack1.setSize(t.x, t.y), this.renderBack2.setSize(t.x, t.y), this.postEffectBlurX.resize(t), this.postEffectBlurY.resize(t)
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform vec2 direction;\nuniform float radius;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvec4 gaussianBlur(sampler2D texture, vec2 uv, float radius, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 step = radius / resolution * direction;\n  color += texture2D(texture, uv - 4.0 * step) * 0.02699548325659403;\n  color += texture2D(texture, uv - 3.0 * step) * 0.06475879783294587;\n  color += texture2D(texture, uv - 2.0 * step) * 0.12098536225957168;\n  color += texture2D(texture, uv - 1.0 * step) * 0.17603266338214976;\n  color += texture2D(texture, uv) * 0.19947114020071635;\n  color += texture2D(texture, uv + 1.0 * step) * 0.17603266338214976;\n  color += texture2D(texture, uv + 2.0 * step) * 0.12098536225957168;\n  color += texture2D(texture, uv + 3.0 * step) * 0.06475879783294587;\n  color += texture2D(texture, uv + 4.0 * step) * 0.02699548325659403;\n  return color;\n}\n\nvoid main() {\n  vec4 color = gaussianBlur(texture, vUv, radius, resolution, direction);\n  gl_FragColor = color;\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 textureMatrix;\n\nvarying vec4 vUv;\n\nvoid main(void) {\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n  vUv = textureMatrix * worldPosition;\n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\n\nvarying vec4 vUv;\n\nvoid main() {\n  vec4 projectorColor;\n  if (all(bvec4(vUv.x >= 0.0, vUv.y >= 0.0, vUv.x <= vUv.z, vUv.y <= vUv.z))) {\n    projectorColor = texture2DProj(texture, vUv);\n  }\n  gl_FragColor = vec4(vec3(1.0), 0.3) * projectorColor;\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    minBright: {
                        type: "f",
                        value: .3
                    },
                    texture: {
                        type: "t",
                        value: e
                    }
                }, this.obj = this.createObj(), this.obj.visible = !1
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(99),
                        fragmentShader: n(490)
                    }))
                }
            }, {
                key: "render",
                value: function(t, e, n, r) {
                    this.obj.visible = !0, t.render(e, n, r), this.obj.visible = !1
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float minBright;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 bright = max(vec4(0.0), (texture2D(texture, vUv) - minBright));\n  gl_FragColor = bright;\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t(e, n) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    texture1: {
                        type: "t",
                        value: e
                    },
                    texture2: {
                        type: "t",
                        value: n
                    }
                }, this.obj = this.createObj(), this.obj.visible = !1
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(99),
                        fragmentShader: n(492)
                    }))
                }
            }, {
                key: "render",
                value: function(t, e, n, r) {
                    this.obj.visible = !0, t.render(e, n, r), this.obj.visible = !1
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D texture1;\nuniform sampler2D texture2;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 color1 = texture2D(texture1, vUv);\n  vec4 color2 = texture2D(texture2, vUv);\n  gl_FragColor = color1 * 0.5 + color2;\n}\n"
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(13).default,
        a = n(494).default;
    e.default = function() {
        for (var t = document.getElementById("canvas-webgl"), e = new r.WebGLRenderer({
                antialias: !1,
                canvas: t,
                alpha: !0
            }), n = new r.Scene, s = new r.PerspectiveCamera(90, document.body.clientWidth / window.innerHeight, 1, 1e4), c = new r.Clock, u = new r.Vector2, l = new r.Vector2, h = new r.Vector2, f = 0, d = 0, v = [], p = 0; p < 20; p++) v[p] = new a, n.add(v[p].obj);
        var m = function() {
                t.width = document.body.clientWidth, t.height = window.innerHeight, s.aspect = document.body.clientWidth / window.innerHeight, s.updateProjectionMatrix(), e.setSize(document.body.clientWidth, window.innerHeight)
            },
            g = function() {
                var t = c.getDelta();
                ! function(t) {
                    (d += t) > 1 && (v[f].show(), f = f + 1 >= v.length - 1 ? 0 : f + 1, d = 0)
                }(t);
                for (var r = 0; r < v.length; r++) v[r].render(t);
                e.render(n, s)
            },
            y = function(t) {
                !0
            },
            x = function(t) {
                !1
            };
        e.setSize(document.body.clientWidth, window.innerHeight), e.setClearColor(0, 1), s.position.set(0, 0, 1e3), s.lookAt(new r.Vector3), window.addEventListener("resize", i(function() {
                m()
            }), 1e3), t.addEventListener("mousedown", function(t) {
                t.preventDefault(), u.set(t.clientX, t.clientY), o(u), y()
            }), document.addEventListener("mousemove", function(t) {
                t.preventDefault(), l.set(t.clientX, t.clientY), o(l)
            }), document.addEventListener("mouseup", function(t) {
                t.preventDefault(), h.set(t.clientX, t.clientY), o(h), x()
            }), t.addEventListener("touchstart", function(t) {
                t.preventDefault(), u.set(t.touches[0].clientX, t.touches[0].clientY), o(u), y(t.touches[0].clientX, t.touches[0].clientY)
            }), t.addEventListener("touchmove", function(t) {
                t.preventDefault(), l.set(t.touches[0].clientX, t.touches[0].clientY), o(l)
            }), t.addEventListener("touchend", function(t) {
                t.preventDefault(), h.set(t.changedTouches[0].clientX, t.changedTouches[0].clientY), o(h), x()
            }), m(),
            function t() {
                g(), requestAnimationFrame(t)
            }()
    }
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    colorH: {
                        type: "f",
                        value: 0
                    },
                    noiseRange: {
                        type: "f",
                        value: 0
                    }
                }, this.obj = this.createObj(), this.obj.visible = !1
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(1500, 1500), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(495),
                        fragmentShader: n(496),
                        transparent: !0
                    }))
                }
            }, {
                key: "show",
                value: function(t) {
                    this.uniforms.time.value = 0, this.uniforms.colorH.value = Math.random(), this.uniforms.noiseRange.value = 3 * Math.random(), this.obj.visible = !0, this.obj.position.set((2 * Math.random() - 1) * window.innerWidth, (2 * Math.random() - 1) * window.innerHeight, 0)
                }
            }, {
                key: "render",
                value: function(t) {
                    this.obj.visible && (this.uniforms.time.value += t, this.obj.position.z -= 3)
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float colorH;\nuniform float noiseRange;\n\nvarying vec2 vUv;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1_1(vec4 x) {\n     return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_1_3(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_1_4 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_1_5 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_1_5;\n  vec3 i1 = min( g_1_5.xyz, l.zxy );\n  vec3 i2 = max( g_1_5.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_1_4.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_1_0(i);\n  vec4 p = permute_1_1( permute_1_1( permute_1_1(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_1_4.wyz - D_1_4.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_1_6 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_1_7 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_1_6.xy,h.z);\n  vec3 p3 = vec3(a1_1_6.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_1_2(vec4(dot(p0_1_7,p0_1_7), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_1_7 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_1_7,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\nvec3 convertHsvToRgb_2_8(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat exponentialOut_3_9(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\n\n\n\nvoid main() {\n  float t1 = exponentialOut_3_9(min(time, 1.0) / 1.0);\n  float t2 = exponentialOut_3_9(clamp(time - 14.0, 0.0, 1.0) / 1.0);\n  vec2 pos = vUv * 2.0 - vec2(1.0);\n  float circleOut = smoothstep(0.0, 0.5, t1 - t2 - length(pos));\n  float circleIn = smoothstep(0.0, 0.5, (t1 - t2) * 0.5 - length(pos));\n  float noise = (snoise_1_3(vec3(pos * (1.4 + noiseRange * 0.1) + vec2(sin(time), cos(time)), time + noiseRange * 100.0)) + 1.0) / 2.0;\n  float mask = circleOut * noise + circleIn;\n  float opacity = 1.0 - step(mask, 0.3);\n  float h1 = step(mask, 0.99) * 0.4 - time * 0.05;\n  float h2 = step(mask, 0.4) * 0.5;\n  vec3 hsv = vec3(h1 - h2 + colorH, 0.45, 0.8);\n  vec3 rgb = convertHsvToRgb_2_8(hsv);\n  gl_FragColor = vec4(rgb, opacity);\n}\n"
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = (n(13).default, n(498).default),
        a = n(507).default,
        s = n(510).default;
    e.default = function() {
        var t = document.getElementById("canvas-webgl"),
            e = new r.WebGLRenderer({
                antialias: !0,
                canvas: t
            }),
            n = new r.WebGLRenderTarget(document.body.clientWidth, window.innerHeight),
            c = new r.Scene,
            u = new r.Scene,
            l = new r.PerspectiveCamera(24, document.body.clientWidth / window.innerHeight, 1, 15e3),
            h = new r.Clock,
            f = new r.Vector2,
            d = new r.Vector2,
            v = new r.Vector2,
            p = new r.Vector2,
            m = new Uint8Array(4),
            g = !1,
            y = new o,
            x = new a,
            b = new s,
            w = function() {
                t.width = document.body.clientWidth, t.height = window.innerHeight, l.aspect = document.body.clientWidth / window.innerHeight, l.updateProjectionMatrix(), e.setSize(document.body.clientWidth, window.innerHeight), n.setSize(document.body.clientWidth, window.innerHeight), x.resize()
            },
            _ = function t() {
                ! function() {
                    var t = h.getDelta();
                    e.setClearColor(0, 1), y.render(t), x.render(e, c, t), b.render(e, c, t), e.render(c, l)
                }(), requestAnimationFrame(t)
            },
            M = function(t) {
                g = !0
            },
            S = function(t) {
                g ? t && y.rotate(2 * (d.x - v.x)) : (e.setClearColor(0, 1), e.render(u, l, n), e.readRenderTargetPixels(n, d.x, n.height - d.y, 1, 1, m), y.picked(m[0] << 16 | m[1] << 8 | m[2]))
            },
            E = function(t) {
                g = !1
            },
            T = function() {
                window.addEventListener("resize", i(function() {
                    w()
                }), 1e3), t.addEventListener("mousedown", function(t) {
                    t.preventDefault(), f.set(t.clientX, t.clientY), M()
                }), document.addEventListener("mousemove", function(t) {
                    t.preventDefault(), d.set(t.clientX, t.clientY), S(!1)
                }), document.addEventListener("mouseup", function(t) {
                    t.preventDefault(), p.set(t.clientX, t.clientY), E()
                }), t.addEventListener("wheel", function(t) {
                    t.preventDefault(),
                        function(t) {
                            y.rotate(t.deltaY)
                        }(t)
                }), t.addEventListener("touchstart", function(t) {
                    t.preventDefault(), f.set(t.touches[0].clientX, t.touches[0].clientY), d.set(t.touches[0].clientX, t.touches[0].clientY), v.set(t.touches[0].clientX, t.touches[0].clientY), M(t.touches[0].clientX, t.touches[0].clientY)
                }), t.addEventListener("touchmove", function(t) {
                    t.preventDefault(), d.set(t.touches[0].clientX, t.touches[0].clientY), S(!0), v.set(t.touches[0].clientX, t.touches[0].clientY)
                }), t.addEventListener("touchend", function(t) {
                    t.preventDefault(), p.set(t.changedTouches[0].clientX, t.changedTouches[0].clientY), E()
                })
            };
        e.setSize(document.body.clientWidth, window.innerHeight), l.position.set(0, 400, -3e3), l.lookAt(new r.Vector3(0, 0, 0)), x.mirrorCamera.position.set(0, -400, -3e3), x.mirrorCamera.lookAt(new r.Vector3(0, 0, 0)), y.core.obj.position.set(0, 80, 0), y.wire.obj.position.set(0, 80, 0), y.wire.objPicked.position.set(0, 80, 0), x.obj.rotation.set(-.5 * Math.PI, 0, 0), c.add(y.core.obj), c.add(y.wire.obj), c.add(x.obj), c.add(b.obj), c.add(b.cubeCamera), u.add(y.wire.objPicked), T(), w(), _()
    }
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return s
    });
    n(0), n(2), n(3);
    var i = n(63).default,
        o = n(499).default,
        a = n(502).default,
        s = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.velocity = [0, 0, 0], this.acceleration = [0, 0, 0], this.anchor = [0, 0, 0], this.instances = 36, this.core = new o(this.instances), this.wire = new a(this.instances)
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "updateRotation",
                value: function() {
                    i.applyHook(this.velocity, this.acceleration, this.anchor, 0, .02), i.applyDrag(this.acceleration, .3), i.updateVelocity(this.velocity, this.acceleration, 1), this.core.uniforms.rotate.value = this.velocity[0], this.wire.uniforms.rotate.value = this.velocity[0]
                }
            }, {
                key: "rotate",
                value: function(t) {
                    t && (this.anchor[0] -= .05 * t)
                }
            }, {
                key: "picked",
                value: function(t) {
                    this.core.uniforms.pickedId.value = t, this.wire.uniforms.pickedId.value = t, t < this.instances && t > -1 ? document.body.classList.add("is-picked") : document.body.classList.remove("is-picked")
                }
            }, {
                key: "render",
                value: function(t) {
                    this.core.uniforms.time.value += t, this.wire.render(t), this.updateRotation()
                }
            }]), t
        }()
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(2),
        a = function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    rotate: {
                        type: "f",
                        value: 0
                    },
                    pickedId: {
                        type: "f",
                        value: -1
                    }
                }, this.instances = e, this.obj = this.createObj()
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.InstancedBufferGeometry,
                        e = new i.OctahedronBufferGeometry(30, 4);
                    t.copy(e);
                    for (var r = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), a = new i.InstancedBufferAttribute(new Float32Array(3 * this.instances), 3), s = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), c = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), u = 0; u < this.instances; u++) r.setXYZ(u, o.radians(u / this.instances * 360)), a.setXYZ(u, u / this.instances - .25, .2, .9), s.setXYZ(u, Math.random()), c.setXYZ(u, .5 * (Math.random() + 1));
                    return t.addAttribute("radian", r), t.addAttribute("hsv", a), t.addAttribute("noiseDiff", s), t.addAttribute("speed", c), new i.Mesh(t, new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(500),
                        fragmentShader: n(501),
                        transparent: !0
                    }))
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute float radian;\nattribute vec3 hsv;\nattribute float noiseDiff;\nattribute float speed;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float rotate;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vColor;\n\nmat4 calcTranslateMat4_1_0(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4X_5_1(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Y_7_2(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Z_6_3(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n\nmat4 calcRotateMat4_2_4(vec3 radian) {\n  return calcRotateMat4X_5_1(radian.x) * calcRotateMat4Y_7_2(radian.y) * calcRotateMat4Z_6_3(radian.z);\n}\n\n\nvec3 convertHsvToRgb_4_5(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_3_6(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_3_6(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_3_7(vec4 x) {\n     return mod289_3_6(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_3_8(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_3_9(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_3_10 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_3_11 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_3_11;\n  vec3 i1 = min( g_3_11.xyz, l.zxy );\n  vec3 i2 = max( g_3_11.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_3_10.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_3_6(i);\n  vec4 p = permute_3_7( permute_3_7( permute_3_7(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_3_10.wyz - D_3_10.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_3_12 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_3_13 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_3_12.xy,h.z);\n  vec3 p3 = vec3(a1_3_12.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_3_8(vec4(dot(p0_3_13,p0_3_13), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_3_13 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_3_13,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\n\nvoid main(void) {\n  float noise = snoise_3_9(position * 0.02 + time * speed + noiseDiff);\n  mat4 rotateMatWorld = calcRotateMat4_2_4(vec3(0.0, radian + radians(rotate), 0.0));\n  mat4 translateMat = calcTranslateMat4_1_0(vec3(1000.0, 0.0, 0.0));\n  vec4 updatePosition = rotateMatWorld * translateMat * vec4(\n    position + normalize(position) * noise * 5.0,\n    1.0\n    );\n  vPosition = updatePosition.xyz;\n  vNormal = normal;\n  vColor = convertHsvToRgb_4_5(hsv);\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform vec3 cameraPosition;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vColor;\n\nconst vec3 light = vec3(0.7);\n\nvoid main() {\n  float diff = (dot(vNormal, light) + 1.0) / 2.0 * 0.25 + 0.75;\n  float opacity = (1.0 - (vPosition.z / 1000.0)) * 0.8 + 0.2;\n  gl_FragColor = vec4(vColor * diff, opacity);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(2),
        a = (n(63).default, function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.size = 120, this.baseGeometry = new i.BoxBufferGeometry(this.size, this.size, this.size), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    rotate: {
                        type: "f",
                        value: 0
                    },
                    pickedId: {
                        type: "f",
                        value: -1
                    }
                }, this.instances = e, this.obj = this.createObj(), this.objPicked = this.createObjPicked()
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.InstancedBufferGeometry;
                    t.copy(this.baseGeometry);
                    for (var e = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), r = new i.InstancedBufferAttribute(new Float32Array(3 * this.instances), 3), a = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), s = 0; s < this.instances; s++) e.setXYZ(s, o.radians(s / this.instances * 360)), r.setXYZ(s, s / this.instances - .25, .2, 1), a.setXYZ(s, 0);
                    return t.addAttribute("radian", e), t.addAttribute("hsv", r), t.addAttribute("timeHover", a), new i.Mesh(t, new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(503),
                        fragmentShader: n(504),
                        depthWrite: !1,
                        transparent: !0,
                        side: i.DoubleSide,
                        flatShading: !0
                    }))
                }
            }, {
                key: "createObjPicked",
                value: function() {
                    var t = new i.InstancedBufferGeometry;
                    t.copy(this.baseGeometry);
                    for (var e = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), r = new i.InstancedBufferAttribute(new Float32Array(3 * this.instances), 3), a = new i.Color, s = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), c = 0; c < this.instances; c++) e.setXYZ(c, o.radians(c / this.instances * 360)), a.setHex(c), r.setXYZ(c, a.r, a.g, a.b), s.setXYZ(c, 0);
                    return t.addAttribute("radian", e), t.addAttribute("pickedColor", r), t.addAttribute("timeHover", s), new i.Mesh(t, new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(505),
                        fragmentShader: n(506)
                    }))
                }
            }, {
                key: "render",
                value: function(t) {
                    var e = this.obj.geometry.attributes.timeHover,
                        n = this.objPicked.geometry.attributes.timeHover;
                    this.uniforms.time.value += t;
                    for (var r = 0; r < e.array.length; r++) this.uniforms.pickedId.value == r ? (e.array[r] = Math.min(e.array[r] + t, .3), n.array[r] = Math.min(n.array[r] + t, .3)) : (e.array[r] = Math.max(e.array[r] - t, 0), n.array[r] = Math.max(n.array[r] - t, 0));
                    e.needsUpdate = !0, n.needsUpdate = !0
                }
            }]), t
        }())
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute float radian;\nattribute vec3 hsv;\nattribute float timeHover;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float rotate;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vColor;\nvarying mat4 vInvertMatrix;\n\nfloat inverse_9_0(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse_9_0(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse_9_0(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse_9_0(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\n\nfloat circularOut_5_1(float t) {\n  return sqrt((2.0 - t) * t);\n}\n\n\n\nmat4 calcTranslateMat4_3_2(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4X_6_3(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Y_7_4(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Z_8_5(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n\nmat4 calcRotateMat4_2_6(vec3 radian) {\n  return calcRotateMat4X_6_3(radian.x) * calcRotateMat4Y_7_4(radian.y) * calcRotateMat4Z_8_5(radian.z);\n}\n\n\nmat4 calcScaleMat4_1_7(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nvec3 convertHsvToRgb_4_8(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main(void) {\n  float easeStep = circularOut_5_1(timeHover / 0.3);\n  mat4 rotateMatWorld = calcRotateMat4_2_6(vec3(0.0, radian + radians(rotate), 0.0));\n  mat4 scaleMat = calcScaleMat4_1_7(vec3(1.0 + easeStep * 0.2));\n  mat4 translateMat = calcTranslateMat4_3_2(vec3(1000.0, 0.0, 0.0));\n  vec4 updatePosition = rotateMatWorld * translateMat * scaleMat * vec4(position, 1.0);\n  vPosition = updatePosition.xyz;\n  vInvertMatrix = inverse_9_0(rotateMatWorld * translateMat);\n  vColor = convertHsvToRgb_4_8(hsv * vec3(1.0, 1.0 - easeStep, 1.0));\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform vec3 cameraPosition;\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\nvarying mat4 vInvertMatrix;\n\nconst vec3 color = vec3(0.9);\n\nvoid main() {\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  if(!gl_FrontFacing) {\n      normal = -normal;\n  }\n  vec3 light = normalize(vInvertMatrix * vec4(vec3(-1000.0, 1000.0, -1000.0), 1.0)).xyz;\n  float diff = (dot(normal, light) + 1.0) / 2.0 * 0.2 + 0.8;\n  float opacity = (1.0 - (vPosition.z / 1000.0)) * 0.1 + 0.1;\n  gl_FragColor = vec4(color * diff * vColor, opacity);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute float radian;\nattribute vec3 pickedColor;\nattribute float timeHover;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float rotate;\n\nvarying vec3 vColor;\n\nfloat circularOut_4_0(float t) {\n  return sqrt((2.0 - t) * t);\n}\n\n\n\nmat4 calcTranslateMat4_2_1(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4X_7_2(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Y_5_3(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Z_6_4(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n\nmat4 calcRotateMat4_1_5(vec3 radian) {\n  return calcRotateMat4X_7_2(radian.x) * calcRotateMat4Y_5_3(radian.y) * calcRotateMat4Z_6_4(radian.z);\n}\n\n\nmat4 calcScaleMat4_3_6(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n\nvoid main(void) {\n  float easeStep = circularOut_4_0(timeHover / 0.3);\n  mat4 rotateMatWorld = calcRotateMat4_1_5(vec3(0.0, radian + radians(rotate), 0.0));\n  mat4 scaleMat = calcScaleMat4_3_6(vec3(1.0 + easeStep * 0.2));\n  mat4 translateMat = calcTranslateMat4_2_1(vec3(1000.0, 0.0, 0.0));\n  vec4 updatePosition = rotateMatWorld * translateMat * scaleMat * vec4(position, 1.0);\n  vColor = pickedColor;\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.mirrorCamera = new i.PerspectiveCamera(24, document.body.clientWidth / window.innerHeight, 1, 15e3), this.mirrorRender = new i.WebGLRenderTarget(document.body.clientWidth, window.innerHeight), this.textureMatrix = new i.Matrix4, this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    texture: {
                        type: "t",
                        value: this.mirrorRender.texture
                    },
                    textureMatrix: {
                        type: "m4",
                        value: this.textureMatrix
                    },
                    mirrorPosition: {
                        type: "v3",
                        value: this.mirrorCamera.position
                    }
                }, this.mirrorCamera.up.set(0, -1, 0), this.obj = this.createObj()
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(4e3, 4e3), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(508),
                        fragmentShader: n(509),
                        transparent: !0
                    }))
                }
            }, {
                key: "updateTextureMatrix",
                value: function() {
                    this.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, 1, 0, 0, 0, 0, 1), this.textureMatrix.multiply(this.mirrorCamera.projectionMatrix), this.textureMatrix.multiply(this.mirrorCamera.matrixWorldInverse)
                }
            }, {
                key: "render",
                value: function(t, e, n) {
                    this.uniforms.time.value += n, this.updateTextureMatrix(), this.obj.visible = !1, t.render(e, this.mirrorCamera, this.mirrorRender), this.obj.visible = !0
                }
            }, {
                key: "resize",
                value: function() {
                    this.mirrorCamera.aspect = document.body.clientWidth / window.innerHeight, this.mirrorCamera.updateProjectionMatrix(), this.mirrorRender.setSize(document.body.clientWidth, window.innerHeight)
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform mat3 normalMatrix;\nuniform mat4 textureMatrix;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec4 vUv;\nvarying mat4 vInvertMatrix;\n\nfloat inverse_1_0(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse_1_0(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse_1_0(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse_1_0(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\n\n\nvoid main(void) {\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n  vPosition = worldPosition.xyz;\n  vNormal = normal;\n  vUv = textureMatrix * worldPosition;\n  vInvertMatrix = inverse_1_0(modelMatrix);\n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec4 vUv;\nvarying mat4 vInvertMatrix;\n\nvoid main() {\n  vec4 projectorColor;\n  if (all(bvec4(vUv.x >= 0.0, vUv.y >= 0.0, vUv.x <= vUv.z, vUv.y <= vUv.z))) {\n    projectorColor = texture2DProj(texture, vUv);\n  }\n  gl_FragColor = vec4(1.0, 1.0, 1.0, 0.35) * projectorColor;\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.cubeCamera = new i.CubeCamera(1, 15e3, 1024), this.instances = 6, this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj = this.createObj(), this.obj.rotation.set(0, .3 * Math.PI, 0)
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    var t = new i.InstancedBufferGeometry,
                        e = new i.BoxBufferGeometry(40, 1, 10);
                    t.copy(e);
                    for (var r = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), o = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), a = 0, s = this.instances; a < s; a++) r.setXYZ(a, 150 * (a + 1) + 200), o.setXYZ(a, 120 * (a - (this.instances - 1) / 2));
                    return t.addAttribute("height", r), t.addAttribute("offsetX", o), new i.Mesh(t, new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(511),
                        fragmentShader: n(512),
                        flatShading: !0
                    }))
                }
            }, {
                key: "render",
                value: function(t, e, n) {
                    this.uniforms.time.value += n, this.obj.visible = !1, this.cubeCamera.update(t, e), this.obj.visible = !0
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute float height;\nattribute float offsetX;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec3 vPosition;\nvarying mat4 vInvertMatrix;\n\nmat4 calcTranslateMat4_1_0(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\n\nmat4 calcScaleMat4_2_1(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nfloat inverse_3_2(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse_3_2(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse_3_2(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse_3_2(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\n\n\nvoid main(void) {\n  mat4 translateMat = calcTranslateMat4_1_0(vec3(offsetX, 0.0, 0.0));\n  mat4 scaleMat = calcScaleMat4_2_1(vec3(1.0, (position.y + 0.5) * height, 1.0));\n  vec4 updatePosition = scaleMat * translateMat * vec4(position, 1.0);\n  vPosition = (modelMatrix * updatePosition).xyz;\n  vInvertMatrix = inverse_3_2(modelMatrix);\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec3 cameraPosition;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying mat4 vInvertMatrix;\n\nvoid main() {\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  vec3 light = vec3(-0.7, 0.7, -0.7);\n  float diff = (dot(normal, light) + 1.0) / 2.0 * 0.2 + 0.8;\n  gl_FragColor = vec4(vec3(0.98) * diff, 1.0);\n}\n"
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(13).default,
        a = n(514).default,
        s = n(517).default;
    e.default = function() {
        var t = document.getElementById("canvas-webgl"),
            e = new r.WebGLRenderer({
                antialias: !1,
                canvas: t
            }),
            n = new r.WebGLRenderTarget(document.body.clientWidth, window.innerHeight),
            c = new r.Scene,
            u = new r.Scene,
            l = new r.OrthographicCamera(-1, 1, 1, -1, 0, 1),
            h = new r.PerspectiveCamera(45, document.body.clientWidth / window.innerHeight, 1, 1e4),
            f = new r.Clock,
            d = new r.Vector2,
            v = new r.Vector2,
            p = new r.Vector2,
            m = new a,
            g = new s(n.texture),
            y = function() {
                t.width = document.body.clientWidth, t.height = window.innerHeight, h.aspect = document.body.clientWidth / window.innerHeight, h.updateProjectionMatrix(), m.resize(), g.resize(), n.setSize(document.body.clientWidth, window.innerHeight), e.setSize(document.body.clientWidth, window.innerHeight)
            },
            x = function t() {
                ! function() {
                    var t = f.getDelta();
                    e.render(u, h, n), g.render(t), e.render(c, l)
                }(), requestAnimationFrame(t)
            },
            b = function(t) {
                !0
            },
            w = function(t) {
                !1
            };
        e.setSize(document.body.clientWidth, window.innerHeight), e.setClearColor(0, 1), h.position.set(1e3, 1e3, 1e3), h.lookAt(new r.Vector3), m.init(function() {
            u.add(m.obj), c.add(g.obj)
        }), window.addEventListener("resize", i(function() {
            y()
        }), 1e3), t.addEventListener("mousedown", function(t) {
            t.preventDefault(), d.set(t.clientX, t.clientY), o(d), b()
        }), document.addEventListener("mousemove", function(t) {
            t.preventDefault(), v.set(t.clientX, t.clientY), o(v)
        }), document.addEventListener("mouseup", function(t) {
            t.preventDefault(), p.set(t.clientX, t.clientY), o(p), w()
        }), t.addEventListener("touchstart", function(t) {
            t.preventDefault(), d.set(t.touches[0].clientX, t.touches[0].clientY), o(d), b(t.touches[0].clientX, t.touches[0].clientY)
        }), t.addEventListener("touchmove", function(t) {
            t.preventDefault(), v.set(t.touches[0].clientX, t.touches[0].clientY), o(v)
        }), t.addEventListener("touchend", function(t) {
            t.preventDefault(), p.set(t.changedTouches[0].clientX, t.changedTouches[0].clientY), o(p), w()
        }), y(), x()
    }
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    resolution: {
                        type: "v2",
                        value: new i.Vector2(document.body.clientWidth, window.innerHeight)
                    },
                    imageResolution: {
                        type: "v2",
                        value: new i.Vector2(2048, 1356)
                    },
                    texture: {
                        type: "t",
                        value: null
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "init",
                value: function(t) {
                    var e = this;
                    (new i.TextureLoader).load("/sketch-threejs/img/sketch/glitch/osaka.jpg", function(n) {
                        e.uniforms.texture.value = n, e.obj = e.createObj(), t()
                    })
                }
            }, {
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(515),
                        fragmentShader: n(516)
                    }))
                }
            }, {
                key: "resize",
                value: function() {
                    this.uniforms.resolution.value.set(document.body.clientWidth, window.innerHeight)
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform vec2 imageResolution;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvoid main(void) {\n  vec2 ratio = vec2(\n      min((resolution.x / resolution.y) / (imageResolution.x / imageResolution.y), 1.0),\n      min((resolution.y / resolution.x) / (imageResolution.y / imageResolution.x), 1.0)\n    );\n\n  vec2 uv = vec2(\n      vUv.x * ratio.x + (1.0 - ratio.x) * 0.5,\n      vUv.y * ratio.y + (1.0 - ratio.y) * 0.5\n    );\n  gl_FragColor = texture2D(texture, uv);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    resolution: {
                        type: "v2",
                        value: new i.Vector2(document.body.clientWidth, window.innerHeight)
                    },
                    texture: {
                        type: "t",
                        value: e
                    }
                }, this.obj = this.createObj()
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(518),
                        fragmentShader: n(519)
                    }))
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }, {
                key: "resize",
                value: function() {
                    this.uniforms.resolution.value.set(document.body.clientWidth, window.innerHeight)
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform vec2 resolution;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nfloat random_1_0(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_2_1(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_2_1(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_2_2(vec4 x) {\n     return mod289_2_1(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_2_3(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_2_4(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_2_5 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_2_6 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_2_6;\n  vec3 i1 = min( g_2_6.xyz, l.zxy );\n  vec3 i2 = max( g_2_6.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_2_5.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_2_1(i);\n  vec4 p = permute_2_2( permute_2_2( permute_2_2(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_2_5.wyz - D_2_5.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_2_7 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_2_8 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_2_7.xy,h.z);\n  vec3 p3 = vec3(a1_2_7.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_2_3(vec4(dot(p0_2_8,p0_2_8), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_2_8 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_2_8,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\n\nconst float interval = 3.0;\n\nvoid main(void){\n  float strength = smoothstep(interval * 0.5, interval, interval - mod(time, interval));\n  vec2 shake = vec2(strength * 8.0 + 0.5) * vec2(\n    random_1_0(vec2(time)) * 2.0 - 1.0,\n    random_1_0(vec2(time * 2.0)) * 2.0 - 1.0\n  ) / resolution;\n\n  float y = vUv.y * resolution.y;\n  float rgbWave = (\n      snoise_2_4(vec3(0.0, y * 0.01, time * 400.0)) * (2.0 + strength * 32.0)\n      * snoise_2_4(vec3(0.0, y * 0.02, time * 200.0)) * (1.0 + strength * 4.0)\n      + step(0.9995, sin(y * 0.005 + time * 1.6)) * 12.0\n      + step(0.9999, sin(y * 0.005 + time * 2.0)) * -18.0\n    ) / resolution.x;\n  float rgbDiff = (6.0 + sin(time * 500.0 + vUv.y * 40.0) * (20.0 * strength + 1.0)) / resolution.x;\n  float rgbUvX = vUv.x + rgbWave;\n  float r = texture2D(texture, vec2(rgbUvX + rgbDiff, vUv.y) + shake).r;\n  float g = texture2D(texture, vec2(rgbUvX, vUv.y) + shake).g;\n  float b = texture2D(texture, vec2(rgbUvX - rgbDiff, vUv.y) + shake).b;\n\n  float whiteNoise = (random_1_0(vUv + mod(time, 10.0)) * 2.0 - 1.0) * (0.15 + strength * 0.15);\n\n  float bnTime = floor(time * 20.0) * 200.0;\n  float noiseX = step((snoise_2_4(vec3(0.0, vUv.x * 3.0, bnTime)) + 1.0) / 2.0, 0.12 + strength * 0.3);\n  float noiseY = step((snoise_2_4(vec3(0.0, vUv.y * 3.0, bnTime)) + 1.0) / 2.0, 0.12 + strength * 0.3);\n  float bnMask = noiseX * noiseY;\n  float bnUvX = vUv.x + sin(bnTime) * 0.2 + rgbWave;\n  float bnR = texture2D(texture, vec2(bnUvX + rgbDiff, vUv.y)).r * bnMask;\n  float bnG = texture2D(texture, vec2(bnUvX, vUv.y)).g * bnMask;\n  float bnB = texture2D(texture, vec2(bnUvX - rgbDiff, vUv.y)).b * bnMask;\n  vec4 blockNoise = vec4(bnR, bnG, bnB, 1.0);\n\n  float bnTime2 = floor(time * 25.0) * 300.0;\n  float noiseX2 = step((snoise_2_4(vec3(0.0, vUv.x * 2.0, bnTime2)) + 1.0) / 2.0, 0.12 + strength * 0.5);\n  float noiseY2 = step((snoise_2_4(vec3(0.0, vUv.y * 8.0, bnTime2)) + 1.0) / 2.0, 0.12 + strength * 0.3);\n  float bnMask2 = noiseX2 * noiseY2;\n  float bnR2 = texture2D(texture, vec2(bnUvX + rgbDiff, vUv.y)).r * bnMask2;\n  float bnG2 = texture2D(texture, vec2(bnUvX, vUv.y)).g * bnMask2;\n  float bnB2 = texture2D(texture, vec2(bnUvX - rgbDiff, vUv.y)).b * bnMask2;\n  vec4 blockNoise2 = vec4(bnR2, bnG2, bnB2, 1.0);\n\n  float waveNoise = (sin(vUv.y * 1200.0) + 1.0) / 2.0 * (0.15 + strength * 0.2);\n\n  gl_FragColor = vec4(r, g, b, 1.0) * (1.0 - bnMask - bnMask2) + (whiteNoise + blockNoise + blockNoise2 - waveNoise);\n}\n"
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(13).default,
        a = n(97).default,
        s = n(521).default,
        c = n(522).default,
        u = n(525).default,
        l = n(528).default;
    e.default = function() {
        var t = document.getElementById("canvas-webgl"),
            e = new r.WebGLRenderer({
                antialias: !1,
                canvas: t,
                alpha: !0
            }),
            n = new r.WebGLRenderTarget(document.body.clientWidth, window.innerHeight),
            h = new r.Scene,
            f = new r.Scene,
            d = new r.OrthographicCamera(-1, 1, 1, -1, 0, 1),
            v = new a(45, document.body.clientWidth / window.innerHeight, 1, 1e5),
            p = new s(v),
            m = new r.Clock,
            g = new r.Vector2,
            y = new r.Vector2,
            x = new r.Vector2,
            b = !1,
            w = new r.CubeTextureLoader,
            _ = new c,
            M = new u,
            S = new l(n.texture),
            E = function() {
                t.width = document.body.clientWidth, t.height = window.innerHeight, v.aspect = document.body.clientWidth / window.innerHeight, v.updateProjectionMatrix(), S.resize(), e.setSize(document.body.clientWidth, window.innerHeight), n.setSize(document.body.clientWidth, window.innerHeight)
            },
            T = function t() {
                ! function() {
                    var t = m.getDelta();
                    p.render(), _.render(t), M.render(t), S.render(t), S.uniforms.strengthZoom.value = p.computeZoomLength(), S.uniforms.strengthGlitch.value = p.computeAcceleration(), e.render(f, v, n), e.render(h, d)
                }(), requestAnimationFrame(t)
            },
            P = function(t) {
                b = !0
            },
            L = function(t) {
                b && p.rotate(g.x - y.x, g.y - y.y)
            },
            A = function(t) {
                b = !1, p.touchEnd()
            },
            z = function() {
                window.addEventListener("resize", i(function() {
                    E()
                }), 1e3), t.addEventListener("mousedown", function(t) {
                    t.preventDefault(), g.set(t.clientX, t.clientY), o(g), P()
                }), document.addEventListener("mousemove", function(t) {
                    t.preventDefault(), y.set(t.clientX, t.clientY), o(y), L()
                }), document.addEventListener("mouseup", function(t) {
                    t.preventDefault(), x.set(t.clientX, t.clientY), o(x), A()
                }), t.addEventListener("wheel", function(t) {
                    t.preventDefault(),
                        function(t) {
                            p.zoom(t.deltaY)
                        }(t)
                }), t.addEventListener("touchstart", function(t) {
                    t.preventDefault(), g.set(t.touches[0].clientX, t.touches[0].clientY), o(g), P(t.touches[0].clientX, t.touches[0].clientY)
                }), t.addEventListener("touchmove", function(t) {
                    t.preventDefault(), y.set(t.touches[0].clientX, t.touches[0].clientY), o(y), L()
                }), t.addEventListener("touchend", function(t) {
                    t.preventDefault(), x.set(t.changedTouches[0].clientX, t.changedTouches[0].clientY), o(x), A()
                })
            };
        e.setSize(document.body.clientWidth, window.innerHeight), e.setClearColor(0, 1), w.setPath("../img/sketch/instancing/").load(["cubemap_px.png", "cubemap_nx.png", "cubemap_py.png", "cubemap_ny.png", "cubemap_pz.png", "cubemap_nz.png"], function(t) {
            _.init(t), M.init(t), h.add(S.obj), f.add(_.obj), f.add(M.obj)
        }), z(), E(), T()
    }
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    n(0);
    var i = n(68),
        o = n(2),
        a = function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.camera = e, this.radian1 = 0, this.radian1Base = 0, this.radian2 = 0, this.radian2Base = 0, this.radius = 2500, this.isZoom = !1
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "rotate",
                value: function(t, e) {
                    !0 === this.isZoom && (this.isZoom = !1), this.radian1 = o.clamp(this.radian1Base + e, o.radians(-75), o.radians(75)), this.radian2 = this.radian2Base - 2 * t
                }
            }, {
                key: "zoom",
                value: function(t) {
                    if (t) {
                        !1 === this.isZoom && (this.isZoom = !0);
                        var e = this.radius;
                        this.radius -= t / Math.abs(t) * 200, this.radius = o.clamp(this.radius, 700, 8e3);
                        this.radius
                    }
                }
            }, {
                key: "touchEnd",
                value: function() {
                    this.radian1Base = this.radian1, this.radian2Base = this.radian2
                }
            }, {
                key: "render",
                value: function() {
                    this.camera.anchor = o.spherical(this.radian1, this.radian2, this.radius), this.camera.render()
                }
            }, {
                key: "computeZoomLength",
                value: function() {
                    return this.isZoom ? .05 * i.vec3.length(this.camera.acceleration) : 0
                }
            }, {
                key: "computeAcceleration",
                value: function() {
                    return .05 * i.vec3.length(this.camera.acceleration)
                }
            }]), t
        }()
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(2),
        a = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    cubeTex: {
                        type: "t",
                        value: null
                    }
                }, this.instances = 1e3, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "init",
                value: function(t) {
                    this.uniforms.cubeTex.value = t, this.obj = this.createObj()
                }
            }, {
                key: "createObj",
                value: function() {
                    var t = new i.InstancedBufferGeometry,
                        e = new i.BoxBufferGeometry(10, 10, 10);
                    t.copy(e);
                    for (var r = new i.InstancedBufferAttribute(new Float32Array(3 * this.instances), 3), a = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), s = new i.InstancedBufferAttribute(new Float32Array(3 * this.instances), 3), c = 0, u = a.count; c < u; c++) {
                        var l = o.spherical(2 * Math.random() * Math.PI, 2 * Math.random() * Math.PI, 3e3 * Math.random() + 100);
                        r.setXYZ(c, l[0], l[1], l[2]), a.setXYZ(c, 100 * Math.random()), s.setXYZ(c, Math.random() - .5, Math.random() - .5, Math.random() - .5)
                    }
                    return t.addAttribute("translate", r), t.addAttribute("offset", a), t.addAttribute("rotate", s), new i.Mesh(t, new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(523),
                        fragmentShader: n(524),
                        transparent: !0,
                        side: i.DoubleSide
                    }))
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec3 translate;\nattribute float offset;\nattribute vec3 rotate;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nmat4 calcTranslateMat4_1_0(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4X_3_1(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Y_4_2(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 calcRotateMat4Z_5_3(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n\nmat4 calcRotateMat4_2_4(vec3 radian) {\n  return calcRotateMat4X_3_1(radian.x) * calcRotateMat4Y_4_2(radian.y) * calcRotateMat4Z_5_3(radian.z);\n}\n\n\n\nvoid main(void) {\n  float radian = radians(time);\n  mat4 rotateWorld = calcRotateMat4_2_4(vec3(radian) * vec3(5.0, 20.0, 1.0) + rotate);\n  mat4 rotateSelf = calcRotateMat4_2_4(vec3(radian) * rotate * 100.0);\n  vec4 updatePosition =\n    rotateWorld\n    * calcTranslateMat4_1_0(translate)\n    * rotateSelf\n    * vec4(position + normalize(position) * offset, 1.0);\n  vPosition = (modelMatrix * updatePosition).xyz;\n  vNormal = (modelMatrix * rotateWorld * rotateSelf * vec4(normal, 1.0)).xyz;\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec3 cameraPosition;\nuniform float time;\nuniform samplerCube cubeTex;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec3 ref = reflect(vPosition - cameraPosition, vNormal);\n  vec4 envColor = textureCube(cubeTex, ref);\n  gl_FragColor = envColor * vec4(0.8, 1.0, 0.95, 0.7);\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    cubeTex: {
                        type: "t",
                        value: null
                    }
                }, this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "init",
                value: function(t) {
                    this.uniforms.cubeTex.value = t, this.obj = this.createObj()
                }
            }, {
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.BoxBufferGeometry(3e4, 3e4, 3e4, 1, 1, 1), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(526),
                        fragmentShader: n(527),
                        side: i.BackSide
                    }))
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\n\nvoid main(void) {\n  vPosition = position;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform samplerCube cubeTex;\n\nvarying vec3 vPosition;\n\nvoid main() {\n  vec3 normal = normalize(vPosition);\n  vec4 color = textureCube(cubeTex, normal);\n  gl_FragColor = color;\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    resolution: {
                        type: "v2",
                        value: new i.Vector2(document.body.clientWidth, window.innerHeight)
                    },
                    texture: {
                        type: "t",
                        value: e
                    },
                    strengthZoom: {
                        type: "f",
                        value: 0
                    },
                    strengthGlitch: {
                        type: "f",
                        value: 0
                    }
                }, this.obj = this.createObj()
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(529),
                        fragmentShader: n(530)
                    }))
                }
            }, {
                key: "render",
                value: function(t) {
                    this.uniforms.time.value += t
                }
            }, {
                key: "resize",
                value: function() {
                    this.uniforms.resolution.value.set(document.body.clientWidth, window.innerHeight)
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform vec2 resolution;\nuniform sampler2D texture;\nuniform float strengthZoom;\nuniform float strengthGlitch;\n\nvarying vec2 vUv;\n\nfloat random_2_0(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1_1(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1_1(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1_2(vec4 x) {\n     return mod289_1_1(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_3(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_1_4(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_1_5 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_1_6 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_1_6;\n  vec3 i1 = min( g_1_6.xyz, l.zxy );\n  vec3 i2 = max( g_1_6.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_1_5.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_1_1(i);\n  vec4 p = permute_1_2( permute_1_2( permute_1_2(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_1_5.wyz - D_1_5.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_1_7 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_1_8 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_1_7.xy,h.z);\n  vec3 p3 = vec3(a1_1_7.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_1_3(vec4(dot(p0_1_8,p0_1_8), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_1_8 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_1_8,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\n\nvoid main(void){\n  // zoom blur\n  vec2 tFrag = 1.0 / resolution;\n  float nFrag = 1.0 / 30.0;\n  vec2 centerOffset = resolution / 2.0;\n  vec3 destColor = vec3(0.0);\n  vec2 fcc = gl_FragCoord.xy - centerOffset;\n  float totalWeight = 0.0;\n\n  for(float i = 0.0; i <= 30.0; i++){\n    float percent = (i + random_2_0(gl_FragCoord.xy)) * nFrag;\n    float weight = percent - percent * percent;\n    vec2  t = gl_FragCoord.xy - fcc * percent * strengthZoom * nFrag;\n    destColor += texture2D(texture, t * tFrag).rgb * weight;\n    totalWeight += weight;\n  }\n  vec4 zoomColor = vec4(destColor / totalWeight, 1.0);\n\n  // glitch\n  float strengthWhiteNoise = min(strengthGlitch * 0.05, 0.1);\n  float whiteNoise = (random_2_0(gl_FragCoord.xy + time) * 2.0 - 1.0) * (0.05 + strengthWhiteNoise);\n\n  float strengthBlockNoise = min(strengthGlitch * 0.15, 1.2);\n  float noiseX = step((snoise_1_4(vec3(0.0, gl_FragCoord.x / resolution.x * 1.0, time * 600.0)) + 1.0) / 2.0, strengthBlockNoise * 0.6);\n  float noiseY = step((snoise_1_4(vec3(0.0, gl_FragCoord.y / resolution.y * 3.0, time * 200.0)) + 1.0) / 2.0, strengthBlockNoise * 0.3);\n  float blockNoiseMask = noiseX * noiseY;\n  vec4 blockNoise = texture2D(texture, 1.0 - vUv) * blockNoiseMask;\n\n  gl_FragColor = zoomColor + whiteNoise + blockNoise;\n}\n"
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(13).default,
        a = n(532).default,
        s = n(534).default,
        c = n(536).default,
        u = n(538).default;
    e.default = function() {
        var t = document.getElementById("canvas-webgl"),
            e = new r.WebGLRenderer({
                antialias: !1,
                canvas: t
            }),
            n = new r.WebGLRenderTarget(document.body.clientWidth, window.innerHeight),
            l = new r.WebGLRenderTarget(document.body.clientWidth, window.innerHeight),
            h = new r.WebGLRenderTarget(document.body.clientWidth, window.innerHeight),
            f = new r.Scene,
            d = new r.Scene,
            v = new r.OrthographicCamera(-1, 1, 1, -1, 0, 1),
            p = new r.PerspectiveCamera(45, document.body.clientWidth / window.innerHeight, 1, 1e4),
            m = new r.Clock,
            g = new r.Vector2,
            y = new r.Vector2,
            x = new r.Vector2,
            b = !1,
            w = new u,
            _ = new a(n.texture),
            M = new s(l.texture, 1, 0),
            S = new s(h.texture, 0, 1),
            E = new c(n.texture, l.texture);
        w.init(e);
        var T = function() {
                t.width = document.body.clientWidth, t.height = window.innerHeight, p.aspect = document.body.clientWidth / window.innerHeight, p.updateProjectionMatrix(), M.resize(), S.resize(), n.setSize(document.body.clientWidth, window.innerHeight), l.setSize(document.body.clientWidth, window.innerHeight), h.setSize(document.body.clientWidth, window.innerHeight), e.setSize(document.body.clientWidth, window.innerHeight)
            },
            P = function t() {
                ! function() {
                    var t = m.getDelta();
                    w.render(e, t), e.render(d, p, n), f.add(_.obj), e.render(f, p, l), f.remove(_.obj), f.add(M.obj), e.render(f, p, h), f.remove(M.obj), f.add(S.obj), e.render(f, p, l), f.remove(S.obj), f.add(E.obj), e.render(f, v), f.remove(E.obj)
                }(), requestAnimationFrame(t)
            },
            L = function(t) {
                b = !0, w.touchStart(g)
            },
            A = function(t) {
                b && w.touchMove(y)
            },
            z = function(t) {
                b = !1, w.touchEnd()
            },
            C = function() {
                window.addEventListener("resize", i(function() {
                    T()
                }), 1e3), t.addEventListener("mousedown", function(t) {
                    t.preventDefault(), g.set(t.clientX, t.clientY), o(g), L()
                }), t.addEventListener("mousemove", function(t) {
                    t.preventDefault(), y.set(t.clientX, t.clientY), o(y), A()
                }), t.addEventListener("mouseup", function(t) {
                    t.preventDefault(), x.set(t.clientX, t.clientY), o(x), z()
                }), t.addEventListener("touchstart", function(t) {
                    t.preventDefault(), g.set(t.touches[0].clientX, t.touches[0].clientY), o(g), L(t.touches[0].clientX, t.touches[0].clientY)
                }), t.addEventListener("touchmove", function(t) {
                    t.preventDefault(), y.set(t.touches[0].clientX, t.touches[0].clientY), o(y), A()
                }), t.addEventListener("touchend", function(t) {
                    t.preventDefault(), o(x), x.set(t.changedTouches[0].clientX, t.changedTouches[0].clientY), z()
                }), window.addEventListener("mouseout", function() {
                    event.preventDefault(), x.set(0, 0), b = !1, w.touchEnd()
                })
            };
        e.setSize(document.body.clientWidth, window.innerHeight), e.setClearColor(0, 1), p.position.set(0, 0, 1e3), p.lookAt(new r.Vector3), d.add(w.obj), C(), T(), P()
    }
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t(e) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    minBright: {
                        type: "f",
                        value: .3
                    },
                    texture: {
                        type: "t",
                        value: e
                    }
                }, this.obj = this.createObj()
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(100),
                        fragmentShader: n(533)
                    }))
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float minBright;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 bright = max(vec4(0.0), (texture2D(texture, vUv) - minBright));\n  gl_FragColor = bright;\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t(e, n, r) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    resolution: {
                        type: "v2",
                        value: new i.Vector2(document.body.clientWidth, window.innerHeight)
                    },
                    direction: {
                        type: "v2",
                        value: new i.Vector2(n, r)
                    },
                    texture: {
                        type: "t",
                        value: e
                    }
                }, this.obj = this.createObj()
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(100),
                        fragmentShader: n(535)
                    }))
                }
            }, {
                key: "resize",
                value: function() {
                    this.uniforms.resolution.value.set(document.body.clientWidth, window.innerHeight)
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform vec2 direction;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvec4 gaussianBlur(sampler2D texture, vec2 uv, float radius, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 step = radius / resolution * direction;\n  color += texture2D(texture, uv - 4.0 * step) * 0.02699548325659403;\n  color += texture2D(texture, uv - 3.0 * step) * 0.06475879783294587;\n  color += texture2D(texture, uv - 2.0 * step) * 0.12098536225957168;\n  color += texture2D(texture, uv - 1.0 * step) * 0.17603266338214976;\n  color += texture2D(texture, uv) * 0.19947114020071635;\n  color += texture2D(texture, uv + 1.0 * step) * 0.17603266338214976;\n  color += texture2D(texture, uv + 2.0 * step) * 0.12098536225957168;\n  color += texture2D(texture, uv + 3.0 * step) * 0.06475879783294587;\n  color += texture2D(texture, uv + 4.0 * step) * 0.02699548325659403;\n  return color;\n}\n\nvoid main() {\n  vec4 color = gaussianBlur(texture, vUv, 1.0, resolution, direction);\n  gl_FragColor = color;\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return o
    });
    var i = n(0),
        o = function() {
            function t(e, n) {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    texture1: {
                        type: "t",
                        value: e
                    },
                    texture2: {
                        type: "t",
                        value: n
                    }
                }, this.obj = this.createObj()
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(100),
                        fragmentShader: n(537)
                    }))
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D texture1;\nuniform sampler2D texture2;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 color1 = texture2D(texture1, vUv);\n  vec4 color2 = texture2D(texture2, vUv);\n  gl_FragColor = color1 * 0.6 + color2;\n}\n"
}, function(t, e, n) {
    "use strict";

    function r(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
        }
    }
    n.r(e), n.d(e, "default", function() {
        return a
    });
    var i = n(0),
        o = n(137).default,
        a = function() {
            function t() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    velocity: {
                        type: "t",
                        value: null
                    },
                    acceleration: {
                        type: "t",
                        value: null
                    }
                }, this.physicsRenderer = null, this.vectorTouchMove = new i.Vector2(0, 0), this.vectorTouchMoveDiff = new i.Vector2(0, 0), this.obj
            }
            return function(t, e, n) {
                e && r(t.prototype, e), n && r(t, n)
            }(t, [{
                key: "init",
                value: function(t) {
                    this.obj = this.createObj(t)
                }
            }, {
                key: "createObj",
                value: function(t) {
                    for (var e = window.innerWidth > 768 ? 8 : 6, r = new i.OctahedronBufferGeometry(100, e), a = r.attributes.position.array, s = [], c = 0; c < a.length; c += 3) s[c + 0] = a[c + 0] + 10 * (2 * Math.random() - 1), s[c + 1] = a[c + 1] + 10 * (2 * Math.random() - 1), s[c + 2] = a[c + 2] + 10 * (2 * Math.random() - 1);
                    return this.physicsRenderer = new o(n(541), n(542), n(543), n(544)), this.physicsRenderer.init(t, s), this.physicsRenderer.mergeAUniforms({
                        vTouchMove: {
                            type: "v2",
                            value: this.vectorTouchMoveDiff
                        }
                    }), this.uniforms.velocity.value = this.physicsRenderer.getCurrentVelocity(), this.uniforms.acceleration.value = this.physicsRenderer.getCurrentAcceleration(), r.addAttribute("uvVelocity", this.physicsRenderer.getBufferAttributeUv()), new i.Points(r, new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(545),
                        fragmentShader: n(546),
                        transparent: !0,
                        depthWrite: !1,
                        blending: i.AdditiveBlending
                    }))
                }
            }, {
                key: "render",
                value: function(t, e) {
                    this.physicsRenderer.render(t, e), this.uniforms.time.value += e
                }
            }, {
                key: "touchStart",
                value: function(t) {
                    this.vectorTouchMove.copy(t)
                }
            }, {
                key: "touchMove",
                value: function(t) {
                    this.vectorTouchMoveDiff.set(t.x - this.vectorTouchMove.x, t.y - this.vectorTouchMove.y), this.vectorTouchMove.copy(t)
                }
            }, {
                key: "touchEnd",
                value: function() {
                    this.vectorTouchMove.set(0, 0), this.vectorTouchMoveDiff.set(0, 0)
                }
            }, {
                key: "resize",
                value: function() {
                    this.physicsRenderer && this.physicsRenderer.resize()
                }
            }]), t
        }()
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nuniform sampler2D velocity;\n\nvarying vec2 vUv;\n\nvoid main(void) {\n  gl_FragColor = texture2D(velocity, vUv);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(t, e) {
    t.exports = '#define GLSLIFY 1\nuniform vec2 resolution;\nuniform sampler2D velocity;\nuniform sampler2D acceleration;\nuniform float time;\nuniform vec2 vTouchMove;\n\nvarying vec2 vUv;\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1_0(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1_0(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1_1(vec4 x)\n{\n  return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_1_3(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_1_4(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_1_0(Pi0);\n  Pi1 = mod289_1_0(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_1_1(permute_1_1(ix) + iy);\n  vec4 ixy0 = permute_1_1(ixy + iz0);\n  vec4 ixy1 = permute_1_1(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_1_2(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_1_2(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_1_3(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\n\n#ifndef PRECISION\n#define PRECISION 0.000001\n#endif\n\nvec3 drag_2_5(vec3 a, float value) {\n  return normalize(a * -1.0 + PRECISION) * length(a) * value;\n}\n\n\n\n\nvoid main(void) {\n  vec3 v = texture2D(velocity, vUv).xyz;\n  vec3 a = texture2D(acceleration, vUv).xyz;\n  float noise = sqrt(length(v)) * 10.0;\n  vec3 d = drag_2_5(a, 0.028);\n  float fx = cnoise_1_4(vec3(time * 0.1, v.y / noise, v.z / noise));\n  float fy = cnoise_1_4(vec3(v.x / noise, time * 0.1, v.z / noise));\n  float fz = cnoise_1_4(vec3(v.x / noise, v.y / noise, time * 0.1));\n  vec3 f1 = vec3(fx, fy, fz) * 0.24;\n  vec3 f2 = vec3(vTouchMove * 16.0 * (resolution / 640.0), 0.0);\n  vec3 f3 = a + f1 + f2 + d;\n  float vStep = 1.0 - step(1000.0, length(v + f3));\n  gl_FragColor = vec4(f3 * vStep, 1.0);\n}\n'
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nuniform sampler2D velocity;\nuniform sampler2D acceleration;\nuniform float time;\n\nvarying vec2 vUv;\n\nvec3 spherical_1_0(float radian1, float radian2, float radius) {\n  return vec3(\n    cos(radian1) * cos(radian2) * radius,\n    sin(radian1) * radius,\n    cos(radian1) * sin(radian2) * radius\n  );\n}\n\n\n\nconst float radius = 100.0;\n\nvoid main(void) {\n  vec3 a = texture2D(acceleration, vUv).xyz;\n  vec3 v = texture2D(velocity, vUv).xyz;\n  float vStep = step(0.000001, length(a));\n  gl_FragColor = vec4(\n    (a + v) * vStep + normalize(v + spherical_1_0(time, -time, 1.0)) * radius * (1.0 - vStep),\n    1.0\n  );\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uvVelocity;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\nuniform sampler2D acceleration;\nuniform sampler2D velocity;\n\nvarying vec3 vAcceleration;\n\nvoid main() {\n  vec3 a = texture2D(acceleration, uvVelocity).xyz;\n  vec3 v = texture2D(velocity, uvVelocity).xyz;\n  vec4 mvPosition = modelViewMatrix * vec4(v, 1.0);\n  vAcceleration = a;\n  gl_PointSize = 500.0 / length(mvPosition.xyz);\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vAcceleration;\n\nvec3 convertHsvToRgb_1_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main() {\n  float start = smoothstep(time, 0.0, 1.0);\n  vec3 n;\n  n.xy = gl_PointCoord * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n  float aLength = length(vAcceleration);\n  vec3 color = convertHsvToRgb_1_0(vec3(aLength * 0.08 + time * 0.05, 0.5, 0.8));\n  gl_FragColor = vec4(color, 0.15 * start);\n}\n"
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(13).default,
        a = n(137).default;
    e.default = function() {
        var t = n(14),
            e = n(31),
            s = document.getElementById("canvas-webgl"),
            c = new r.WebGLRenderer({
                antialias: !0,
                canvas: s
            }),
            u = new r.Scene,
            l = new e(35, window.innerWidth / window.innerHeight, 1, 1e4),
            h = (new r.Clock, null),
            f = function() {
                for (var e = new r.BufferGeometry, i = [], o = [], a = [], s = [], c = 0; c < Math.pow(1e3, 2); c++) i.push(0, 0, 0), o.push(c % 1e3 * (1 / 999), Math.floor(c / 1e3) * (1 / 999)), a.push(t.getRandomInt(0, 120) / 360, .8, 1), s.push(t.getRandomInt(1, 100));
                var u = new Float32Array(i);
                e.addAttribute("position", new r.BufferAttribute(u, 3));
                var l = new Float32Array(o);
                e.addAttribute("uv2", new r.BufferAttribute(l, 2));
                var h = new Float32Array(a);
                e.addAttribute("color", new r.BufferAttribute(h, 3));
                var f = new Float32Array(s);
                e.addAttribute("mass", new r.BufferAttribute(f, 1));
                var d = new r.ShaderMaterial({
                    uniforms: {
                        time: {
                            type: "f",
                            value: 0
                        },
                        velocity: {
                            type: "t",
                            value: new r.Texture
                        },
                        acceleration: {
                            type: "t",
                            value: new r.Texture
                        }
                    },
                    vertexShader: n(548),
                    fragmentShader: n(549),
                    transparent: !0,
                    depthWrite: !1,
                    blending: r.AdditiveBlending
                });
                return new r.Points(e, d)
            }(),
            d = function() {
                (h = new a(n(550), n(551), n(552), n(553))).init(c, function() {
                    for (var e = [], n = 0; n < Math.pow(1e3, 2); n++) {
                        var r = t.getPolarCoord(t.getRadian(t.getRandomInt(0, 360)), t.getRadian(t.getRandomInt(0, 360)), t.getRandomInt(10, 1e3));
                        e.push(r.x, r.y / 10, r.z)
                    }
                    return e
                }()), h.accelerationMesh.material.uniforms.anchor = {
                    type: "v2",
                    value: new r.Vector2
                }, u.add(f), l.force.position.anchor.set(0, 15, 600), l.force.look.anchor.set(0, 0, 0)
            },
            v = function() {
                s.width = window.innerWidth, s.height = window.innerHeight, l.aspect = window.innerWidth / window.innerHeight, l.updateProjectionMatrix(), c.setSize(window.innerWidth, window.innerHeight)
            },
            p = function t() {
                h.render(c), f.material.uniforms.time.value++, f.material.uniforms.velocity.value = h.getCurrentVelocity(), f.material.uniforms.acceleration.value = h.getCurrentAcceleration(), l.force.position.applyHook(0, .025), l.force.position.applyDrag(.2), l.force.position.updateVelocity(), l.updatePosition(), l.force.look.applyHook(0, .2), l.force.look.applyDrag(.4), l.force.look.updateVelocity(), l.updateLook(), c.render(u, l), requestAnimationFrame(t)
            },
            m = function() {
                var t = new r.Vector2,
                    e = new r.Vector2,
                    n = new r.Vector2,
                    a = function(e, n, r) {
                        t.set(e, n), o(t)
                    },
                    c = function(t, n, r) {
                        e.set(t, n), o(e), h.accelerationMesh.material.uniforms.anchor.value.copy(e)
                    },
                    u = function(t, e, r) {
                        n.set(t, e)
                    };
                window.addEventListener("resize", i(function() {
                    v()
                }), 1e3), s.addEventListener("mousedown", function(t) {
                    t.preventDefault(), a(t.clientX, t.clientY)
                }), s.addEventListener("mousemove", function(t) {
                    t.preventDefault(), c(t.clientX, t.clientY)
                }), s.addEventListener("mouseup", function(t) {
                    t.preventDefault(), u(t.clientX, t.clientY)
                }), s.addEventListener("touchstart", function(t) {
                    t.preventDefault(), a(t.touches[0].clientX, t.touches[0].clientY)
                }), s.addEventListener("touchmove", function(t) {
                    t.preventDefault(), c(t.touches[0].clientX, t.touches[0].clientY)
                }), s.addEventListener("touchend", function(t) {
                    t.preventDefault(), u(t.changedTouches[0].clientX, t.changedTouches[0].clientY)
                }), window.addEventListener("mouseout", function() {
                    event.preventDefault(), n.set(0, 0), h.accelerationMesh.material.uniforms.anchor.value.set(0, 0, 0)
                })
            };
        c.setSize(window.innerWidth, window.innerHeight), c.setClearColor(0, 1), l.position.set(1e3, 1e3, 1e3), l.lookAt(new r.Vector3), m(), d(), v(), p()
    }
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec2 uv2;\nattribute vec3 color;\nattribute float mass;\n\nuniform sampler2D velocity;\nuniform sampler2D acceleration;\n\nvarying float vAcceleration;\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main(void) {\n  vec4 update_position = modelViewMatrix * texture2D(velocity, uv2);\n  vAcceleration = length(texture2D(acceleration, uv2).xyz) * mass;\n  vColor = color;\n  vOpacity = 0.6 * (300.0 / length(update_position.xyz));\n  gl_PointSize = 2.0 * (300.0 / length(update_position.xyz));\n  gl_Position = projectionMatrix * update_position;\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nvarying float vAcceleration;\nvarying vec3 vColor;\nvarying float vOpacity;\n\nuniform float time;\n\nvec3 hsv2rgb_1_0(vec3 c){\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main(void) {\n  vec3 n;\n  n.xy = gl_PointCoord * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n  gl_FragColor = vec4(hsv2rgb_1_0(vec3(vColor.x + time / 3600.0, vColor.y, vColor.z)), vOpacity);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nuniform vec2 resolution;\nuniform sampler2D velocity;\nuniform sampler2D acceleration;\nuniform vec2 anchor;\n\nvarying vec2 vUv;\n\n#define PRECISION 0.000001\n\n#ifndef PRECISION\n#define PRECISION 0.000001\n#endif\n\nvec3 drag_1_0(vec3 a, float value) {\n  return normalize(a * -1.0 + PRECISION) * length(a) * value;\n}\n\n\n\n\nvoid main(void) {\n  vec3 v = texture2D(velocity, vUv).xyz;\n  vec3 a = texture2D(acceleration, vUv).xyz;\n  vec3 a2 = a + normalize(vec3(\n    anchor.x * resolution.x / 6.0 + PRECISION,\n    0.0,\n    anchor.y * resolution.y / -2.0 + PRECISION\n  ) - v) / 2.0;\n  vec3 a3 = a2 + drag_1_0(a2, 0.003);\n  gl_FragColor = vec4(a3, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nuniform float time;\nuniform sampler2D velocity;\nuniform sampler2D acceleration;\n\nvarying vec2 vUv;\n\nvoid main(void) {\n  gl_FragColor = vec4(texture2D(acceleration, vUv).xyz + texture2D(velocity, vUv).xyz, 1.0);\n}\n"
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(13).default;
    e.default = function() {
        var t = n(14),
            e = n(101),
            a = n(31),
            s = document.getElementById("canvas-webgl"),
            c = new r.WebGLRenderer({
                antialias: !0,
                canvas: s
            }),
            u = new r.Scene,
            l = new a(35, window.innerWidth / window.innerHeight, 1, 1e4),
            h = (new r.Clock, null),
            f = null,
            d = null,
            v = null,
            p = new r.DirectionalLight(16777215, 1),
            m = new r.Scene,
            g = new a(45, 1, 1, 1e4),
            y = new r.WebGLRenderTarget(1200, 1200),
            x = null,
            b = new r.Scene,
            w = new a(45, 1, 1, 1e4),
            _ = new r.HemisphereLight(268435455, 13421772, 1),
            M = new r.WebGLRenderTarget(1200, 1200),
            S = null,
            E = null,
            T = new e,
            P = function() {
                T.anchor.set(1, 0), w.force.position.anchor.set(1e3, 300, 0), w.force.look.anchor.set(0, 0, 0), S = function() {
                    var t = new r.SphereGeometry(1e3, 128, 128),
                        e = new r.BufferGeometry;
                    e.fromGeometry(t);
                    var i = new r.ShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            }
                        },
                        vertexShader: n(563),
                        fragmentShader: n(564),
                        side: r.BackSide
                    });
                    return new r.Mesh(e, i)
                }(), E = function() {
                    for (var e = new r.BufferGeometry, i = [], o = 0; o < 2e3; o++) i.push(t.getRadian(t.getRandomInt(0, 120) + 120), t.getRadian(t.getRandomInt(0, 3600) / 10), t.getRandomInt(200, 1e3));
                    var a = new Float32Array(i);
                    e.addAttribute("position", new r.BufferAttribute(a, 3));
                    var s = new r.ShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            }
                        },
                        vertexShader: n(561),
                        fragmentShader: n(562)
                    });
                    return new r.Points(e, s)
                }(), b.add(S), b.add(E), b.add(_), h = function() {
                    for (var e = new r.BufferGeometry, i = [], o = [], a = 0; a < 32; a++) {
                        i.push(0, 0, 0);
                        var s = t.getRadian(t.getRandomInt(0, 360)),
                            c = t.getRadian(t.getRandomInt(0, 360)),
                            u = t.getRadian(t.getRandomInt(0, 360));
                        o.push(s, c, u)
                    }
                    var l = new Float32Array(i);
                    e.addAttribute("position", new r.BufferAttribute(l, 3));
                    var h = new Float32Array(o);
                    e.addAttribute("radian", new r.BufferAttribute(h, 3));
                    var f = new r.ShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            },
                            resolution: {
                                type: "v2",
                                value: new r.Vector2(window.innerWidth, window.innerHeight)
                            },
                            size: {
                                type: "f",
                                value: 28
                            },
                            force: {
                                type: "v2",
                                value: T.velocity
                            }
                        },
                        vertexShader: n(555),
                        fragmentShader: n(556),
                        transparent: !0,
                        depthWrite: !1,
                        blending: r.AdditiveBlending
                    });
                    return new r.Points(e, f)
                }(), m.add(h), g.position.set(0, 0, 3e3), g.force.look.anchor.set(0, 0, 0), x = function() {
                    var t = new r.PlaneGeometry(1e3, 1e3),
                        e = new r.BufferGeometry;
                    e.fromGeometry(t);
                    var i = new r.ShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            },
                            resolution: {
                                type: "v2",
                                value: new r.Vector2(window.innerWidth, window.innerHeight)
                            },
                            texture: {
                                type: "t",
                                value: y.texture
                            },
                            texture2: {
                                type: "t",
                                value: M.texture
                            }
                        },
                        vertexShader: n(565),
                        fragmentShader: n(566),
                        transparent: !0
                    });
                    return new r.Mesh(e, i)
                }(), u.add(x), f = function() {
                    var t = new r.SphereGeometry(1200, 64, 64),
                        e = new r.ShaderMaterial({
                            uniforms: {
                                time: {
                                    type: "f",
                                    value: 0
                                }
                            },
                            vertexShader: n(559),
                            fragmentShader: n(560),
                            side: r.BackSide
                        });
                    return new r.Mesh(t, e)
                }(), u.add(f), d = function() {
                    var t = new r.SphereGeometry(1100, 64, 64),
                        e = new r.MeshBasicMaterial({
                            color: 14540253,
                            wireframe: !0
                        });
                    return new r.Mesh(t, e)
                }(), u.add(d), v = function() {
                    for (var e = new r.SphereBufferGeometry(2, 4, 4), i = e.attributes, o = new r.BufferGeometry, a = [], s = [], c = [], u = [], l = [], h = function(n) {
                            for (g = t.getRandomInt(300, 1e3), d = t.getRadian(t.getRandomInt(0, 3600) / 10), v = t.getRandomInt(60, 120) / 100, p = 0; p < i.position.array.length; p += 3) a.push(i.position.array[p + 0], i.position.array[p + 1], i.position.array[p + 2]), s.push(g), c.push(d), u.push(v);
                            e.index.array.map(function(t) {
                                l.push(t + n * i.position.array.length / 3)
                            })
                        }, f = 0; f < 16; f++) {
                        var d, v, p;
                        h(f)
                    }
                    var m = new Float32Array(a);
                    o.addAttribute("position", new r.BufferAttribute(m, 3));
                    var g = new Float32Array(s);
                    o.addAttribute("radius", new r.BufferAttribute(g, 1));
                    var y = new Float32Array(c);
                    o.addAttribute("radian", new r.BufferAttribute(y, 1));
                    var x = new Float32Array(u);
                    o.addAttribute("scale", new r.BufferAttribute(x, 1));
                    var b = new Uint32Array(l);
                    o.setIndex(new r.BufferAttribute(b, 1));
                    var w = new r.ShaderMaterial({
                        uniforms: r.UniformsUtils.merge([r.UniformsLib.lights, {
                            time: {
                                type: "f",
                                value: 0
                            }
                        }]),
                        vertexShader: n(557),
                        fragmentShader: n(558),
                        flatShading: !0,
                        lights: !0
                    });
                    return new r.Mesh(o, w)
                }(), u.add(v), p.position.set(0, 1, 0), u.add(p), l.force.position.anchor.set(1e3, 300, 0), l.force.look.anchor.set(0, 0, 0)
            },
            L = function() {
                s.width = window.innerWidth, s.height = window.innerHeight, l.aspect = window.innerWidth / window.innerHeight, l.updateProjectionMatrix(), c.setSize(window.innerWidth, window.innerHeight), h.material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight), x.material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight)
            },
            A = function t() {
                h.material.uniforms.time.value++, x.lookAt(l.position), x.material.uniforms.time.value++, S.material.uniforms.time.value++, E.material.uniforms.time.value++, d.rotation.y = h.material.uniforms.time.value / 1e3, v.material.uniforms.time.value++, T.applyHook(0, .12), T.applyDrag(.18), T.updateVelocity(), l.force.position.applyHook(0, .025), l.force.position.applyDrag(.2), l.force.position.updateVelocity(), l.updatePosition(), l.force.look.anchor.y = 100 * Math.sin(h.material.uniforms.time.value / 100), l.force.look.applyHook(0, .2), l.force.look.applyDrag(.4), l.updateLook(), w.force.position.applyHook(0, .1), w.force.position.applyDrag(.2), w.force.position.updateVelocity(), w.updatePosition(), w.force.look.applyHook(0, .2), w.force.look.applyDrag(.4), w.force.look.updateVelocity(), w.updateLook(), c.render(b, w, M), c.render(m, g, y), c.render(u, l), requestAnimationFrame(t)
            },
            z = function() {
                var t = new r.Vector2,
                    e = new r.Vector2,
                    n = new r.Vector2,
                    a = function(e, n, r) {
                        t.set(e, n), o(t), T.anchor.set(2, 30)
                    },
                    c = function(t, n, r) {
                        e.set(t, n), o(e)
                    },
                    u = function(t, e, r) {
                        n.set(t, e), T.anchor.set(1, 0)
                    };
                window.addEventListener("resize", i(function() {
                    L()
                }), 1e3), s.addEventListener("mousedown", function(t) {
                    t.preventDefault(), a(t.clientX, t.clientY)
                }), s.addEventListener("mousemove", function(t) {
                    t.preventDefault(), c(t.clientX, t.clientY)
                }), s.addEventListener("mouseup", function(t) {
                    t.preventDefault(), u(t.clientX, t.clientY)
                }), s.addEventListener("touchstart", function(t) {
                    t.preventDefault(), a(t.touches[0].clientX, t.touches[0].clientY)
                }), s.addEventListener("touchmove", function(t) {
                    t.preventDefault(), c(t.touches[0].clientX, t.touches[0].clientY)
                }), s.addEventListener("touchend", function(t) {
                    t.preventDefault(), u(t.changedTouches[0].clientX, t.changedTouches[0].clientY)
                }), window.addEventListener("mouseout", function() {
                    event.preventDefault(), n.set(0, 0), T.anchor.set(1, 0)
                })
            };
        c.setSize(window.innerWidth, window.innerHeight), c.setClearColor(0, 1), l.position.set(1e3, 1e3, 1e3), l.lookAt(new r.Vector3), z(), P(), L(), A()
    }
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute vec3 radian;\n\nuniform float time;\nuniform vec2 resolution;\nuniform float size;\nuniform vec2 force;\n\nvoid main() {\n  float radius = 300.0;\n  float radian_base = radians(time * 2.0);\n  vec3 update_positon = position + vec3(\n    cos(radian_base + radian.x) * cos(radian_base + radian.y) * radius,\n    cos(radian_base + radian.x) * sin(radian_base + radian.y) * radius,\n    sin(radian_base + radian.x) * radius\n  ) * force.x;\n  vec4 mvPosition = modelViewMatrix * vec4(update_positon, 1.0);\n\n  gl_PointSize = (size + force.y) * (abs(sin(radian_base + radian.z))) * (size / length(mvPosition.xyz)) * 480.0;\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nuniform float size;\n\nvoid main() {\n  vec3 n;\n  n.xy = gl_PointCoord.xy * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n  gl_FragColor = vec4(1.0);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nattribute float radius;\nattribute float radian;\nattribute float scale;\n\nuniform float time;\n\nvarying vec3 vPosition;\nvarying mat4 vInvertMatrix;\n\nfloat inverse_8_0(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse_8_0(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse_8_0(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse_8_0(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_7_1(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_7_1(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_7_2(vec4 x) {\n     return mod289_7_1(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_7_3(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_7_4(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_7_5 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_7_6 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_7_6;\n  vec3 i1 = min( g_7_6.xyz, l.zxy );\n  vec3 i2 = max( g_7_6.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_7_5.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_7_1(i);\n  vec4 p = permute_7_2( permute_7_2( permute_7_2(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_7_5.wyz - D_7_5.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_7_7 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_7_8 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_7_7.xy,h.z);\n  vec3 p3 = vec3(a1_7_7.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_7_3(vec4(dot(p0_7_8,p0_7_8), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_7_8 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_7_8,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\nmat4 translateMatrix_1_9(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\n\nmat4 rotationMatrixX_5_10(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 rotationMatrixY_4_11(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\nmat4 rotationMatrixZ_6_12(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n\nmat4 rotationMatrix_2_13(float radian_x, float radian_y, float radian_z) {\n  return rotationMatrixX_5_10(radian_x) * rotationMatrixY_4_11(radian_y) * rotationMatrixZ_6_12(radian_z);\n}\n\n\nmat4 scaleMatrix_3_14(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n\n\nvec4 move(vec3 position) {\n  return translateMatrix_1_9(\n    vec3(\n      cos(radians(time * 0.5) + radian) * radius,\n      sin(radians(time * 0.5) + radian * 10.0) * radius * 0.3,\n      sin(radians(time * 0.5) + radian) * radius\n    )\n  ) * rotationMatrix_2_13(\n    radians(time * radian) + radian, radians(time) + radian, radians(time) + radian\n  ) * scaleMatrix_3_14(\n    vec3(20.0 * scale) + vec3(10.0) * snoise_7_4((position + sin(radian)))\n  ) * vec4(position, 1.0);\n}\n\nvoid main() {\n  vec4 update_position = move(position);\n  vPosition = position;\n  vInvertMatrix = inverse_8_0(rotationMatrix_2_13(\n    radians(time * radian) + radian, radians(time) + radian, radians(time) + radian\n  ));\n  gl_Position = projectionMatrix * modelViewMatrix * update_position;\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\nuniform DirectionalLight directionalLights[1];\n\nvarying vec3 vPosition;\nvarying mat4 vInvertMatrix;\n\nvoid main() {\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  vec3 inv_light = normalize(vInvertMatrix * vec4(directionalLights[0].direction, 1.0)).xyz;\n  float diff = (dot(normal, inv_light) + 1.0) / 2.0 * 0.25 + 0.75;\n  gl_FragColor = vec4(vec3(1.0) * diff, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nuniform float time;\n\nvarying vec3 vColor;\n\nvoid main() {\n  vColor = vec3((position.y / 1000.0 + 1.0) * 0.12 + 0.88);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nuniform float time;\n\nvec3 getPolarCoord(float rad1, float rad2, float r) {\n  return vec3(\n    cos(rad1) * cos(rad2) * r,\n    sin(rad1) * r,\n    cos(rad1) * sin(rad2) * r\n  );\n}\n\nvoid main() {\n  vec3 update_position = getPolarCoord(\n    position.x,\n    position.y + radians(time / 2.0),\n    position.z + sin(radians(time * 2.0) + position.x + position.y) * position.z / 4.0\n  );\n  vec4 mv_position = modelViewMatrix * vec4(update_position, 1.0);\n\n  gl_PointSize = 2.0 * (1000.0 / length(mv_position.xyz));\n  gl_Position = projectionMatrix * mv_position;\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nvoid main() {\n  vec3 n;\n  n.xy = gl_PointCoord.xy * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n  gl_FragColor = vec4(1.0);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nuniform float time;\n\nvarying vec3 vColor;\n\nvec3 hsv2rgb_1_0(vec3 c){\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_2_1(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_2_1(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_2_2(vec4 x) {\n     return mod289_2_1(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_2_3(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_2_4(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_2_5 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_2_6 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_2_6;\n  vec3 i1 = min( g_2_6.xyz, l.zxy );\n  vec3 i2 = max( g_2_6.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_2_5.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_2_1(i);\n  vec4 p = permute_2_2( permute_2_2( permute_2_2(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_2_5.wyz - D_2_5.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_2_7 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_2_8 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_2_7.xy,h.z);\n  vec3 p3 = vec3(a1_2_7.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_2_3(vec4(dot(p0_2_8,p0_2_8), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_2_8 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_2_8,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\n\nvoid main() {\n  float noise = snoise_2_4(\n    vec3(position.x + time * 10.0, position.y + cos(time / 20.0) * 100.0, position.z + time * 10.0) / 800.0\n  );\n  vColor = hsv2rgb_1_0(vec3(noise * 0.2 + 0.75, 0.4, noise * 0.3 + 0.5));\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nuniform float time;\nuniform vec2 resolution;\nuniform sampler2D texture;\nuniform sampler2D texture2;\n\nconst float blur = 20.0;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 color = vec4(0.0);\n  for (float x = 0.0; x < blur; x++){\n    for (float y = 0.0; y < blur; y++){\n      color += texture2D(texture, vUv - (vec2(x, y) - vec2(blur / 2.0)) / resolution);\n    }\n  }\n  vec4 color2 = color / pow(blur, 2.0);\n  vec4 color3 = texture2D(texture2, vUv);\n  gl_FragColor = vec4(color3.rgb, floor(length(color2.rgb)));\n}\n"
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(13).default;
    e.default = function() {
        var t = n(14),
            e = n(42),
            a = n(31),
            s = document.getElementById("canvas-webgl"),
            c = new r.WebGLRenderer({
                antialias: !0,
                canvas: s
            }),
            u = new r.Scene,
            l = new a(35, window.innerWidth / window.innerHeight, 1, 1e4),
            h = (new r.Clock, new r.Raycaster),
            f = null,
            d = new e,
            v = new e,
            p = null;
        d.mass = 1.4;
        var m = function() {
                var t = new r.PlaneBufferGeometry(6, 6),
                    e = new r.ShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            },
                            time2: {
                                type: "f",
                                value: 0
                            },
                            acceleration: {
                                type: "f",
                                value: 0
                            },
                            resolution: {
                                type: "v2",
                                value: new r.Vector2(window.innerWidth, window.innerHeight)
                            }
                        },
                        vertexShader: n(568),
                        fragmentShader: n(569),
                        transparent: !0
                    }),
                    i = new r.Mesh(t, e);
                return i.name = "MetalCube", i
            }(),
            g = function() {
                var t = new r.OctahedronGeometry(30, 4),
                    e = new r.BufferGeometry;
                e.fromGeometry(t);
                var i = new r.ShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            },
                            acceleration: {
                                type: "f",
                                value: 0
                            }
                        },
                        vertexShader: n(570),
                        fragmentShader: n(571),
                        flatShading: !0,
                        side: r.BackSide
                    }),
                    o = new r.Mesh(e, i);
                return o.name = "Background", o
            }(),
            y = function() {
                s.width = window.innerWidth, s.height = window.innerHeight, l.aspect = window.innerWidth / window.innerHeight, l.updateProjectionMatrix(), c.setSize(window.innerWidth, window.innerHeight), m.material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight)
            },
            x = function() {
                ! function(e, n, i) {
                    d.acceleration.length() > .1 || !i || (h.setFromCamera(i, n), (f = h.intersectObjects(e.children)[0]) && "MetalCube" == f.object.name && (d.anchor.copy(t.getPolarCoord(t.getRadian(t.getRandomInt(-20, 20)), t.getRadian(t.getRandomInt(0, 360)), t.getRandomInt(30, 90) / 10)), v.applyForce(new r.Vector3(1, 0, 0))))
                }(u, l, p), d.applyHook(0, .12), d.applyDrag(.01), d.updateVelocity(), v.applyHook(0, .005), v.applyDrag(.2), v.updateVelocity(), m.position.copy(d.velocity), m.material.uniforms.time.value++, m.material.uniforms.time2.value += 1 + Math.floor(4 * d.acceleration.length()), m.material.uniforms.acceleration.value = d.acceleration.length(), g.material.uniforms.time.value++, g.material.uniforms.acceleration.value = v.velocity.length(), l.force.position.applyHook(0, .025), l.force.position.applyDrag(.2), l.force.position.updateVelocity(), l.updatePosition(), l.lookAtCenter(), c.render(u, l)
            },
            b = function() {
                var t = new r.Vector2,
                    e = new r.Vector2,
                    n = new r.Vector2,
                    a = function(e, n, r) {
                        t.set(e, n), o(t)
                    },
                    c = function(t, n, r) {
                        e.set(t, n), o(e), p = e
                    },
                    u = function(t, e, r) {
                        n.set(t, e)
                    };
                window.addEventListener("resize", i(function() {
                    y()
                }), 1e3), s.addEventListener("mousedown", function(t) {
                    t.preventDefault(), a(t.clientX, t.clientY)
                }), s.addEventListener("mousemove", function(t) {
                    t.preventDefault(), c(t.clientX, t.clientY)
                }), s.addEventListener("mouseup", function(t) {
                    t.preventDefault(), u(t.clientX, t.clientY)
                }), s.addEventListener("touchstart", function(t) {
                    t.preventDefault(), a(t.touches[0].clientX, t.touches[0].clientY)
                }), s.addEventListener("touchmove", function(t) {
                    t.preventDefault(), c(t.touches[0].clientX, t.touches[0].clientY)
                }), s.addEventListener("touchend", function(t) {
                    t.preventDefault(), u(t.changedTouches[0].clientX, t.changedTouches[0].clientY)
                }), window.addEventListener("mouseout", function() {
                    event.preventDefault(), n.set(0, 0)
                })
            };
        c.setSize(window.innerWidth, window.innerHeight), c.setClearColor(0, 1), l.position.set(1e3, 1e3, 1e3), l.lookAt(new r.Vector3), b(), u.add(m), u.add(g), l.setPolarCoord(0, t.getRadian(90), 24), y(),
            function t() {
                x(), requestAnimationFrame(t)
            }()
    }
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nvarying mat4 m_matrix;\n\nfloat inverse_1_0(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse_1_0(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse_1_0(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse_1_0(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\n\n\nvoid main(void) {\n  m_matrix = inverse_1_0(modelMatrix);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nuniform float time;\nuniform float time2;\nuniform float acceleration;\nuniform vec2 resolution;\n\nvarying mat4 m_matrix;\n\n// const vec3 cPos = vec3(0.0, 0.0, 10.0);\nconst float targetDepth = 3.5;\nconst vec3 lightDir = vec3(0.577, -0.577, 0.577);\n\nvec3 hsv2rgb_1_0(vec3 c){\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_4_1(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_4_1(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_4_2(vec4 x) {\n     return mod289_4_1(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_4_3(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_4_4(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_4_5 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_4_6 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_4_6;\n  vec3 i1 = min( g_4_6.xyz, l.zxy );\n  vec3 i2 = max( g_4_6.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_4_5.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_4_1(i);\n  vec4 p = permute_4_2( permute_4_2( permute_4_2(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_4_5.wyz - D_4_5.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_4_7 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_4_8 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_4_7.xy,h.z);\n  vec3 p3 = vec3(a1_4_7.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_4_3(vec4(dot(p0_4_8,p0_4_8), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_4_8 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_4_8,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\nvec3 rotate_2_9(vec3 p, float radian_x, float radian_y, float radian_z) {\n  mat3 mx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, cos(radian_x), -sin(radian_x),\n    0.0, sin(radian_x), cos(radian_x)\n  );\n  mat3 my = mat3(\n    cos(radian_y), 0.0, sin(radian_y),\n    0.0, 1.0, 0.0,\n    -sin(radian_y), 0.0, cos(radian_y)\n  );\n  mat3 mz = mat3(\n    cos(radian_z), -sin(radian_z), 0.0,\n    sin(radian_z), cos(radian_z), 0.0,\n    0.0, 0.0, 1.0\n  );\n  return mx * my * mz * p;\n}\n\n\nfloat dBox_3_10(vec3 p, vec3 size) {\n  return length(max(abs(p) - size, 0.0));\n}\n\n\n\nfloat getNoise(vec3 p) {\n  return snoise_4_4(p * (0.4 + acceleration * 0.1) + time / 100.0);\n}\n\nvec3 getRotate(vec3 p) {\n  return rotate_2_9(p, radians(time2), radians(time2 * 2.0), radians(time2));\n}\n\nfloat distanceFunc(vec3 p) {\n  vec4 p1 = m_matrix * vec4(p, 1.0);\n  float n1 = getNoise(p1.xyz);\n  vec3 p2 = getRotate(p1.xyz);\n  float d1 = dBox_3_10(p2, vec3(0.8 - min(acceleration, 0.8))) - 0.2;\n  float d2 = dBox_3_10(p2, vec3(1.0)) - n1;\n  float d3 = dBox_3_10(p2, vec3(0.5 + acceleration * 0.4)) - n1;\n  return min(max(d1, -d2), d3);\n}\n\nfloat distanceFuncForFill(vec3 p) {\n  vec4 p1 = m_matrix * vec4(p, 1.0);\n  float n = getNoise(p1.xyz);\n  vec3 p2 = getRotate(p1.xyz);\n  return dBox_3_10(p2, vec3(0.5 + acceleration * 0.4)) - n;\n}\n\nvec3 getNormal(vec3 p) {\n  const float d = 0.1;\n  return normalize(vec3(\n    distanceFunc(p + vec3(d, 0.0, 0.0)) - distanceFunc(p + vec3(-d, 0.0, 0.0)),\n    distanceFunc(p + vec3(0.0, d, 0.0)) - distanceFunc(p + vec3(0.0, -d, 0.0)),\n    distanceFunc(p + vec3(0.0, 0.0, d)) - distanceFunc(p + vec3(0.0, 0.0, -d))\n  ));\n}\n\nvoid main() {\n  vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n\n  vec3 cDir = normalize(cameraPosition * -1.0);\n  vec3 cUp  = vec3(0.0, 1.0, 0.0);\n  vec3 cSide = cross(cDir, cUp);\n\n  vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n\n  float distance = 0.0;\n  float rLen = 0.0;\n  vec3 rPos = cameraPosition;\n  for(int i = 0; i < 64; i++){\n    distance = distanceFunc(rPos);\n    rLen += distance;\n    rPos = cameraPosition + ray * rLen * 0.2;\n  }\n\n  vec3 normal = getNormal(rPos);\n  if(abs(distance) < 0.5){\n    if (distanceFuncForFill(rPos) > 0.5) {\n      gl_FragColor = vec4(hsv2rgb_1_0(vec3(dot(normal, cUp) * 0.8 + time / 400.0, 0.2, dot(normal, cUp) * 0.8 + 0.1)), 1.0);\n    } else {\n      gl_FragColor = vec4(hsv2rgb_1_0(vec3(dot(normal, cUp) * 0.1 + time / 400.0, 0.8, dot(normal, cUp) * 0.2 + 0.8)), 1.0);\n    }\n  } else {\n    gl_FragColor = vec4(0.0);\n  }\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nuniform float time;\nuniform float acceleration;\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\nvarying mat4 invertMatrix;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_3_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_3_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_3_1(vec4 x) {\n     return mod289_3_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_3_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_3_3(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_3_4 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_3_5 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_3_5;\n  vec3 i1 = min( g_3_5.xyz, l.zxy );\n  vec3 i2 = max( g_3_5.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_3_4.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_3_0(i);\n  vec4 p = permute_3_1( permute_3_1( permute_3_1(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_3_4.wyz - D_3_4.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_3_6 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_3_7 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_3_6.xy,h.z);\n  vec3 p3 = vec3(a1_3_6.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_3_2(vec4(dot(p0_3_7,p0_3_7), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_3_7 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_3_7,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\nvec3 hsv2rgb_1_8(vec3 c){\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat inverse_4_9(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse_4_9(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse_4_9(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse_4_9(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\n\nvec3 rotate_2_10(vec3 p, float radian_x, float radian_y, float radian_z) {\n  mat3 mx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, cos(radian_x), -sin(radian_x),\n    0.0, sin(radian_x), cos(radian_x)\n  );\n  mat3 my = mat3(\n    cos(radian_y), 0.0, sin(radian_y),\n    0.0, 1.0, 0.0,\n    -sin(radian_y), 0.0, cos(radian_y)\n  );\n  mat3 mz = mat3(\n    cos(radian_z), -sin(radian_z), 0.0,\n    sin(radian_z), cos(radian_z), 0.0,\n    0.0, 0.0, 1.0\n  );\n  return mx * my * mz * p;\n}\n\n\n\nvec3 getRotate(vec3 p) {\n  return rotate_2_10(p, radians(time / 6.0), radians(time / 7.0), radians(time / 8.0));\n}\n\nvoid main() {\n  float updateTime = time / 400.0;\n  vec3 p_rotate = getRotate(position);\n  float noise = snoise_3_3(vec3(p_rotate / 12.1 + updateTime * 0.5));\n  vec3 p_noise = p_rotate + p_rotate * noise / 20.0 * (min(acceleration, 6.0) + 1.0);\n\n  vPosition = p_noise;\n  vColor = hsv2rgb_1_8(vec3(updateTime + position.y / 400.0, 0.05 + min(acceleration / 10.0, 0.25), 1.0));\n  invertMatrix = inverse_4_9(modelMatrix);\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(p_noise, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nuniform float time;\nuniform float acceleration;\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\nvarying mat4 invertMatrix;\n\nvoid main() {\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  vec3 inv_light = normalize(invertMatrix * vec4(0.7, -0.7, 0.7, 1.0)).xyz;\n  float diff = (dot(normal, inv_light) + 1.0) / 4.0 + 0.4;\n  gl_FragColor = vec4(vColor * diff, 1.0);\n}\n"
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(13).default;
    e.default = function() {
        n(14);
        var t = n(101),
            e = n(31),
            a = document.getElementById("canvas-webgl"),
            s = new r.WebGLRenderer({
                antialias: !0,
                canvas: a
            }),
            c = new r.Scene,
            u = new e(35, window.innerWidth / window.innerHeight, 1, 1e4),
            l = (new r.Clock, null),
            h = null,
            f = new r.HemisphereLight('#FF0000', 0, 1),
            d = new r.Scene,
            v = new e(45, window.innerWidth / window.innerHeight, 1, 1e4),
            p = new r.HemisphereLight('#4488dd', 0, 1.7),
            m = new t,
            g = 1,
            y = new r.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
                magFilter: r.NearestFilter,
                minFilter: r.NearestFilter,
                wrapS: r.ClampToEdgeWrapping,
                wrapT: r.ClampToEdgeWrapping
            }),
            x = null,
            b = function() {
                document.body.className = "bg-white", l = function() {
                    var t = new r.BufferGeometry;
                    t.fromGeometry(new r.OctahedronGeometry(300, 5));
                    var e = new r.ShaderMaterial({
                        uniforms: r.UniformsUtils.merge([r.UniformsLib.lights, {
                            time: {
                                type: "f",
                                value: 0
                            },
                            radius: {
                                type: "f",
                                value: 10
                            },
                            distort: {
                                type: "f",
                                value: 0
                            }
                        }]),
                        vertexShader: n(573),
                        fragmentShader: n(574),
                        lights: !0
                    });
                    return new r.Mesh(t, e)
                }(), d.add(l), h = function() {
                    var t = new r.SphereGeometry(2800),
                        e = new r.MeshPhongMaterial({
                            side: r.BackSide,
                            color: "#79245a"
                        });
                    return new r.Mesh(t, e)
                }(), d.add(h), d.add(p), v.force.position.anchor.set(1800, 1800, 0), v.force.look.anchor.set(0, 0, 0), x = function() {
                    var t = new r.PlaneGeometry(2, 2),
                        e = new r.BufferGeometry;
                    e.fromGeometry(t);
                    var i = new r.ShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            },
                            resolution: {
                                type: "v2",
                                value: new r.Vector2(window.innerWidth, window.innerHeight)
                            },
                            acceleration: {
                                type: "f",
                                value: 0
                            },
                            texture: {
                                type: "t",
                                value: y
                            }
                        },
                        vertexShader: n(575),
                        fragmentShader: n(576)
                    });
                    return new r.Mesh(e, i)
                }(), c.add(x), c.add(f), u.force.position.anchor.set(1800, 1800, 0), u.force.look.anchor.set(0, 0, 0), m.anchor.set(1, 0), m.anchor.set(1, 0), m.velocity.set(1, 0), m.k = .045, m.d = .16
            },
            w = function() {
                a.width = window.innerWidth, a.height = window.innerHeight, u.aspect = window.innerWidth / window.innerHeight, u.updateProjectionMatrix(), s.setSize(window.innerWidth, window.innerHeight), y.setSize(window.innerWidth, window.innerHeight), v.resize(window.innerWidth, window.innerHeight), x.material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight)
            },
            _ = function t() {
                m.applyHook(0, m.k), m.applyDrag(m.d), m.updateVelocity(), l.material.uniforms.time.value += g, l.material.uniforms.radius.value = m.velocity.x, l.material.uniforms.distort.value = m.velocity.x / 2 - .1, v.force.position.applyHook(0, .85), v.force.position.applyDrag(.9), v.force.position.updateVelocity(), v.updatePosition(), v.force.look.applyHook(0, 2), v.force.look.applyDrag(4), v.force.look.updateVelocity(), v.updateLook(), x.material.uniforms.time.value += g*200, x.material.uniforms.acceleration.value = m.acceleration.length()*1.4, u.force.position.applyHook(0, 25), u.force.position.applyDrag(2), u.force.position.updateVelocity(), u.updatePosition(), u.force.look.applyHook(0, 20), u.force.look.applyDrag(4), u.force.look.updateVelocity(), u.lookAt(u.force.look.velocity), s.render(d, v, y), s.render(c, u), requestAnimationFrame(t)
            },
            M = function() {
                var t = new r.Vector2,
                    e = new r.Vector2,
                    n = new r.Vector2,
                    s = function(e, n, r) {
                        t.set(e, n), o(t), m.anchor.x < 3 ? (m.k += .005, m.d -= .03, m.anchor.x += 1.4, g += .2) : (m.k = .05, m.d = .16, m.anchor.x = 1, g = 1)
                    },
                    c = function(t, n, r) {
                        e.set(t, n), o(e)
                    },
                    u = function(t, e, r) {
                        n.set(t, e)
                    };
                window.addEventListener("resize", i(function() {
                    w()
                }), 1e3), window.addEventListener("mousedown", function(t) {
                    t.preventDefault(), s(t.clientX, t.clientY)
                }), window.addEventListener("mousemove", function(t) {
                    t.preventDefault(), c(t.clientX, t.clientY)
                }), window.addEventListener("mouseup", function(t) {
                    t.preventDefault(), u(t.clientX, t.clientY)
                }), a.addEventListener("touchstart", function(t) {
                     s(t.touches[0].clientX, t.touches[0].clientY)
                }), a.addEventListener("touchmove", function(t) {
                    t.preventDefault(), c(t.touches[0].clientX, t.touches[0].clientY)
                }), a.addEventListener("touchend", function(t) {
                    t.preventDefault(), u(t.changedTouches[0].clientX, t.changedTouches[0].clientY)
                }), window.addEventListener("mouseout", function() {
                    event.preventDefault(), n.set(0, 0)
                })
            };
        s.setSize(window.innerWidth, window.innerHeight), s.setClearColor('#2a1bee', 1), u.position.set(1e3, 1e3, 1e3), u.lookAt(new r.Vector3), M(), b(), w(), _()
    }
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nuniform float time;\nuniform float radius;\nuniform float distort;\n\nvarying vec3 vColor;\nvarying vec3 vNormal;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_2_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_2_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_2_1(vec4 x) {\n     return mod289_2_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_2_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_2_3(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_2_4 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_2_5 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_2_5;\n  vec3 i1 = min( g_2_5.xyz, l.zxy );\n  vec3 i2 = max( g_2_5.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_2_4.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_2_0(i);\n  vec4 p = permute_2_1( permute_2_1( permute_2_1(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_2_4.wyz - D_2_4.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_2_6 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_2_7 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_2_6.xy,h.z);\n  vec3 p3 = vec3(a1_2_6.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_2_2(vec4(dot(p0_2_7,p0_2_7), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_2_7 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_2_7,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\nvec3 hsv2rgb_1_8(vec3 c){\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid main() {\n  float updateTime = time / 1000.0;\n  float noise = snoise_2_3(vec3(position / 400.1 + updateTime * 5.0));\n  vec4 mvPosition = modelViewMatrix * vec4(position * (noise * pow(distort, 2.0) + radius), 1.0);\n\n  vColor = hsv2rgb_1_8(vec3(noise * distort * 0.3 + updateTime, 0.2, 1.0));\n  vNormal = normal;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nvarying vec3 vColor;\nvarying vec3 vNormal;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_2_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_2_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_2_1(vec4 x) {\n     return mod289_2_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_2_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_2_3(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_2_4 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_2_5 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_2_5;\n  vec3 i1 = min( g_2_5.xyz, l.zxy );\n  vec3 i2 = max( g_2_5.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_2_4.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_2_0(i);\n  vec4 p = permute_2_1( permute_2_1( permute_2_1(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_2_4.wyz - D_2_4.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_2_6 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_2_7 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_2_6.xy,h.z);\n  vec3 p3 = vec3(a1_2_6.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_2_2(vec4(dot(p0_2_7,p0_2_7), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_2_7 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_2_7,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\nvec3 hsv2rgb_1_8(vec3 c){\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nstruct HemisphereLight {\n  vec3 direction;\n  vec3 groundColor;\n  vec3 skyColor;\n};\nuniform HemisphereLight hemisphereLights[NUM_HEMI_LIGHTS];\n\nvoid main() {\n  vec3 light = vec3(0.0);\n  light += (dot(hemisphereLights[0].direction, vNormal) + 1.0) * hemisphereLights[0].skyColor * 0.5;\n  light += (-dot(hemisphereLights[0].direction, vNormal) + 1.0) * hemisphereLights[0].groundColor * 0.5;\n  gl_FragColor = vec4(vColor * light, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(t, e) {
    t.exports = "#define GLSLIFY 1\nuniform float time;\nuniform vec2 resolution;\nuniform float acceleration;\nuniform sampler2D texture;\n\nconst float blur = 56.0;\n\nvarying vec2 vUv;\n\nfloat random2_1_0(vec2 c){\n    return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_2_1(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289_2_1(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute_2_2(vec3 x) {\n  return mod289_2_1(((x*34.0)+1.0)*x);\n}\n\nfloat snoise_2_3(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289_2_1(i); // Avoid truncation effects in permutation\n  vec3 p = permute_2_2( permute_2_2( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\n\n\nvec2 diffUv(float v, float diff) {\n  return vUv + (vec2(v + snoise_2_3(vec2(gl_FragCoord.y + time) / 100.0), 0.0) * diff + vec2(v * 3.0, 0.0)) / resolution;\n}\n\nfloat randomNoise(vec2 p) {\n  return (random2_1_0(p - vec2(sin(time))) * 2.0 - 1.0) * max(length(acceleration), 0.08);\n}\n\nvoid main() {\n  float diff = 300.0 * length(acceleration);\n  vec2 uv_r = diffUv(4.5, diff);\n  vec2 uv_g = diffUv(-0.0, diff);\n  vec2 uv_b = diffUv(-4.0, diff);\n  float r = texture2D(texture, uv_r).r + randomNoise(uv_r);\n  float g = texture2D(texture, uv_g).g + randomNoise(uv_g);\n  float b = texture2D(texture, uv_b).b + randomNoise(uv_b);\n  gl_FragColor = vec4(r, g, b, 1.0);\n}\n"
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(13).default;
    e.default = function() {
        var t = n(14),
            e = n(64),
            a = n(65),
            s = n(31),
            c = document.getElementById("canvas-webgl"),
            u = new r.WebGLRenderer({
                antialias: !0,
                canvas: c
            }),
            l = new r.Scene,
            h = new s(35, window.innerWidth / window.innerHeight, 1, 1e4),
            f = (new r.Clock, new Image),
            d = [],
            v = [],
            p = null,
            m = null,
            g = null,
            y = null,
            x = new a,
            b = !1,
            w = function() {
                var t = document.createElement("canvas"),
                    e = t.getContext("2d"),
                    n = null,
                    i = null;
                return t.width = 200, t.height = 200, (n = e.createRadialGradient(100, 100, 20, 100, 100, 100)).addColorStop(.2, "rgba(255, 255, 255, 1)"), n.addColorStop(.5, "rgba(255, 255, 255, 0.3)"), n.addColorStop(1, "rgba(255, 255, 255, 0)"), e.fillStyle = n, e.arc(100, 100, 100, 0, Math.PI / 180, !0), e.fill(), (i = new r.Texture(t)).minFilter = r.NearestFilter, i.needsUpdate = !0, i
            },
            _ = function() {
                ! function(t) {
                    f.src = "elephant.png", f.onload = function() {
                        t()
                    }
                }(function() {
                    ! function() {
                        var t = document.createElement("canvas"),
                            e = t.getContext("2d");
                        t.width = 400, t.height = 400, e.drawImage(f, 0, 0);
                        for (var n = e.getImageData(0, 0, 400, 400), r = 0; r < 400; r++)
                            if (!(r % 3 > 0))
                                for (var i = 0; i < 400; i++) i % 3 > 0 || n.data[4 * (i + 400 * r)] > 0 && d.push(0, -1 * (r - 200), -1 * (i - 200))
                    }(),
                    function(t) {
                        p = new Float32Array(d/5), m = new Float32Array(d.length/5), g = new Float32Array(d.length / 1), y = new Float32Array(d.length / 0.001);
                        for (var i = 0; i < d.length / 3; i++) {
                            var o = new e,
                                a = new r.Color("hsl(" + (d[3 * i + 2] + d[3 * i + 1] + 400) / 5 + ", 60%, 80%)");
                            o.init(new r.Vector3(d[3 * i], d[3 * i + 1], d[3 * i + 2])), o.is_activate = !0, v.push(o), a.toArray(m, 3 * i), g[i] = 1, y[i] = 12
                        }
                        x.init({
                            scene: t,
                            vs: n(66),
                            fs: n(67),
                            positions: p,
                            colors: m,
                            opacities: g,
                            sizes: y,
                            texture: w(),
                            blending: r.NormalBlending
                        }), b = !0
                    }(l)
                }), h.setPolarCoord(0, 0, 1400)
            },
            M = function() {
                c.width = window.innerWidth, c.height = window.innerHeight, h.aspect = window.innerWidth / window.innerHeight, h.updateProjectionMatrix(), u.setSize(window.innerWidth, window.innerHeight)
            },
            S = function() {
                b && (! function() {
                    for (var e = 0; e < v.length; e++) {
                        var n = v[e];
                        n.time++, n.acceleration.length() < 1 && (n.is_activate = !0), n.is_activate ? (n.applyHook(0, .18), n.applyDrag(.26)) : n.applyDrag(.035), n.updateVelocity(), n.velocity.sub(x.velocity), p[3 * e + 0] = n.velocity.x - x.velocity.x, p[3 * e + 1] = n.velocity.y - x.velocity.x, p[3 * e + 2] = n.velocity.z - x.velocity.x, n.size = Math.log(t.getRandomInt(1, 128)) / Math.log(128) * Math.sqrt(document.body.clientWidth), y[e] = n.size
                    }
                    x.updatePoints()
                }(), x.updatePoints()), h.force.position.applyHook(0, .025), h.force.position.applyDrag(.2), h.force.position.updateVelocity(), h.updatePosition(), h.lookAtCenter(), u.render(l, h)
            },
            E = function() {
                var e = new r.Vector2,
                    n = new r.Vector2,
                    a = new r.Vector2,
                    s = function(n, r, i) {
                        e.set(n, r), o(e),
                            function() {
                                for (var e = 0; e < v.length; e++) {
                                    var n = v[e],
                                        r = t.getRadian(t.getRandomInt(0, 360)),
                                        i = t.getRadian(t.getRandomInt(0, 360)),
                                        o = t.getRandomInt(40, 80);
                                    n.is_activate = !1, n.applyForce(t.getPolarCoord(r, i, o))
                                }
                            }()
                    },
                    u = function(t, e, r) {
                        n.set(t, e), o(n), h.force.position.anchor.z = 1e3 * n.x, h.force.position.anchor.y = -1e3 * n.y
                    },
                    l = function(t, e, n) {
                        a.set(t, e), h.force.position.anchor.z = 0, h.force.position.anchor.y = 0
                    };
                window.addEventListener("resize", i(function() {
                    M()
                }), 1e3), c.addEventListener("mousedown", function(t) {
                    t.preventDefault(), s(t.clientX, t.clientY)
                }), c.addEventListener("mousemove", function(t) {
                    t.preventDefault(), u(t.clientX, t.clientY)
                }), c.addEventListener("mouseup", function(t) {
                    t.preventDefault(), l(t.clientX, t.clientY)
                }), c.addEventListener("touchstart", function(t) {
                    t.preventDefault(), s(t.touches[0].clientX, t.touches[0].clientY)
                }), c.addEventListener("touchmove", function(t) {
                    t.preventDefault(), u(t.touches[0].clientX, t.touches[0].clientY)
                }), c.addEventListener("touchend", function(t) {
                    t.preventDefault(), l(t.changedTouches[0].clientX, t.changedTouches[0].clientY)
                }), window.addEventListener("mouseout", function() {
                    event.preventDefault(), a.set(0, 0), h.force.position.anchor.z = 0, h.force.position.anchor.y = 0
                })
            };
        u.setSize(window.innerWidth, window.innerHeight), u.setClearColor(0, 1), h.position.set(1e3, 1e3, 1e3), h.lookAt(new r.Vector3), E(), _(), M(),
            function t() {
                S(), requestAnimationFrame(t)
            }()
    }
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(13).default;
    e.default = function() {
        var t = n(14),
            e = n(42),
            a = n(138),
            s = n(31),
            c = document.getElementById("canvas-webgl"),
            u = new r.WebGLRenderer({
                antialias: !0,
                canvas: c
            }),
            l = new r.Scene,
            h = new s(35, window.innerWidth / window.innerHeight, 1, 1e4),
            f = (new r.Clock, []),
            d = null,
            v = new r.Raycaster,
            p = -1,
            m = -1,
            g = !1,
            y = !1,
            x = !1,
            b = function() {
                this.rad = 0, this.obj, this.is_entered = !1, e.call(this)
            },
            w = new r.PlaneGeometry(100, 100);
        (b.prototype = Object.create(e.prototype)).constructor = b, b.prototype.init = function(e) {
            var n = new r.MeshPhongMaterial({
                side: r.DoubleSide,
                map: (new r.TextureLoader).load("../img/sketch/gallery/image0" + t.getRandomInt(1, 9) + ".jpg")
            });
            this.obj = new r.Mesh(w, n), this.velocity = e.clone(), this.anchor = e.clone(), this.acceleration.set(0, 0, 0)
        };
        var _ = function(t) {
                if (!x) {
                    var e;
                    v.setFromCamera(t, h), (e = v.intersectObjects(l.children)).length > 0 && 0 == y ? (document.body.classList.add("is-pointed"), p = e[0].object.id) : S()
                }
            },
            M = function(t, e) {
                x = !0, t.force.position.anchor.set(780 * Math.cos(e.rad), e.obj.position.y, 780 * Math.sin(e.rad)), t.force.look.anchor.copy(e.obj.position), S()
            },
            S = function() {
                document.body.classList.remove("is-pointed"), p = -1
            },
            E = function() {
                ! function(e) {
                    for (var n = 0; n < 300; n++) {
                        var i = null,
                            o = t.getRadian(n % 45 * 8 + 180),
                            a = 1e3 * Math.cos(o),
                            s = 5 * n - 750,
                            c = 1e3 * Math.sin(o),
                            u = new r.Vector3(a, s, c);
                        (i = new b).init(new r.Vector3), i.rad = o, i.obj.position.copy(u), e.add(i.obj), f.push(i)
                    }
                }(l), d = new a(16777215, 16777215, 1), l.add(d), h.force.position.anchor.set(0, 0, 0), h.rotate_rad1 = t.getRadian(-35), h.rotate_rad1_base = h.rotate_rad1, h.rotate_rad2 = t.getRadian(180), h.rotate_rad2_base = h.rotate_rad2
            },
            T = function() {
                c.width = window.innerWidth, c.height = window.innerHeight, h.aspect = window.innerWidth / window.innerHeight, h.updateProjectionMatrix(), u.setSize(window.innerWidth, window.innerHeight)
            },
            P = function e() {
                ! function() {
                    for (var e = 0; e < 300; e++) f[e].applyHook(0, .14), f[e].applyDrag(.4), f[e].updateVelocity(), f[e].obj.lookAt(0, f[e].obj.position.y, 0), f[e].obj.id == p && 0 == y && 0 == x ? 1 == g ? m = e : f[e].obj.material.color.set(11184810) : f[e].obj.material.color.set(16777215);
                    h.force.position.applyHook(0, .08), h.force.position.applyDrag(.4), h.force.position.updateVelocity(), h.updatePosition(), !1 === x && h.force.look.anchor.copy(t.getPolarCoord(h.rotate_rad1, h.rotate_rad2, 1e3)), h.force.look.applyHook(0, .08), h.force.look.applyDrag(.4), h.force.look.updateVelocity(), h.updateLook(), u.render(l, h)
                }(), requestAnimationFrame(e)
            },
            L = function() {
                var e = new r.Vector2,
                    n = new r.Vector2,
                    a = new r.Vector2,
                    s = function(t, n, r) {
                        e.set(t, n), o(e), _(e), g = !0
                    },
                    u = function(r, i, a) {
                        n.set(r, i), o(n), _(l), g && e.clone().sub(n).length() > .01 && (g = !1, y = !0), 1 == y && 0 == x && (h.rotate_rad1 = h.rotate_rad1_base + t.getRadian(50 * (e.y - n.y)), h.rotate_rad2 = h.rotate_rad2_base + t.getRadian(50 * (e.x - n.x)), h.rotate_rad1 < t.getRadian(-50) && (h.rotate_rad1 = t.getRadian(-50)), h.rotate_rad1 > t.getRadian(50) && (h.rotate_rad1 = t.getRadian(50)))
                    },
                    d = function(t, e, n) {
                        a.set(t, e), S(), x ? (h.force.position.anchor.set(0, 0, 0), m = -1, x = !1) : g && m > -1 ? M(h, f[m]) : y && (h.rotate_rad1_base = h.rotate_rad1, h.rotate_rad2_base = h.rotate_rad2), g = !1, y = !1
                    };
                window.addEventListener("resize", i(function() {
                    T()
                }), 1e3), c.addEventListener("mousedown", function(t) {
                    t.preventDefault(), s(t.clientX, t.clientY)
                }), c.addEventListener("mousemove", function(t) {
                    t.preventDefault(), u(t.clientX, t.clientY)
                }), c.addEventListener("mouseup", function(t) {
                    t.preventDefault(), d(t.clientX, t.clientY)
                }), c.addEventListener("touchstart", function(t) {
                    t.preventDefault(), s(t.touches[0].clientX, t.touches[0].clientY)
                }), c.addEventListener("touchmove", function(t) {
                    t.preventDefault(), u(t.touches[0].clientX, t.touches[0].clientY)
                }), c.addEventListener("touchend", function(t) {
                    t.preventDefault(), d(t.changedTouches[0].clientX, t.changedTouches[0].clientY)
                }), window.addEventListener("mouseout", function() {
                    event.preventDefault(), a.set(0, 0), S(), x ? (h.force.position.anchor.set(0, 0, 0), m = -1, x = !1) : g && m > -1 ? M(h, f[m]) : y && (h.rotate_rad1_base = h.rotate_rad1, h.rotate_rad2_base = h.rotate_rad2), g = !1, y = !1
                })
            };
        u.setSize(window.innerWidth, window.innerHeight), u.setClearColor(0, 1), h.position.set(1e3, 1e3, 1e3), h.lookAt(new r.Vector3), L(), E(), T(), P()
    }
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(13).default;
    e.default = function() {
        var t = n(14),
            e = n(101),
            a = n(64),
            s = n(65),
            c = n(138),
            u = n(139),
            l = n(31),
            h = document.getElementById("canvas-webgl"),
            f = new r.WebGLRenderer({
                antialias: !0,
                canvas: h
            }),
            d = new r.Scene,
            v = new l(35, window.innerWidth / window.innerHeight, 1, 1e4),
            p = (new r.Clock, []),
            m = 2,
            g = new s,
            y = null,
            x = null,
            b = null,
            w = new Float32Array(3e4),
            _ = new Float32Array(3e4),
            M = new Float32Array(1e4),
            S = new Float32Array(1e4),
            E = null,
            T = new e,
            P = null,
            L = Date.now(),
            A = Date.now(),
            z = Date.now(),
            C = Date.now(),
            R = 0,
            I = !1,
            D = !1,
            O = !0,
            F = function() {
                E = function() {
                    for (var t = new r.OctahedronGeometry(30, 2), e = new r.BufferGeometry, n = new r.MeshPhongMaterial({
                            color: new r.Color("hsl(140, 100%, 100%)"),
                            flatShading: !0
                        }), i = new Float32Array(3 * t.vertices.length), o = 0; o < t.vertices.length; o++) i[3 * o] = t.vertices[o].x, i[3 * o + 1] = t.vertices[o].y, i[3 * o + 2] = t.vertices[o].z;
                    for (var a = new Uint32Array(3 * t.faces.length), s = 0; s < t.faces.length; s++) a[3 * s] = t.faces[s].a, a[3 * s + 1] = t.faces[s].b, a[3 * s + 2] = t.faces[s].c;
                    return e.addAttribute("position", new r.BufferAttribute(i, 3)), e.attributes.position.dynamic = !0, e.setIndex(new r.BufferAttribute(a, 1)), e.index.dynamic = !0, new r.Mesh(e, n)
                }(), d.add(E), P = function() {
                    var t = new r.OctahedronGeometry(250, 4),
                        e = new r.MeshPhongMaterial({
                            color: 2236962,
                            flatShading: !0
                        });
                    return new r.Mesh(t, e)
                }(), d.add(P);
                for (var e = 0; e < 1e4; e++) {
                    var i = new a,
                        o = t.getRandomInt(95, 185),
                        s = t.getRandomInt(60, 80);
                    i.init(new r.Vector3(t.getRandomInt(-100, 100), 0, 0)), i.color = new r.Color("hsl(" + o + ", " + s + "%, 70%)"), p.push(i), w[3 * e + 0] = i.velocity.x, w[3 * e + 1] = i.velocity.y, w[3 * e + 2] = i.velocity.z, _[3 * e + 0] = i.color.r, _[3 * e + 1] = i.color.g, _[3 * e + 2] = i.color.b, M[e] = i.a, S[e] = i.size
                }
                g.init({
                    scene: d,
                    vs: n(66),
                    fs: n(67),
                    positions: w,
                    colors: _,
                    opacities: M,
                    sizes: S,
                    texture: function() {
                        var t = document.createElement("canvas"),
                            e = t.getContext("2d"),
                            n = null,
                            i = null;
                        return t.width = 200, t.height = 200, (n = e.createRadialGradient(100, 100, 20, 100, 100, 100)).addColorStop(.9, "rgba(255, 255, 255, 1)"), n.addColorStop(1, "rgba(255, 255, 255, 0)"), e.fillStyle = n, e.arc(100, 100, 100, 0, Math.PI / 180, !0), e.fill(), (i = new r.Texture(t)).minFilter = r.NearestFilter, i.needsUpdate = !0, i
                    }(),
                    blending: r.NormalBlending
                }), g.rad1 = 0, g.rad1_base = 0, g.rad2 = 0, g.rad3 = 0, y = new c(new r.Color("hsl(95, 50%, 60%)").getHex(), new r.Color("hsl(185, 50%, 60%)").getHex(), 1), d.add(y), x = new u("hsl(95, 60%, 50%)", 1, 500, 1), d.add(x), b = new u("hsl(95, 60%, 50%)", 1, 500, 1), d.add(b), v.anchor = new r.Vector3(1500, 0, 0)
            },
            j = function() {
                h.width = window.innerWidth, h.height = window.innerHeight, v.aspect = window.innerWidth / window.innerHeight, v.updateProjectionMatrix(), f.setSize(window.innerWidth, window.innerHeight)
            },
            k = function() {
                I && R < 200 ? R += 1 : R > 0 && (R -= 1), g.velocity = (E.rotation.x += .03 + R / 1e3, E.rotation.y += .01 + R / 1e3, E.rotation.z += .01 + R / 1e3, g.rad1_base += t.getRadian(.6), g.rad1 = t.getRadian(45 * Math.sin(g.rad1_base) + R / 100), g.rad2 += t.getRadian(.8 + R / 100), g.rad3 += .01, t.getPolarCoord(g.rad1, g.rad2, 350)), !0 === O && (v.force.position.anchor.copy(g.velocity.clone().add(g.velocity.clone().sub(g.obj.position).normalize().multiplyScalar(-400))), v.force.position.anchor.y += 2 * g.velocity.y, v.force.look.anchor.copy(g.velocity)), g.updatePoints(), E.position.copy(g.velocity), y.color.setHSL((95 - R / 1.5) / 360, .5, .6), y.groundColor.setHSL((185 - R / 1.5) / 360, .5, .6), x.position.copy(g.velocity), x.color.setHSL((95 - R / 1.5) / 360, .5, .6), b.position.copy(g.velocity), b.color.setHSL((185 - R / 1.5) / 360, .5, .6),
                    function() {
                        var e = 0;
                        if (Date.now() - L > 10) {
                            for (var n = 0; n < p.length; n++) {
                                var r = p[n];
                                if (!r.is_active) {
                                    var i = t.getRadian(t.getRandomInt(0, 360)),
                                        o = t.getRadian(t.getRandomInt(0, 360)),
                                        a = t.getRandomInt(1, 30),
                                        s = t.getPolarCoord(i, o, a),
                                        c = t.getPolarCoord(i, o, a / 20),
                                        u = t.getRandomInt(95, 185) - R / 1.5,
                                        l = t.getRandomInt(60, 80);
                                    if (s.add(g.velocity), r.activate(), r.init(s), r.color.setHSL(u / 360, l / 100, .7), r.applyForce(c), r.a = 1, r.size = 25, ++e >= m) break
                                }
                            }
                            L = Date.now()
                        }
                    }(),
                    function() {
                        for (var t = 0; t < p.length; t++) {
                            var e = p[t];
                            new r.Vector3, e.is_active && (e.time++, e.applyDrag(.1), e.updateVelocity(), e.time > 10 && (e.size -= 2), e.size <= 0 && (e.init(new r.Vector3(0, 0, 0)), e.time = 0, e.a = 0, e.inactivate())), w[3 * t + 0] = e.velocity.x - g.velocity.x, w[3 * t + 1] = e.velocity.y - g.velocity.y, w[3 * t + 2] = e.velocity.z - g.velocity.z, _[3 * t + 0] = e.color.r, _[3 * t + 1] = e.color.g, _[3 * t + 2] = e.color.b, M[t] = e.a, S[t] = e.size
                        }
                        g.updatePoints()
                    }(), v.force.position.applyHook(0, .025), v.force.position.applyDrag(.2), v.force.position.updateVelocity(), v.updatePosition(), v.force.look.applyHook(0, .2), v.force.look.applyDrag(.4), v.force.look.updateVelocity(), v.updateLook(), x.position.copy(t.getPolarCoord(t.getRadian(0), t.getRadian(0), 24).add(g.velocity)), b.position.copy(t.getPolarCoord(t.getRadian(180), t.getRadian(0), 24).add(g.velocity)), Date.now() - z > 1e3 - 3 * R && (T.applyForce(new r.Vector2(.08 + R / 5e3, 0)), z = Date.now(), D = !0, A = Date.now()), m = D && Date.now() - A < 500 ? 6 + Math.floor(R / 40) : 1 + Math.floor(R / 40), T.applyHook(0, .1), T.applyDrag(.12), T.updateVelocity(), E.scale.set(1 + T.velocity.x, 1 + T.velocity.x, 1 + T.velocity.x), f.render(d, v)
            },
            U = function() {
                var t = new r.Vector2,
                    e = new r.Vector2,
                    n = new r.Vector2,
                    a = function(e, n, r) {
                        t.set(e, n), o(t), I = !0, C = Date.now()
                    },
                    s = function(t, n, r) {
                        e.set(t, n), o(e)
                    },
                    c = function(t, e, r) {
                        n.set(t, e), I = !1, Date.now() - C < 100 && (!0 === O ? (v.force.position.anchor.set(1200, 1200, 0), v.force.look.anchor.set(0, 0, 0), O = !1) : O = !0)
                    };
                window.addEventListener("resize", i(function() {
                    j()
                }), 1e3), h.addEventListener("mousedown", function(t) {
                    t.preventDefault(), a(t.clientX, t.clientY)
                }), h.addEventListener("mousemove", function(t) {
                    t.preventDefault(), s(t.clientX, t.clientY)
                }), h.addEventListener("mouseup", function(t) {
                    t.preventDefault(), c(t.clientX, t.clientY)
                }), h.addEventListener("touchstart", function(t) {
                    t.preventDefault(), a(t.touches[0].clientX, t.touches[0].clientY)
                }), h.addEventListener("touchmove", function(t) {
                    t.preventDefault(), s(t.touches[0].clientX, t.touches[0].clientY)
                }), h.addEventListener("touchend", function(t) {
                    t.preventDefault(), c(t.changedTouches[0].clientX, t.changedTouches[0].clientY)
                }), window.addEventListener("mouseout", function() {
                    event.preventDefault(), n.set(0, 0), I = !1, Date.now() - C < 100 && (!0 === O ? (v.force.position.anchor.set(1200, 1200, 0), v.force.look.anchor.set(0, 0, 0), O = !1) : O = !0)
                })
            };
        f.setSize(window.innerWidth, window.innerHeight), f.setClearColor(0, 1), v.position.set(1e3, 1e3, 1e3), v.lookAt(new r.Vector3), U(), F(), j(),
            function t() {
                k(), requestAnimationFrame(t)
            }()
    }
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(13).default;
    e.default = function() {
        var t = n(14),
            e = n(64),
            a = n(65),
            s = n(31),
            c = document.getElementById("canvas-webgl"),
            u = new r.WebGLRenderer({
                antialias: !0,
                canvas: c
            }),
            l = new r.Scene,
            h = new s(35, window.innerWidth / window.innerHeight, 1, 1e4),
            f = (new r.Clock, []),
            d = new a,
            v = new Float32Array(6e4),
            p = new Float32Array(6e4),
            m = new Float32Array(2e4),
            g = new Float32Array(2e4),
            y = new r.Vector3(1.5, 0, 0),
            x = Date.now(),
            b = !1,
            w = function() {
                for (var i = 0; i < 2e4; i++) {
                    var o = new e,
                        a = t.getRandomInt(60, 210),
                        s = t.getRandomInt(30, 90),
                        c = new r.Color("hsl(" + a + ", " + s + "%, 50%)");
                    o.init(new r.Vector3(t.getRandomInt(-100, 100), 0, 0)), f.push(o), v[3 * i + 0] = o.velocity.x, v[3 * i + 1] = o.velocity.y, v[3 * i + 2] = o.velocity.z, c.toArray(p, 3 * i), m[i] = o.a, g[i] = o.size
                }
                d.init({
                    scene: l,
                    vs: n(66),
                    fs: n(67),
                    positions: v,
                    colors: p,
                    opacities: m,
                    sizes: g,
                    texture: function() {
                        var t = document.createElement("canvas"),
                            e = t.getContext("2d"),
                            n = null,
                            i = null;
                        return t.width = 256, t.height = 256, (n = e.createRadialGradient(128, 128, 20, 128, 128, 128)).addColorStop(.2, "rgba(255, 255, 255, 1)"), n.addColorStop(.5, "rgba(255, 255, 255, 0.3)"), n.addColorStop(1, "rgba(255, 255, 255, 0)"), e.fillStyle = n, e.arc(128, 128, 128, 0, Math.PI / 180, !0), e.fill(), (i = new r.Texture(t)).needsUpdate = !0, i
                    }(),
                    blending: r.AdditiveBlending
                }), h.force.position.anchor.set(800, 0, 0)
            },
            _ = function() {
                c.width = window.innerWidth, c.height = window.innerHeight, h.aspect = window.innerWidth / window.innerHeight, h.updateProjectionMatrix(), u.setSize(window.innerWidth, window.innerHeight)
            },
            M = function() {
                b ? y.x < 6 && (y.x += .02) : y.x > 1.5 && (y.x -= .1),
                    function() {
                        var e = 0;
                        if (Date.now() - x > 16 * y.x) {
                            for (var n = 0; n < f.length; n++) {
                                var i = f[n];
                                if (!i.is_active) {
                                    var o = t.getRadian(3 * t.getRandomInt(0, 120)),
                                        a = Math.log(t.getRandomInt(2, 128)) / Math.log(128) * 160 + 60,
                                        s = Math.sin(o) * a,
                                        c = Math.cos(o) * a,
                                        u = new r.Vector3(-1e3, s, c);
                                    if (u.add(d.velocity), i.activate(), i.init(u), i.a = 0, i.size = t.getRandomInt(5, 60), ++e >= Math.pow(3 * y.x, .4 * y.x)) break
                                }
                            }
                            x = Date.now()
                        }
                    }(),
                    function() {
                        for (var t = 0; t < f.length; t++) {
                            var e = f[t];
                            e.is_active && (e.time++, e.applyForce(y), e.applyDrag(.1), e.updateVelocity(), e.a < .8 && (e.a += .02), e.velocity.x > 1e3 && (e.init(new r.Vector3(0, 0, 0)), e.time = 0, e.a = 0, e.inactivate())), v[3 * t + 0] = e.velocity.x, v[3 * t + 1] = e.velocity.y, v[3 * t + 2] = e.velocity.z, m[t] = e.a, g[t] = e.size
                        }
                        d.updatePoints()
                    }(), h.force.position.applyHook(0, .008), h.force.position.applyDrag(.1), h.force.position.updateVelocity(), h.updatePosition(), h.lookAtCenter(), u.render(l, h)
            },
            S = function() {
                var t = new r.Vector2,
                    e = new r.Vector2,
                    n = new r.Vector2,
                    a = function(e, n, r) {
                        t.set(e, n), o(t), b = !0
                    },
                    s = function(t, n, r) {
                        e.set(t, n), o(e), h.force.position.anchor.z = 120 * e.x, h.force.position.anchor.y = -120 * e.y
                    },
                    u = function(t, e, r) {
                        n.set(t, e), h.force.position.anchor.z = 0, h.force.position.anchor.y = 0, b = !1
                    };
                window.addEventListener("resize", i(function() {
                    _()
                }), 1e3), c.addEventListener("mousedown", function(t) {
                    t.preventDefault(), a(t.clientX, t.clientY)
                }), c.addEventListener("mousemove", function(t) {
                    t.preventDefault(), s(t.clientX, t.clientY)
                }), c.addEventListener("mouseup", function(t) {
                    t.preventDefault(), u(t.clientX, t.clientY)
                }), c.addEventListener("touchstart", function(t) {
                    t.preventDefault(), a(t.touches[0].clientX, t.touches[0].clientY)
                }), c.addEventListener("touchmove", function(t) {
                    t.preventDefault(), s(t.touches[0].clientX, t.touches[0].clientY)
                }), c.addEventListener("touchend", function(t) {
                    t.preventDefault(), u(t.changedTouches[0].clientX, t.changedTouches[0].clientY)
                }), window.addEventListener("mouseout", function() {
                    event.preventDefault(), n.set(0, 0), h.force.position.anchor.z = 0, h.force.position.anchor.y = 0
                })
            };
        u.setSize(window.innerWidth, window.innerHeight), u.setClearColor(0, 1), h.position.set(1e3, 1e3, 1e3), h.lookAt(new r.Vector3), S(), w(), _(),
            function t() {
                M(), requestAnimationFrame(t)
            }()
    }
}, function(t, e, n) {
    "use strict";
    n.r(e);
    var r = n(0),
        i = n(3),
        o = n(13).default;
    e.default = function() {
        var t = n(14),
            e = n(64),
            a = n(65),
            s = n(139),
            c = n(31),
            u = document.getElementById("canvas-webgl"),
            l = new r.WebGLRenderer({
                antialias: !0,
                canvas: u
            }),
            h = new r.Scene,
            f = new c(35, window.innerWidth / window.innerHeight, 1, 1e4),
            d = (new r.Clock, []),
            v = new a,
            p = new s(16737792, 1, 1800, 1),
            m = new Float32Array(3e4),
            g = new Float32Array(3e4),
            y = new Float32Array(1e4),
            x = new Float32Array(1e4),
            b = new r.Vector3(0, .1, 0),
            w = null,
            _ = Date.now(),
            M = !1,
            S = function(t) {
                var e = t.y * window.innerHeight / 3,
                    n = t.x * window.innerWidth / -3;
                v.anchor.y = e, v.anchor.z = n, p.force.anchor.y = e, p.force.anchor.z = n
            },
            E = function() {
                for (var i = 0; i < 1e4; i++) {
                    var o = new e,
                        a = t.getRandomInt(0, 45),
                        s = t.getRandomInt(60, 90),
                        c = new r.Color("hsl(" + a + ", " + s + "%, 50%)");
                    o.init(new r.Vector3(t.getRandomInt(-100, 100), 0, 0)), d.push(o), m[3 * i + 0] = o.velocity.x, m[3 * i + 1] = o.velocity.y, m[3 * i + 2] = o.velocity.z, c.toArray(g, 3 * i), y[i] = o.a, x[i] = o.size
                }
                v.init({
                    scene: h,
                    vs: n(66),
                    fs: n(67),
                    positions: m,
                    colors: g,
                    opacities: y,
                    sizes: x,
                    texture: function() {
                        var t = document.createElement("canvas"),
                            e = t.getContext("2d"),
                            n = null,
                            i = null;
                        return t.width = 200, t.height = 200, (n = e.createRadialGradient(100, 100, 20, 100, 100, 100)).addColorStop(.2, "rgba(255, 255, 255, 1)"), n.addColorStop(.5, "rgba(255, 255, 255, 0.3)"), n.addColorStop(1, "rgba(255, 255, 255, 0)"), e.fillStyle = n, e.arc(100, 100, 100, 0, Math.PI / 180, !0), e.fill(), (i = new r.Texture(t)).minFilter = r.NearestFilter, i.needsUpdate = !0, i
                    }(),
                    blending: r.AdditiveBlending
                }), h.add(p), w = function() {
                    var t = new r.OctahedronGeometry(1500, 3),
                        e = new r.MeshPhongMaterial({
                            color: 16777215,
                            flatShading: !0,
                            side: r.BackSide
                        });
                    return new r.Mesh(t, e)
                }(), h.add(w), f.setPolarCoord(t.getRadian(25), 0, 1e3), p.setPolarCoord(t.getRadian(25), 0, 200)
            },
            T = function() {
                u.width = window.innerWidth, u.height = window.innerHeight, f.aspect = window.innerWidth / window.innerHeight, f.updateProjectionMatrix(), l.setSize(window.innerWidth, window.innerHeight)
            },
            P = function() {
                v.applyHook(0, .08), v.applyDrag(.2), v.updateVelocity(), p.force.applyHook(0, .08), p.force.applyDrag(.2), p.force.updateVelocity(), p.updatePosition(),
                    function() {
                        var e = 0;
                        if (Date.now() - _ > 10) {
                            for (var n = 0; n < d.length; n++) {
                                var i = d[n];
                                if (!i.is_active) {
                                    var o = t.getRadian(Math.log(t.getRandomInt(0, 256)) / Math.log(256) * 260),
                                        a = t.getRadian(t.getRandomInt(0, 360)),
                                        s = 12 * (1 - Math.log(t.getRandomInt(32, 256)) / Math.log(256)),
                                        c = new r.Vector3,
                                        u = t.getPolarCoord(o, a, s);
                                    if (c.add(v.velocity), i.activate(), i.init(c), i.applyForce(u), i.a = .2, i.size = Math.pow(12 - s, 2) * t.getRandomInt(1, 24) / 10, ++e >= 6) break
                                }
                            }
                            _ = Date.now()
                        }
                    }(),
                    function() {
                        for (var t = 0; t < d.length; t++) {
                            var e = d[t];
                            e.is_active && (e.time++, e.applyForce(b), e.applyDrag(.01), e.updateVelocity(), e.time > 50 && (e.size -= .7, e.a -= .009), e.a <= 0 && (e.init(new r.Vector3(0, 0, 0)), e.time = 0, e.a = 0, e.inactivate())), m[3 * t + 0] = e.velocity.x - v.velocity.x, m[3 * t + 1] = e.velocity.y - v.velocity.y, m[3 * t + 2] = e.velocity.z - v.velocity.z, y[t] = e.a, x[t] = e.size
                        }
                        v.updatePoints()
                    }(), f.force.position.applyHook(0, .004), f.force.position.applyDrag(.1), f.force.position.updateVelocity(), f.updatePosition(), f.lookAtCenter(), l.render(h, f)
            },
            L = function() {
                var t = new r.Vector2,
                    e = new r.Vector2,
                    n = new r.Vector2,
                    a = function(e, n, r) {
                        t.set(e, n), o(t), S(t), M = !0
                    },
                    s = function(t, n, r) {
                        e.set(t, n), o(e), M && S(e)
                    },
                    c = function(t, e, r) {
                        n.set(t, e), M = !1, v.anchor.set(0, 0, 0), p.force.anchor.set(0, 0, 0)
                    };
                window.addEventListener("resize", i(function() {
                    T()
                }), 1e3), u.addEventListener("mousedown", function(t) {
                    t.preventDefault(), a(t.clientX, t.clientY)
                }), u.addEventListener("mousemove", function(t) {
                    t.preventDefault(), s(t.clientX, t.clientY)
                }), u.addEventListener("mouseup", function(t) {
                    t.preventDefault(), c(t.clientX, t.clientY)
                }), u.addEventListener("touchstart", function(t) {
                    t.preventDefault(), a(t.touches[0].clientX, t.touches[0].clientY)
                }), u.addEventListener("touchmove", function(t) {
                    t.preventDefault(), s(t.touches[0].clientX, t.touches[0].clientY)
                }), u.addEventListener("touchend", function(t) {
                    t.preventDefault(), c(t.changedTouches[0].clientX, t.changedTouches[0].clientY)
                }), window.addEventListener("mouseout", function() {
                    event.preventDefault(), n.set(0, 0), M = !1, v.anchor.set(0, 0, 0), p.force.anchor.set(0, 0, 0)
                })
            };
        l.setSize(window.innerWidth, window.innerHeight), l.setClearColor(0, 1), f.position.set(1e3, 1e3, 1e3), f.lookAt(new r.Vector3), L(), E(), T(),
            function t() {
                P(), requestAnimationFrame(t)
            }()
    }
}]);